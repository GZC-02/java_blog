import{_ as p,c as o,b as a,e as l,w as i,d as n,a as t,r as d,o as u}from"./app-CUeFR5CM.js";const v={},b={id:"arraylist",tabindex:"-1"},m={class:"header-anchor",href:"#arraylist"},g={id:"linkedlist",tabindex:"-1"},y={class:"header-anchor",href:"#linkedlist"},f={id:"vector-和-stack",tabindex:"-1"},k={class:"header-anchor",href:"#vector-和-stack"},c={id:"hashset",tabindex:"-1"},q={class:"header-anchor",href:"#hashset"},x={id:"linkedhashset",tabindex:"-1"},L={class:"header-anchor",href:"#linkedhashset"},M={href:"https://javabetter.cn/oo/this-super.html",target:"_blank",rel:"noopener noreferrer"},w={id:"treeset",tabindex:"-1"},C={class:"header-anchor",href:"#treeset"},S={id:"queue",tabindex:"-1"},A={class:"header-anchor",href:"#queue"},E={id:"arraydeque",tabindex:"-1"},j={class:"header-anchor",href:"#arraydeque"},I={id:"linkedlist-1",tabindex:"-1"},H={class:"header-anchor",href:"#linkedlist-1"},T={id:"priorityqueue",tabindex:"-1"},D={class:"header-anchor",href:"#priorityqueue"},N={id:"map",tabindex:"-1"},O={class:"header-anchor",href:"#map"},z={id:"hashmap",tabindex:"-1"},V={class:"header-anchor",href:"#hashmap"},P={id:"linkedhashmap",tabindex:"-1"},F={class:"header-anchor",href:"#linkedhashmap"},K={id:"treemap",tabindex:"-1"},R={class:"header-anchor",href:"#treemap"},B={href:"https://javabetter.cn/collection/treemap.html",target:"_blank",rel:"noopener noreferrer"},Q={href:"https://javabetter.cn/oo/native-method.html",target:"_blank",rel:"noopener noreferrer"},U={id:"更新-arraylist-中的元素",tabindex:"-1"},J={class:"header-anchor",href:"#更新-arraylist-中的元素"},Y={id:"删除-arraylist-中的元素",tabindex:"-1"},$={class:"header-anchor",href:"#删除-arraylist-中的元素"},W={id:"查找-arraylist-中的元素",tabindex:"-1"},X={class:"header-anchor",href:"#查找-arraylist-中的元素"},G={id:"二分查找法",tabindex:"-1"},Z={class:"header-anchor",href:"#二分查找法"},h={href:"https://javabetter.cn/common-tool/collections.html",target:"_blank",rel:"noopener noreferrer"},_={id:"arraylist增删改查时的时间复杂度",tabindex:"-1"},ss={class:"header-anchor",href:"#arraylist增删改查时的时间复杂度"},ns={id:"查询",tabindex:"-1"},ls={class:"header-anchor",href:"#查询"},es={id:"插入",tabindex:"-1"},is={class:"header-anchor",href:"#插入"},as={id:"删除",tabindex:"-1"},ts={class:"header-anchor",href:"#删除"},rs={id:"修改",tabindex:"-1"},ds={class:"header-anchor",href:"#修改"},ps={id:"总结",tabindex:"-1"},os={class:"header-anchor",href:"#总结"},us={href:"https://javabetter.cn/collection/linkedlist.html#_02%E3%80%81linkedlist%E7%9A%84%E6%8B%9B%E5%BC%8F",target:"_blank",rel:"noopener noreferrer"},vs={id:"招式一-增",tabindex:"-1"},bs={class:"header-anchor",href:"#招式一-增"},ms={id:"招式二-删",tabindex:"-1"},gs={class:"header-anchor",href:"#招式二-删"},ys={id:"招式三-改",tabindex:"-1"},fs={class:"header-anchor",href:"#招式三-改"},ks={id:"招式四-查",tabindex:"-1"},cs={class:"header-anchor",href:"#招式四-查"},qs={id:"linkedlist-的挑战",tabindex:"-1"},xs={class:"header-anchor",href:"#linkedlist-的挑战"},Ls={href:"https://javabetter.cn/collection/list-war-2.html",target:"_blank",rel:"noopener noreferrer"},Ms={id:"linkedlist-的应用",tabindex:"-1"},ws={class:"header-anchor",href:"#linkedlist-的应用"},Cs={href:"https://paicoding.com/column/7/2",target:"_blank",rel:"noopener noreferrer"},Ss={href:"https://paicoding.com/column/7/19",target:"_blank",rel:"noopener noreferrer"},As={id:"栈数据结构",tabindex:"-1"},Es={class:"header-anchor",href:"#栈数据结构"},js={href:"https://javabetter.cn/collection/stack.html#%E6%A0%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84",target:"_blank",rel:"noopener noreferrer"},Is={id:"自定义栈",tabindex:"-1"},Hs={class:"header-anchor",href:"#自定义栈"},Ts={href:"https://javabetter.cn/collection/stack.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%88",target:"_blank",rel:"noopener noreferrer"},Ds={id:"stack-类",tabindex:"-1"},Ns={class:"header-anchor",href:"#stack-类"},Os={href:"https://javabetter.cn/collection/stack.html#stack-%E7%B1%BB",target:"_blank",rel:"noopener noreferrer"},zs={href:"https://javabetter.cn/thread/synchronized-1.html",target:"_blank",rel:"noopener noreferrer"},Vs={id:"小结",tabindex:"-1"},Ps={class:"header-anchor",href:"#小结"},Fs={href:"https://javabetter.cn/collection/stack.html#%E5%B0%8F%E7%BB%93",target:"_blank",rel:"noopener noreferrer"},Ks={href:"https://paicoding.com/column/7/20",target:"_blank",rel:"noopener noreferrer"},Rs={id:"hashmap-详解-附源码",tabindex:"-1"},Bs={class:"header-anchor",href:"#hashmap-详解-附源码"},Qs={id:"hashmap-增删改查的简单例子",tabindex:"-1"},Us={class:"header-anchor",href:"#hashmap-增删改查的简单例子"},Js={id:"hash-方法的原理",tabindex:"-1"},Ys={class:"header-anchor",href:"#hash-方法的原理"},$s={id:"hash-方法的作用",tabindex:"-1"},Ws={class:"header-anchor",href:"#hash-方法的作用"},Xs={id:"取模运算-vs-取余运算-vs-与运算",tabindex:"-1"},Gs={class:"header-anchor",href:"#取模运算-vs-取余运算-vs-与运算"},Zs={id:"取模运算-和位运算",tabindex:"-1"},hs={class:"header-anchor",href:"#取模运算-和位运算"},_s={id:"为什么取模运算之前要调用-hash-方法呢",tabindex:"-1"},sn={class:"header-anchor",href:"#为什么取模运算之前要调用-hash-方法呢"},nn={id:"小结-1",tabindex:"-1"},ln={class:"header-anchor",href:"#小结-1"},en={id:"hashmap-的扩容机制",tabindex:"-1"},an={class:"header-anchor",href:"#hashmap-的扩容机制"},tn={id:"resize-方法",tabindex:"-1"},rn={class:"header-anchor",href:"#resize-方法"},dn={id:"新容量-newcapacity",tabindex:"-1"},pn={class:"header-anchor",href:"#新容量-newcapacity"},on={id:"transfer-方法",tabindex:"-1"},un={class:"header-anchor",href:"#transfer-方法"},vn={id:"拉链法",tabindex:"-1"},bn={class:"header-anchor",href:"#拉链法"},mn={id:"java-8-扩容",tabindex:"-1"},gn={class:"header-anchor",href:"#java-8-扩容"},yn={id:"小结-2",tabindex:"-1"},fn={class:"header-anchor",href:"#小结-2"},kn={href:"https://javabetter.cn/collection/hashmap.html#%E5%B0%8F%E7%BB%93-1",target:"_blank",rel:"noopener noreferrer"},cn={id:"加载因子为什么是-0-75",tabindex:"-1"},qn={class:"header-anchor",href:"#加载因子为什么是-0-75"},xn={id:"小结-3",tabindex:"-1"},Ln={class:"header-anchor",href:"#小结-3"},Mn={href:"https://javabetter.cn/collection/hashmap.html#%E5%B0%8F%E7%BB%93-2",target:"_blank",rel:"noopener noreferrer"},wn={id:"线程不安全",tabindex:"-1"},Cn={class:"header-anchor",href:"#线程不安全"},Sn={id:"多线程下扩容会死循环",tabindex:"-1"},An={class:"header-anchor",href:"#多线程下扩容会死循环"},En={id:"多线程下-put-会导致元素丢失",tabindex:"-1"},jn={class:"header-anchor",href:"#多线程下-put-会导致元素丢失"},In={id:"put-和-get-并发时会导致-get-到-null",tabindex:"-1"},Hn={class:"header-anchor",href:"#put-和-get-并发时会导致-get-到-null"},Tn={href:"https://blog.csdn.net/lonyw/article/details/80519652",target:"_blank",rel:"noopener noreferrer"},Dn={href:"https://zhuanlan.zhihu.com/p/91636401",target:"_blank",rel:"noopener noreferrer"},Nn={href:"https://www.zhihu.com/question/20733617",target:"_blank",rel:"noopener noreferrer"},On={href:"https://zhuanlan.zhihu.com/p/21673805",target:"_blank",rel:"noopener noreferrer"},zn={id:"小结-4",tabindex:"-1"},Vn={class:"header-anchor",href:"#小结-4"},Pn={id:"小结-5",tabindex:"-1"},Fn={class:"header-anchor",href:"#小结-5"},Kn={href:"https://paicoding.com/column/7/1",target:"_blank",rel:"noopener noreferrer"},Rn={href:"https://paicoding.com/column/7/13",target:"_blank",rel:"noopener noreferrer"},Bn={id:"插入顺序",tabindex:"-1"},Qn={class:"header-anchor",href:"#插入顺序"},Un={id:"访问顺序",tabindex:"-1"},Jn={class:"header-anchor",href:"#访问顺序"},Yn={id:"lru-缓存",tabindex:"-1"},$n={class:"header-anchor",href:"#lru-缓存"},Wn={id:"小结-6",tabindex:"-1"},Xn={class:"header-anchor",href:"#小结-6"},Gn={id:"treemap-详解",tabindex:"-1"},Zn={class:"header-anchor",href:"#treemap-详解"},hn={id:"自然顺序",tabindex:"-1"},_n={class:"header-anchor",href:"#自然顺序"},sl={id:"自定义排序",tabindex:"-1"},nl={class:"header-anchor",href:"#自定义排序"},ll={id:"排序的好处",tabindex:"-1"},el={class:"header-anchor",href:"#排序的好处"},il={id:"如何选择-map",tabindex:"-1"},al={class:"header-anchor",href:"#如何选择-map"},tl={id:"双端队列-arraydeque",tabindex:"-1"},rl={class:"header-anchor",href:"#双端队列-arraydeque"},dl={href:"https://javabetter.cn/collection/gailan.html",target:"_blank",rel:"noopener noreferrer"},pl={id:"栈和队列",tabindex:"-1"},ol={class:"header-anchor",href:"#栈和队列"},ul={href:"https://javabetter.cn/collection/linkedlist.html",target:"_blank",rel:"noopener noreferrer"},vl={id:"方法剖析",tabindex:"-1"},bl={class:"header-anchor",href:"#方法剖析"},ml={id:"addfirst",tabindex:"-1"},gl={class:"header-anchor",href:"#addfirst"},yl={id:"addlast",tabindex:"-1"},fl={class:"header-anchor",href:"#addlast"},kl={id:"pollfirst",tabindex:"-1"},cl={class:"header-anchor",href:"#pollfirst"},ql={id:"polllast",tabindex:"-1"},xl={class:"header-anchor",href:"#polllast"},Ll={id:"peekfirst",tabindex:"-1"},Ml={class:"header-anchor",href:"#peekfirst"},wl={id:"peeklast",tabindex:"-1"},Cl={class:"header-anchor",href:"#peeklast"},Sl={id:"小结-7",tabindex:"-1"},Al={class:"header-anchor",href:"#小结-7"},El={href:"https://javabetter.cn/collection/arraydeque.html#%E5%B0%8F%E7%BB%93",target:"_blank",rel:"noopener noreferrer"},jl={id:"优先队列-priorityqueue",tabindex:"-1"},Il={class:"header-anchor",href:"#优先队列-priorityqueue"},Hl={id:"priorityqueue的作用",tabindex:"-1"},Tl={class:"header-anchor",href:"#priorityqueue的作用"},Dl={href:"https://javabetter.cn/collection/PriorityQueue.html#priorityqueue%E7%9A%84%E4%BD%9C%E7%94%A8",target:"_blank",rel:"noopener noreferrer"},Nl={id:"方法剖析-1",tabindex:"-1"},Ol={class:"header-anchor",href:"#方法剖析-1"},zl={href:"https://javabetter.cn/collection/PriorityQueue.html#%E6%96%B9%E6%B3%95%E5%89%96%E6%9E%90",target:"_blank",rel:"noopener noreferrer"},Vl={id:"add-和-offer",tabindex:"-1"},Pl={class:"header-anchor",href:"#add-和-offer"},Fl={href:"https://javabetter.cn/collection/PriorityQueue.html#add-%E5%92%8C-offer",target:"_blank",rel:"noopener noreferrer"},Kl={id:"element-和-peek",tabindex:"-1"},Rl={class:"header-anchor",href:"#element-和-peek"},Bl={href:"https://javabetter.cn/collection/PriorityQueue.html#element-%E5%92%8C-peek",target:"_blank",rel:"noopener noreferrer"},Ql={id:"remove-和-poll",tabindex:"-1"},Ul={class:"header-anchor",href:"#remove-和-poll"},Jl={href:"https://javabetter.cn/collection/PriorityQueue.html#remove-%E5%92%8C-poll",target:"_blank",rel:"noopener noreferrer"},Yl={id:"remove-object-o",tabindex:"-1"},$l={class:"header-anchor",href:"#remove-object-o"},Wl={href:"https://javabetter.cn/collection/PriorityQueue.html#remove-object-o",target:"_blank",rel:"noopener noreferrer"},Xl={id:"小结-8",tabindex:"-1"},Gl={class:"header-anchor",href:"#小结-8"},Zl={href:"https://javabetter.cn/collection/PriorityQueue.html#%E5%B0%8F%E7%BB%93",target:"_blank",rel:"noopener noreferrer"},hl={href:"https://paicoding.com/column/7/23",target:"_blank",rel:"noopener noreferrer"},_l={id:"arraylist-和-linkedlist-区别",tabindex:"-1"},se={class:"header-anchor",href:"#arraylist-和-linkedlist-区别"},ne={id:"arraylist-是如何实现的",tabindex:"-1"},le={class:"header-anchor",href:"#arraylist-是如何实现的"},ee={id:"linkedlist-是如何实现的",tabindex:"-1"},ie={class:"header-anchor",href:"#linkedlist-是如何实现的"},ae={id:"新增元素时究竟谁快",tabindex:"-1"},te={class:"header-anchor",href:"#新增元素时究竟谁快"},re={id:"arraylist-1",tabindex:"-1"},de={class:"header-anchor",href:"#arraylist-1"},pe={id:"linkedlist-3",tabindex:"-1"},oe={class:"header-anchor",href:"#linkedlist-3"},ue={id:"删除元素时究竟谁快",tabindex:"-1"},ve={class:"header-anchor",href:"#删除元素时究竟谁快"},be={id:"arraylist-2",tabindex:"-1"},me={class:"header-anchor",href:"#arraylist-2"},ge={id:"linkedlist-4",tabindex:"-1"},ye={class:"header-anchor",href:"#linkedlist-4"},fe={id:"遍历元素时究竟谁快",tabindex:"-1"},ke={class:"header-anchor",href:"#遍历元素时究竟谁快"},ce={id:"arraylist-3",tabindex:"-1"},qe={class:"header-anchor",href:"#arraylist-3"},xe={id:"linkedlist-5",tabindex:"-1"},Le={class:"header-anchor",href:"#linkedlist-5"},Me={id:"两者的使用场景",tabindex:"-1"},we={class:"header-anchor",href:"#两者的使用场景"},Ce={id:"关于fail-fast",tabindex:"-1"},Se={class:"header-anchor",href:"#关于fail-fast"},Ae={href:"https://javabetter.cn/collection/fail-fast.html#%E5%85%B3%E4%BA%8Efail-fast",target:"_blank",rel:"noopener noreferrer"},Ee={id:"for-each-删除元素报错",tabindex:"-1"},je={class:"header-anchor",href:"#for-each-删除元素报错"},Ie={href:"https://javabetter.cn/collection/fail-fast.html#for-each-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E6%8A%A5%E9%94%99",target:"_blank",rel:"noopener noreferrer"},He={id:"分析代码执行的逻辑",tabindex:"-1"},Te={class:"header-anchor",href:"#分析代码执行的逻辑"},De={href:"https://javabetter.cn/collection/fail-fast.html#%E5%88%86%E6%9E%90%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E7%9A%84%E9%80%BB%E8%BE%91",target:"_blank",rel:"noopener noreferrer"},Ne={id:"那该如何正确地删除元素呢",tabindex:"-1"},Oe={class:"header-anchor",href:"#那该如何正确地删除元素呢"},ze={href:"https://javabetter.cn/collection/fail-fast.html#%E9%82%A3%E8%AF%A5%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%9C%B0%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E5%91%A2",target:"_blank",rel:"noopener noreferrer"},Ve={id:"_1-remove-后-break",tabindex:"-1"},Pe={class:"header-anchor",href:"#_1-remove-后-break"},Fe={href:"https://javabetter.cn/collection/fail-fast.html#_1-remove-%E5%90%8E-break",target:"_blank",rel:"noopener noreferrer"},Ke={id:"_2-for-循环",tabindex:"-1"},Re={class:"header-anchor",href:"#_2-for-循环"},Be={href:"https://javabetter.cn/collection/fail-fast.html#_2-for-%E5%BE%AA%E7%8E%AF",target:"_blank",rel:"noopener noreferrer"},Qe={id:"_3-使用-iterator",tabindex:"-1"},Ue={class:"header-anchor",href:"#_3-使用-iterator"},Je={href:"https://javabetter.cn/collection/fail-fast.html#_3-%E4%BD%BF%E7%94%A8-iterator",target:"_blank",rel:"noopener noreferrer"},Ye={id:"小结-9",tabindex:"-1"},$e={class:"header-anchor",href:"#小结-9"},We={href:"https://javabetter.cn/collection/fail-fast.html#%E5%B0%8F%E7%BB%93",target:"_blank",rel:"noopener noreferrer"},Xe={id:"comparable-和-comparator",tabindex:"-1"},Ge={class:"header-anchor",href:"#comparable-和-comparator"},Ze={id:"comparable",tabindex:"-1"},he={class:"header-anchor",href:"#comparable"},_e={id:"comparator",tabindex:"-1"},si={class:"header-anchor",href:"#comparator"},ni={id:"原封不动的-cmower-类。",tabindex:"-1"},li={class:"header-anchor",href:"#原封不动的-cmower-类。"},ei={id:"再来看-comparator-接口的实现类。",tabindex:"-1"},ii={class:"header-anchor",href:"#再来看-comparator-接口的实现类。"},ai={id:"再来看测试类。",tabindex:"-1"},ti={class:"header-anchor",href:"#再来看测试类。"},ri={href:"https://javabetter.cn/basic-extra-meal/generic.html",target:"_blank",rel:"noopener noreferrer"},di={id:"到底该用哪一个",tabindex:"-1"},pi={class:"header-anchor",href:"#到底该用哪一个"},oi={id:"weakhashmap如何不阻止对象回收呢",tabindex:"-1"},ui={class:"header-anchor",href:"#weakhashmap如何不阻止对象回收呢"},vi={href:"https://javabetter.cn/collection/WeakHashMap.html#weakhashmap%E5%A6%82%E4%BD%95%E4%B8%8D%E9%98%BB%E6%AD%A2%E5%AF%B9%E8%B1%A1%E5%9B%9E%E6%94%B6%E5%91%A2",target:"_blank",rel:"noopener noreferrer"},bi={id:"如何删除被回收的key数据呢",tabindex:"-1"},mi={class:"header-anchor",href:"#如何删除被回收的key数据呢"},gi={href:"https://javabetter.cn/collection/WeakHashMap.html#%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4%E8%A2%AB%E5%9B%9E%E6%94%B6%E7%9A%84key%E6%95%B0%E6%8D%AE%E5%91%A2",target:"_blank",rel:"noopener noreferrer"},yi={id:"compute-简介-java-8-新增",tabindex:"-1"},fi={class:"header-anchor",href:"#compute-简介-java-8-新增"},ki={id:"compute有啥用",tabindex:"-1"},ci={class:"header-anchor",href:"#compute有啥用"},qi={id:"compute-源码分析",tabindex:"-1"},xi={class:"header-anchor",href:"#compute-源码分析"},Li={id:"方法定义",tabindex:"-1"},Mi={class:"header-anchor",href:"#方法定义"};function wi(Ci,s){const e=d("font"),r=d("ExternalLinkIcon");return u(),o("div",null,[s[2537]||(s[2537]=a("h2",{id:"集合体系结构",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#集合体系结构"},[a("span",null,"集合体系结构")])],-1)),s[2538]||(s[2538]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726665524007-aea7bc67-01cf-43c8-878f-a3c56cd1e147.png"},null,-1)),s[2539]||(s[2539]=a("p",null,[a("strong",null,"java 集合框架分为两大支线")],-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[0]||(s[0]=[n("① Collection，主要由 List、Set、Queue 组成：")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1]||(s[1]=[n("List 代表")])),_:1}),s[8]||(s[8]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2]||(s[2]=[n("有序")])),_:1}),s[9]||(s[9]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[3]||(s[3]=[n("、")])),_:1}),s[10]||(s[10]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[4]||(s[4]=[n("可重复")])),_:1}),s[11]||(s[11]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[5]||(s[5]=[n("的")])),_:1}),s[12]||(s[12]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[6]||(s[6]=[n("集合")])),_:1}),s[13]||(s[13]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[7]||(s[7]=[n("，典型代表就是封装了动态数组的 ArrayList 和封装了链表的 LinkedList；")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[14]||(s[14]=[n("Set 代表")])),_:1}),s[21]||(s[21]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[15]||(s[15]=[n("无序")])),_:1}),s[22]||(s[22]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[16]||(s[16]=[n("、")])),_:1}),s[23]||(s[23]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[17]||(s[17]=[n("不可重复")])),_:1}),s[24]||(s[24]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[18]||(s[18]=[n("的")])),_:1}),s[25]||(s[25]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[19]||(s[19]=[n("集合")])),_:1}),s[26]||(s[26]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[20]||(s[20]=[n("，典型代表就是 HashSet 和 TreeSet；")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[27]||(s[27]=[n("Queue 代表队列，典型代表就是双端队列")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[28]||(s[28]=[n("ArrayDeque")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[29]||(s[29]=[n("，以及优先级队列")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[30]||(s[30]=[n("PriorityQueue")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[31]||(s[31]=[n("。")])),_:1})])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[32]||(s[32]=[n("② Map，代表键值对的集合，典型代表就是 HashMap")])),_:1}),s[2540]||(s[2540]=a("h2",{id:"list",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#list"},[a("span",null,"List")])],-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[33]||(s[33]=[n("特点是存取有序，可以存放重复的元素，可以用下标对元素进行操作。")])),_:1}),a("h3",b,[a("a",m,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[34]||(s[34]=[n("ArrayList")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[35]||(s[35]=[n("先来一段 ArrayList 的增删改查，学会用。")])),_:1}),s[2541]||(s[2541]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">// 创建一个集合</span>
<span class="line">ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</span>
<span class="line">// 添加元素</span>
<span class="line">list.add(&quot;王二&quot;);</span>
<span class="line">list.add(&quot;沉默&quot;);</span>
<span class="line">list.add(&quot;陈清扬&quot;);</span>
<span class="line"></span>
<span class="line">// 遍历集合 for 循环</span>
<span class="line">for (int i = 0; i &lt; list.size(); i++) {</span>
<span class="line">    String s = list.get(i);</span>
<span class="line">    System.out.println(s);</span>
<span class="line">}</span>
<span class="line">// 遍历集合 for each</span>
<span class="line">for (String s : list) {</span>
<span class="line">    System.out.println(s);</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">// 删除元素</span>
<span class="line">list.remove(1);</span>
<span class="line">// 遍历集合</span>
<span class="line">for (String s : list) {</span>
<span class="line">    System.out.println(s);</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">// 修改元素</span>
<span class="line">list.set(1, &quot;王二狗&quot;);</span>
<span class="line">// 遍历集合</span>
<span class="line">for (String s : list) {</span>
<span class="line">    System.out.println(s);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[36]||(s[36]=[n("简单介绍一下 ArrayList 的特征，")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[37]||(s[37]=[n("后面还会详细讲")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[38]||(s[38]=[n("。")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[39]||(s[39]=[n("ArrayList 是由")])),_:1}),s[42]||(s[42]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[40]||(s[40]=[n("数组")])),_:1}),s[43]||(s[43]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[41]||(s[41]=[n("实现的，支持随机存取，也就是可以通过下标直接存取元素；")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[44]||(s[44]=[n("从")])),_:1}),s[49]||(s[49]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[45]||(s[45]=[n("尾部插入和删除元素会比较快捷")])),_:1}),s[50]||(s[50]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[46]||(s[46]=[n("，从")])),_:1}),s[51]||(s[51]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[47]||(s[47]=[n("中间插入和删除元素会比较低效")])),_:1}),s[52]||(s[52]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[48]||(s[48]=[n("，因为涉及到数组元素的复制和移动；")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[53]||(s[53]=[n("如果内部数组的容量不足时会自动扩容，因此当元素非常庞大的时候，效率会比较低。")])),_:1})])]),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}}),a("h3",g,[a("a",y,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[54]||(s[54]=[n("LinkedList")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[55]||(s[55]=[n("来一段 LinkedList 的增删改查，和 ArrayList 几乎没什么差别。")])),_:1}),s[2542]||(s[2542]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">// 创建一个集合</span>
<span class="line">LinkedList&lt;String&gt; list = new LinkedList&lt;String&gt;();</span>
<span class="line">// 添加元素</span>
<span class="line">list.add(&quot;王二&quot;);</span>
<span class="line">list.add(&quot;沉默&quot;);</span>
<span class="line">list.add(&quot;陈清扬&quot;);</span>
<span class="line"></span>
<span class="line">// 遍历集合 for 循环</span>
<span class="line">for (int i = 0; i &lt; list.size(); i++) {</span>
<span class="line">    String s = list.get(i);</span>
<span class="line">    System.out.println(s);</span>
<span class="line">}</span>
<span class="line">// 遍历集合 for each</span>
<span class="line">for (String s : list) {</span>
<span class="line">    System.out.println(s);</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">// 删除元素</span>
<span class="line">list.remove(1);</span>
<span class="line">// 遍历集合</span>
<span class="line">for (String s : list) {</span>
<span class="line">    System.out.println(s);</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">// 修改元素</span>
<span class="line">list.set(1, &quot;王二狗&quot;);</span>
<span class="line">// 遍历集合</span>
<span class="line">for (String s : list) {</span>
<span class="line">    System.out.println(s);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[56]||(s[56]=[n("不过，LinkedList 和 ArrayList 仍然有较大的不同，")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[57]||(s[57]=[n("后面也会详细地讲")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[58]||(s[58]=[n("。")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[59]||(s[59]=[n("LinkedList 是由")])),_:1}),s[66]||(s[66]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[60]||(s[60]=[n("双向链表")])),_:1}),s[67]||(s[67]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[61]||(s[61]=[n("实现的，")])),_:1}),s[68]||(s[68]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[62]||(s[62]=[n("不支持随机存取")])),_:1}),s[69]||(s[69]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[63]||(s[63]=[n("，")])),_:1}),s[70]||(s[70]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[64]||(s[64]=[n("只能从一端开始遍历，直到找到需要的元素后返回")])),_:1}),s[71]||(s[71]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[65]||(s[65]=[n("；")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[72]||(s[72]=[n("任意位置")])),_:1}),s[75]||(s[75]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[73]||(s[73]=[n("插入和删除元素都很方便")])),_:1}),s[76]||(s[76]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[74]||(s[74]=[n("，因为只需要改变前一个节点和后一个节点的引用即可，不像 ArrayList 那样需要复制和移动数组元素；")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[77]||(s[77]=[n("因为每个元素都存储了前一个和后一个节点的引用，所以相对来说，")])),_:1}),s[80]||(s[80]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[78]||(s[78]=[n("占用的内存空间会比 ArrayList 多")])),_:1}),s[81]||(s[81]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[79]||(s[79]=[n("一些。")])),_:1})])]),a("h3",f,[a("a",k,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[82]||(s[82]=[n("Vector 和 Stack")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[83]||(s[83]=[n("List 的实现类还有一个 Vector，是一个元老级的类，比 ArrayList 出现得更早。ArrayList 和 Vector 非常相似，只不过 ")])),_:1}),s[2543]||(s[2543]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[84]||(s[84]=[n("Vector 是线程安全")])),_:1}),s[2544]||(s[2544]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[85]||(s[85]=[n("的，像 get、set、add 这些方法都加了 ")])),_:1}),s[2545]||(s[2545]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[86]||(s[86]=[n("synchronized")])),_:1}),s[2546]||(s[2546]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[87]||(s[87]=[n(" 关键字，就导致执行效率会比较低，所以现在已经很少用了。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[88]||(s[88]=[n("我就不写太多代码了，只看一下 add 方法的源码就明白了。")])),_:1}),s[2547]||(s[2547]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public synchronized boolean add(E e) {</span>
<span class="line">    elementData[elementCount++] = e;</span>
<span class="line">    return true;</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[89]||(s[89]=[n("这种加了同步方法的类，注定会被淘汰掉，就像 ")])),_:1}),s[2548]||(s[2548]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[90]||(s[90]=[n("StringBuilder 取代 StringBuffer")])),_:1}),s[2549]||(s[2549]=n("](https://javabetter.cn/string/builder-buffer.html)")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[91]||(s[91]=[n(" 那样。JDK 源码也说了：")])),_:1}),l(e,{style:{color:"rgb(102, 102, 102)"}},{default:i(()=>s[92]||(s[92]=[n("如果不需要线程安全，建议使用 ArrayList 代替 Vector。")])),_:1}),s[2550]||(s[2550]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726665868134-6a53698b-5b79-4b8d-96c1-0d97c124f6a1.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[93]||(s[93]=[n("Stack 是 Vector 的一个子类，本质上也是由")])),_:1}),s[2551]||(s[2551]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[94]||(s[94]=[n("动态数组实现")])),_:1}),s[2552]||(s[2552]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[95]||(s[95]=[n("的，只不过还实现了先进后出的功能（在 get、set、add 方法的基础上追加了 pop「返回并移除栈顶的元素」、peek「只返回栈顶元素」等方法），所以叫")])),_:1}),s[2553]||(s[2553]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[96]||(s[96]=[n("栈")])),_:1}),s[2554]||(s[2554]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[97]||(s[97]=[n("。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[98]||(s[98]=[n("下面是这两个方法的源码，增删改查我就不写了，和 ArrayList 和 LinkedList 几乎一样。")])),_:1}),s[2555]||(s[2555]=t(`<div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token class-name">E</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">E</span> obj<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    obj <span class="token operator">=</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token function">removeElementAt</span><span class="token punctuation">(</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">return</span> obj<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token class-name">E</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span></span>
<span class="line">        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">EmptyStackException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token function">elementAt</span><span class="token punctuation">(</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[99]||(s[99]=[n("不过，由于 Stack 执行效率比较低（方法上同样加了 synchronized 关键字），就被双端队列 ArrayDeque 取代了（下面会介绍）。")])),_:1}),s[2556]||(s[2556]=a("h4",{id:"",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#"},[a("span")])],-1)),s[2557]||(s[2557]=a("h2",{id:"set",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#set"},[a("span",null,"Set")])],-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[100]||(s[100]=[n("Set 的特点是存取无序，不可以存放重复的元素，不可以用下标对元素进行操作，和 List 有很多不同。")])),_:1}),a("h3",c,[a("a",q,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[101]||(s[101]=[n("HashSet")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[102]||(s[102]=[n("HashSet 其实是由 ")])),_:1}),s[2558]||(s[2558]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[103]||(s[103]=[n("HashMap 实现")])),_:1}),s[2559]||(s[2559]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[104]||(s[104]=[n("的，只不过")])),_:1}),s[2560]||(s[2560]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[105]||(s[105]=[n("值由一个固定的 Object 对象填充，而键用于操作")])),_:1}),s[2561]||(s[2561]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[106]||(s[106]=[n("。来简单看一下它的源码。")])),_:1}),s[2562]||(s[2562]=t(`<div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> </span>
<span class="line">    <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> map<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// Dummy value to associate with an Object in the backing Map</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> <span class="token constant">PRESENT</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token constant">PRESENT</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token operator">==</span><span class="token constant">PRESENT</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[107]||(s[107]=[n("实际开发中，HashSet 并不常用，比如，如果我们需要按照顺序存储一组元素，那么 ArrayList 和 LinkedList 可能更适合；如果我们需要存储键值对并根据键进行查找，那么 HashMap 可能更适合。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[108]||(s[108]=[n("来一段增删改查体验一下：")])),_:1}),s[2563]||(s[2563]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">// 创建一个新的HashSet</span>
<span class="line">HashSet&lt;String&gt; set = new HashSet&lt;&gt;();</span>
<span class="line"></span>
<span class="line">// 添加元素</span>
<span class="line">set.add(&quot;沉默&quot;);</span>
<span class="line">set.add(&quot;王二&quot;);</span>
<span class="line">set.add(&quot;陈清扬&quot;);</span>
<span class="line"></span>
<span class="line">// 输出HashSet的元素个数</span>
<span class="line">System.out.println(&quot;HashSet size: &quot; + set.size()); // output: 3</span>
<span class="line"></span>
<span class="line">// 判断元素是否存在于HashSet中</span>
<span class="line">boolean containsWanger = set.contains(&quot;王二&quot;);</span>
<span class="line">System.out.println(&quot;Does set contain &#39;王二&#39;? &quot; + containsWanger); // output: true</span>
<span class="line"></span>
<span class="line">// 删除元素</span>
<span class="line">boolean removeWanger = set.remove(&quot;王二&quot;);</span>
<span class="line">System.out.println(&quot;Removed &#39;王二&#39;? &quot; + removeWanger); // output: true</span>
<span class="line"></span>
<span class="line">// 修改元素，需要先删除后添加</span>
<span class="line">boolean removeChenmo = set.remove(&quot;沉默&quot;);</span>
<span class="line">boolean addBuChenmo = set.add(&quot;不沉默&quot;);</span>
<span class="line">System.out.println(&quot;Modified set? &quot; + (removeChenmo &amp;&amp; addBuChenmo)); // output: true</span>
<span class="line"></span>
<span class="line">// 输出修改后的HashSet</span>
<span class="line">System.out.println(&quot;HashSet after modification: &quot; + set); // output: [陈清扬, 不沉默]</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[109]||(s[109]=[n("HashSet 主要用于去重，比如，我们需要统计一篇文章中有多少个不重复的单词，就可以使用 HashSet 来实现。")])),_:1}),s[2564]||(s[2564]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">// 创建一个 HashSet 对象</span>
<span class="line">HashSet&lt;String&gt; set = new HashSet&lt;&gt;();</span>
<span class="line"></span>
<span class="line">// 添加元素</span>
<span class="line">set.add(&quot;沉默&quot;);</span>
<span class="line">set.add(&quot;王二&quot;);</span>
<span class="line">set.add(&quot;陈清扬&quot;);</span>
<span class="line">set.add(&quot;沉默&quot;);</span>
<span class="line"></span>
<span class="line">// 输出 HashSet 的元素个数</span>
<span class="line">System.out.println(&quot;HashSet size: &quot; + set.size()); // output: 3</span>
<span class="line"></span>
<span class="line">// 遍历 HashSet</span>
<span class="line">for (String s : set) {</span>
<span class="line">    System.out.println(s);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[110]||(s[110]=[n("从上面的例子可以看得出，HashSet 会自动去重，因为它是用 HashMap 实现的，")])),_:1}),s[2565]||(s[2565]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[111]||(s[111]=[n("HashMap")])),_:1}),s[2566]||(s[2566]=n("](https://javabetter.cn/collection/hashmap.html)")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[112]||(s[112]=[n("的键是唯一的（哈希值），相同键的值会覆盖掉原来的值，于是第二次")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2567]||(s[2567]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[113]||(s[113]=[n('set.add("沉默")')])),_:1}),s[2568]||(s[2568]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[114]||(s[114]=[n("的时候就覆盖了第一次的")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2569]||(s[2569]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[115]||(s[115]=[n('set.add("沉默")')])),_:1}),s[2570]||(s[2570]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[116]||(s[116]=[n("。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[117]||(s[117]=[n("我在《")])),_:1}),s[2571]||(s[2571]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[118]||(s[118]=[n("LeetCode 的第 15 题：三数之和")])),_:1}),s[2572]||(s[2572]=n("](https://paicoding.com/column/7/15)")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[119]||(s[119]=[n("》的时候用到了 HashSet，大家可以通过链接去查看一下。")])),_:1}),a("h3",x,[a("a",L,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[120]||(s[120]=[n("LinkedHashSet")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[121]||(s[121]=[n("LinkedHashSet 虽然继承自 HashSet，其实是由")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2573]||(s[2573]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[122]||(s[122]=[n("LinkedHashMap")])),_:1}),s[2574]||(s[2574]=n("](https://javabetter.cn/collection/linkedhashmap.html)")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[123]||(s[123]=[n("实现的。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[124]||(s[124]=[n("这是 LinkedHashSet 的无参构造方法：")])),_:1}),s[2575]||(s[2575]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public LinkedHashSet() {</span>
<span class="line">    super(16, .75f, true);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),a("p",null,[a("a",M,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[125]||(s[125]=[n("super")])),_:1}),l(r)]),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[126]||(s[126]=[n("的意思是它将调用父类的 HashSet 的一个有参构造方法：")])),_:1})]),s[2576]||(s[2576]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">HashSet(int initialCapacity, float loadFactor, boolean dummy) {</span>
<span class="line">    map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[127]||(s[127]=[n("看到")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2577]||(s[2577]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[128]||(s[128]=[n("LinkedHashMap")])),_:1}),s[2578]||(s[2578]=n("](https://javabetter.cn/collection/linkedhashmap.html)")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[129]||(s[129]=[n("了吧，这个我们后面会去讲。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[130]||(s[130]=[n("好吧，来看一段 LinkedHashSet 的增删改查吧。")])),_:1}),s[2579]||(s[2579]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">LinkedHashSet&lt;String&gt; set = new LinkedHashSet&lt;&gt;();</span>
<span class="line"></span>
<span class="line">// 添加元素</span>
<span class="line">set.add(&quot;沉默&quot;);</span>
<span class="line">set.add(&quot;王二&quot;);</span>
<span class="line">set.add(&quot;陈清扬&quot;);</span>
<span class="line"></span>
<span class="line">// 删除元素</span>
<span class="line">set.remove(&quot;王二&quot;);</span>
<span class="line"></span>
<span class="line">// 修改元素</span>
<span class="line">set.remove(&quot;沉默&quot;);</span>
<span class="line">set.add(&quot;沉默的力量&quot;);</span>
<span class="line"></span>
<span class="line">// 查找元素</span>
<span class="line">boolean hasChenQingYang = set.contains(&quot;陈清扬&quot;);</span>
<span class="line">System.out.println(&quot;set包含陈清扬吗？&quot; + hasChenQingYang);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[131]||(s[131]=[n("在以上代码中，我们首先创建了一个 LinkedHashSet 对象，然后使用 add 方法依次添加了三个元素：沉默、王二和陈清扬。接着，我们使用 remove 方法删除了王二这个元素，并使用 remove 和 add 方法修改了沉默这个元素。最后，我们使用 contains 方法查找了陈清扬这个元素是否存在于 set 中，并打印了结果。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[132]||(s[132]=[n("LinkedHashSet 是一种基于哈希表实现的 Set 接口，它继承自 HashSet，并且使用链表维护了元素的插入顺序。因此，它既具有 HashSet 的快速查找、插入和删除操作的优点，又可以维护元素的插入顺序。")])),_:1}),a("h3",w,[a("a",C,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[133]||(s[133]=[n("TreeSet")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[134]||(s[134]=[n("“二哥，不用你讲了，我能猜到，TreeSet 是由")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2580]||(s[2580]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[135]||(s[135]=[n("TreeMap（后面会讲）")])),_:1}),s[2581]||(s[2581]=n("](https://javabetter.cn/collection/treemap.html)")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[136]||(s[136]=[n("实现的，只不过同样操作的键位，值由一个固定的 Object 对象填充。”")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[137]||(s[137]=[n("哇，三妹都学会了推理。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[138]||(s[138]=[n("是的，与 TreeMap 相似，TreeSet 是一种基于红黑树实现的有序集合，它实现了 SortedSet 接口，可以自动对集合中的元素进行排序。按照键的自然顺序或指定的比较器顺序进行排序。")])),_:1}),s[2582]||(s[2582]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">// 创建一个 TreeSet 对象</span>
<span class="line">TreeSet&lt;String&gt; set = new TreeSet&lt;&gt;();</span>
<span class="line"></span>
<span class="line">// 添加元素</span>
<span class="line">set.add(&quot;沉默&quot;);</span>
<span class="line">set.add(&quot;王二&quot;);</span>
<span class="line">set.add(&quot;陈清扬&quot;);</span>
<span class="line">System.out.println(set); // 输出 [沉默, 王二, 陈清扬]</span>
<span class="line"></span>
<span class="line">// 删除元素</span>
<span class="line">set.remove(&quot;王二&quot;);</span>
<span class="line">System.out.println(set); // 输出 [沉默, 陈清扬]</span>
<span class="line"></span>
<span class="line">// 修改元素：TreeSet 中的元素不支持直接修改，需要先删除再添加</span>
<span class="line">set.remove(&quot;陈清扬&quot;);</span>
<span class="line">set.add(&quot;陈青阳&quot;);</span>
<span class="line">System.out.println(set); // 输出 [沉默, 陈青阳]</span>
<span class="line"></span>
<span class="line">// 查找元素</span>
<span class="line">System.out.println(set.contains(&quot;沉默&quot;)); // 输出 true</span>
<span class="line">System.out.println(set.contains(&quot;王二&quot;)); // 输出 false</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[139]||(s[139]=[n("需要注意的是，TreeSet 不允许插入 null 元素，否则会抛出 NullPointerException 异常。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[140]||(s[140]=[n("“总体上来说，Set 集合不是关注的重点，因为底层都是由 Map 实现的，为什么要用 Map 实现呢？三妹你能猜到原因吗？”")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[141]||(s[141]=[n("“让我想想。”")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[142]||(s[142]=[n("“嗯？难道是因为 Map 的键不允许重复、无序吗？”")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[143]||(s[143]=[n("老天，竟然被三妹猜到了。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[144]||(s[144]=[n("“是的，你这水平长进了呀，三妹。”")])),_:1}),a("h2",S,[a("a",A,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[145]||(s[145]=[n("Queue")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[146]||(s[146]=[n("Queue，也就是队列，通常遵循先进先出（FIFO）的原则，新元素插入到队列的尾部，访问元素返回队列的头部。")])),_:1}),a("h3",E,[a("a",j,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[147]||(s[147]=[n("ArrayDeque")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[148]||(s[148]=[n("从名字上可以看得出，ArrayDeque 是一个基于数组实现的双端队列，为了满足可以同时在数组两端插入或删除元素的需求，数组必须是循环的，也就是说数组的任何一点都可以被看作是起点或者终点。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[149]||(s[149]=[n("这是一个包含了 4 个元素的双端队列，和一个包含了 5 个元素的双端队列。")])),_:1}),s[2583]||(s[2583]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726665926214-a23b14a7-d80e-4581-af43-aca1189a9896.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[150]||(s[150]=[n("head 指向队首的第一个有效的元素，tail 指向队尾第一个可以插入元素的空位，因为是循环数组，所以 head 不一定从是从 0 开始，tail 也不一定总是比 head 大。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[151]||(s[151]=[n("来一段 ArrayDeque 的增删改查吧。")])),_:1}),s[2584]||(s[2584]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">// 创建一个ArrayDeque</span>
<span class="line">ArrayDeque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();</span>
<span class="line"></span>
<span class="line">// 添加元素</span>
<span class="line">deque.add(&quot;沉默&quot;);</span>
<span class="line">deque.add(&quot;王二&quot;);</span>
<span class="line">deque.add(&quot;陈清扬&quot;);</span>
<span class="line"></span>
<span class="line">// 删除元素</span>
<span class="line">deque.remove(&quot;王二&quot;);</span>
<span class="line"></span>
<span class="line">// 修改元素</span>
<span class="line">deque.remove(&quot;沉默&quot;);</span>
<span class="line">deque.add(&quot;沉默的力量&quot;);</span>
<span class="line"></span>
<span class="line">// 查找元素</span>
<span class="line">boolean hasChenQingYang = deque.contains(&quot;陈清扬&quot;);</span>
<span class="line">System.out.println(&quot;deque包含陈清扬吗？&quot; + hasChenQingYang);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),a("h3",I,[a("a",H,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[152]||(s[152]=[n("LinkedList")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[153]||(s[153]=[n("LinkedList 一般应该归在 List 下，只不过，它也实现了 Deque 接口，可以作为队列来使用。等于说，LinkedList 同时实现了 Stack、Queue、PriorityQueue 的所有功能。")])),_:1}),s[2585]||(s[2585]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public class LinkedList&lt;E&gt;</span>
<span class="line">    extends AbstractSequentialList&lt;E&gt;</span>
<span class="line">    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span>
<span class="line">{}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[154]||(s[154]=[n("换句话说，LinkedList 和 ArrayDeque 都是 Java 集合框架中的双向队列（deque），它们都支持在队列的两端进行元素的插入和删除操作。不过，LinkedList 和 ArrayDeque 在实现上有一些不同：")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[155]||(s[155]=[n("底层实现方式不同：LinkedList 是基于链表实现的，而 ArrayDeque 是基于数组实现的。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[156]||(s[156]=[n("随机访问的效率不同：由于底层实现方式的不同，LinkedList 对于随机访问的效率较低，时间复杂度为 O(n)，而 ArrayDeque 可以通过下标随机访问元素，时间复杂度为 O(1)。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[157]||(s[157]=[n("迭代器的效率不同：LinkedList 对于迭代器的效率比较低，因为需要通过链表进行遍历，时间复杂度为 O(n)，而 ArrayDeque 的迭代器效率比较高，因为可以直接访问数组中的元素，时间复杂度为 O(1)。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[158]||(s[158]=[n("内存占用不同：由于 LinkedList 是基于链表实现的，它在存储元素时需要额外的空间来存储链表节点，因此内存占用相对较高，而 ArrayDeque 是基于数组实现的，内存占用相对较低。")])),_:1})])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[159]||(s[159]=[n("因此，在选择使用 LinkedList 还是 ArrayDeque 时，需要根据具体的业务场景和需求来选择。如果需要在双向队列的两端进行频繁的插入和删除操作，并且需要随机访问元素，可以考虑使用 ArrayDeque；如果需要在队列中间进行频繁的插入和删除操作，可以考虑使用 LinkedList。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[160]||(s[160]=[n("来一段 LinkedList 作为队列时候的增删改查吧，注意和它作为 List 的时候有很大的不同。")])),_:1}),s[2586]||(s[2586]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">// 创建一个 LinkedList 对象</span>
<span class="line">LinkedList&lt;String&gt; queue = new LinkedList&lt;&gt;();</span>
<span class="line"></span>
<span class="line">// 添加元素</span>
<span class="line">queue.offer(&quot;沉默&quot;);</span>
<span class="line">queue.offer(&quot;王二&quot;);</span>
<span class="line">queue.offer(&quot;陈清扬&quot;);</span>
<span class="line">System.out.println(queue); // 输出 [沉默, 王二, 陈清扬]</span>
<span class="line"></span>
<span class="line">// 删除元素</span>
<span class="line">queue.poll();</span>
<span class="line">System.out.println(queue); // 输出 [王二, 陈清扬]</span>
<span class="line"></span>
<span class="line">// 修改元素：LinkedList 中的元素不支持直接修改，需要先删除再添加</span>
<span class="line">String first = queue.poll();</span>
<span class="line">queue.offer(&quot;王大二&quot;);</span>
<span class="line">System.out.println(queue); // 输出 [陈清扬, 王大二]</span>
<span class="line"></span>
<span class="line">// 查找元素：LinkedList 中的元素可以使用 get() 方法进行查找</span>
<span class="line">System.out.println(queue.get(0)); // 输出 陈清扬</span>
<span class="line">System.out.println(queue.contains(&quot;沉默&quot;)); // 输出 false</span>
<span class="line"></span>
<span class="line">// 查找元素：使用迭代器的方式查找陈清扬</span>
<span class="line">// 使用迭代器依次遍历元素并查找</span>
<span class="line">Iterator&lt;String&gt; iterator = queue.iterator();</span>
<span class="line">while (iterator.hasNext()) {</span>
<span class="line">    String element = iterator.next();</span>
<span class="line">    if (element.equals(&quot;陈清扬&quot;)) {</span>
<span class="line">        System.out.println(&quot;找到了：&quot; + element);</span>
<span class="line">        break;</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[161]||(s[161]=[n("在使用 LinkedList 作为队列时，可以使用 offer() 方法将元素添加到队列的末尾，使用 poll() 方法从队列的头部删除元素。另外，由于 LinkedList 是链表结构，不支持随机访问元素，因此不能使用下标访问元素，需要使用迭代器或者 poll() 方法依次遍历元素。")])),_:1}),a("h3",T,[a("a",D,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[162]||(s[162]=[n("PriorityQueue")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[163]||(s[163]=[n("PriorityQueue 是一种优先级队列，它的出队顺序与元素的优先级有关，执行 remove 或者 poll 方法，返回的总是优先级最高的元素。")])),_:1}),s[2587]||(s[2587]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">// 创建一个 PriorityQueue 对象</span>
<span class="line">PriorityQueue&lt;String&gt; queue = new PriorityQueue&lt;&gt;();</span>
<span class="line"></span>
<span class="line">// 添加元素</span>
<span class="line">queue.offer(&quot;沉默&quot;);</span>
<span class="line">queue.offer(&quot;王二&quot;);</span>
<span class="line">queue.offer(&quot;陈清扬&quot;);</span>
<span class="line">System.out.println(queue); // 输出 [沉默, 王二, 陈清扬]</span>
<span class="line"></span>
<span class="line">// 删除元素</span>
<span class="line">queue.poll();</span>
<span class="line">System.out.println(queue); // 输出 [王二, 陈清扬]</span>
<span class="line"></span>
<span class="line">// 修改元素：PriorityQueue 不支持直接修改元素，需要先删除再添加</span>
<span class="line">String first = queue.poll();</span>
<span class="line">queue.offer(&quot;张三&quot;);</span>
<span class="line">System.out.println(queue); // 输出 [张三, 陈清扬]</span>
<span class="line"></span>
<span class="line">// 查找元素：PriorityQueue 不支持随机访问元素，只能访问队首元素</span>
<span class="line">System.out.println(queue.peek()); // 输出 张三</span>
<span class="line">System.out.println(queue.contains(&quot;陈清扬&quot;)); // 输出 true</span>
<span class="line"></span>
<span class="line">// 通过 for 循环的方式查找陈清扬</span>
<span class="line">for (String element : queue) {</span>
<span class="line">    if (element.equals(&quot;陈清扬&quot;)) {</span>
<span class="line">        System.out.println(&quot;找到了：&quot; + element);</span>
<span class="line">        break;</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[164]||(s[164]=[n("要想有优先级，元素就需要实现")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2588]||(s[2588]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[165]||(s[165]=[n("Comparable 接口或者 Comparator 接口")])),_:1}),s[2589]||(s[2589]=n("](https://javabetter.cn/basic-extra-meal/comparable-omparator.html)")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[166]||(s[166]=[n("（我们后面会讲）。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[167]||(s[167]=[n("这里先来一段通过实现 Comparator 接口按照年龄姓名排序的优先级队列吧。")])),_:1}),s[2590]||(s[2590]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">import java.util.Comparator;</span>
<span class="line">import java.util.PriorityQueue;</span>
<span class="line"></span>
<span class="line">class Student {</span>
<span class="line">    private String name;</span>
<span class="line">    private int chineseScore;</span>
<span class="line">    private int mathScore;</span>
<span class="line"></span>
<span class="line">    public Student(String name, int chineseScore, int mathScore) {</span>
<span class="line">        this.name = name;</span>
<span class="line">        this.chineseScore = chineseScore;</span>
<span class="line">        this.mathScore = mathScore;</span>
<span class="line">    }</span>
<span class="line"></span>
<span class="line">    public String getName() {</span>
<span class="line">        return name;</span>
<span class="line">    }</span>
<span class="line"></span>
<span class="line">    public int getChineseScore() {</span>
<span class="line">        return chineseScore;</span>
<span class="line">    }</span>
<span class="line"></span>
<span class="line">    public int getMathScore() {</span>
<span class="line">        return mathScore;</span>
<span class="line">    }</span>
<span class="line"></span>
<span class="line">    @Override</span>
<span class="line">    public String toString() {</span>
<span class="line">        return &quot;Student{&quot; +</span>
<span class="line">                &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; +</span>
<span class="line">                &quot;, 总成绩=&quot; + (chineseScore + mathScore) +</span>
<span class="line">                &#39;}&#39;;</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">class StudentComparator implements Comparator&lt;Student&gt; {</span>
<span class="line">    @Override</span>
<span class="line">    public int compare(Student s1, Student s2) {</span>
<span class="line">        // 比较总成绩</span>
<span class="line">        return Integer.compare(s2.getChineseScore() + s2.getMathScore(),</span>
<span class="line">                s1.getChineseScore() + s1.getMathScore());</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">public class PriorityQueueComparatorExample {</span>
<span class="line"></span>
<span class="line">    public static void main(String[] args) {</span>
<span class="line">        // 创建一个按照总成绩排序的优先级队列</span>
<span class="line">        PriorityQueue&lt;Student&gt; queue = new PriorityQueue&lt;&gt;(new StudentComparator());</span>
<span class="line"></span>
<span class="line">        // 添加元素</span>
<span class="line">        queue.offer(new Student(&quot;王二&quot;, 80, 90));</span>
<span class="line">        System.out.println(queue);</span>
<span class="line">        queue.offer(new Student(&quot;陈清扬&quot;, 95, 95));</span>
<span class="line">        System.out.println(queue);</span>
<span class="line">        queue.offer(new Student(&quot;小驼铃&quot;, 90, 95));</span>
<span class="line">        System.out.println(queue);</span>
<span class="line">        queue.offer(new Student(&quot;沉默&quot;, 90, 80));</span>
<span class="line">        while (!queue.isEmpty()) {</span>
<span class="line">            System.out.print(queue.poll() + &quot; &quot;);</span>
<span class="line">        }</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[168]||(s[168]=[n("Student 是一个学生对象，包含姓名、语文成绩和数学成绩。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[169]||(s[169]=[n("StudentComparator 实现了 Comparator 接口，对总成绩做了一个排序。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[170]||(s[170]=[n("PriorityQueue 是一个优先级队列，参数为 StudentComparator，然后我们添加了 4 个学生对象进去。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[171]||(s[171]=[n("来看一下输出结果：")])),_:1}),s[2591]||(s[2591]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">[Student{name=&#39;王二&#39;, 总成绩=170}]</span>
<span class="line">[Student{name=&#39;陈清扬&#39;, 总成绩=190}, Student{name=&#39;王二&#39;, 总成绩=170}]</span>
<span class="line">[Student{name=&#39;陈清扬&#39;, 总成绩=190}, Student{name=&#39;王二&#39;, 总成绩=170}, Student{name=&#39;小驼铃&#39;, 总成绩=185}]</span>
<span class="line">Student{name=&#39;陈清扬&#39;, 总成绩=190} Student{name=&#39;小驼铃&#39;, 总成绩=185} Student{name=&#39;沉默&#39;, 总成绩=170} Student{name=&#39;王二&#39;, 总成绩=170}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[172]||(s[172]=[n("我们使用 offer 方法添加元素，最后用 while 循环遍历元素（通过 poll 方法取出元素），从结果可以看得出，")])),_:1}),s[2592]||(s[2592]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[173]||(s[173]=[n("PriorityQueue")])),_:1}),s[2593]||(s[2593]=n("](https://javabetter.cn/collection/PriorityQueue.html)")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[174]||(s[174]=[n("按照学生的总成绩由高到低进行了排序。")])),_:1}),a("h2",N,[a("a",O,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[175]||(s[175]=[n("Map")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[176]||(s[176]=[n("Map 保存的是键值对，键要求保持唯一性，值可以重复。")])),_:1}),a("h3",z,[a("a",V,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[177]||(s[177]=[n("HashMap")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[178]||(s[178]=[n("HashMap 实现了 Map 接口，可以根据键快速地查找对应的值——通过哈希函数将键映射到哈希表中的一个索引位置，从而实现快速访问。")])),_:1}),s[2594]||(s[2594]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[179]||(s[179]=[n("后面会详细聊到")])),_:1}),s[2595]||(s[2595]=n("](https://javabetter.cn/collection/hashmap.html)")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[180]||(s[180]=[n("。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[181]||(s[181]=[n("这里先大致了解一下 HashMap 的特点：")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[182]||(s[182]=[n("HashMap 中的键和值都可以为 null。如果键为 null，则将该键映射到哈希表的第一个位置。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[183]||(s[183]=[n("可以使用迭代器或者 forEach 方法遍历 HashMap 中的键值对。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[184]||(s[184]=[n("HashMap 有一个初始容量和一个负载因子。初始容量是指哈希表的初始大小，负载因子是指哈希表在扩容之前可以存储的键值对数量与哈希表大小的比率。默认的初始容量是 16，负载因子是 0.75。")])),_:1})])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[185]||(s[185]=[n("来个简单的增删改查吧。")])),_:1}),s[2596]||(s[2596]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">// 创建一个 HashMap 对象</span>
<span class="line">HashMap&lt;String, String&gt; hashMap = new HashMap&lt;&gt;();</span>
<span class="line"></span>
<span class="line">// 添加键值对</span>
<span class="line">hashMap.put(&quot;沉默&quot;, &quot;cenzhong&quot;);</span>
<span class="line">hashMap.put(&quot;王二&quot;, &quot;wanger&quot;);</span>
<span class="line">hashMap.put(&quot;陈清扬&quot;, &quot;chenqingyang&quot;);</span>
<span class="line"></span>
<span class="line">// 获取指定键的值</span>
<span class="line">String value1 = hashMap.get(&quot;沉默&quot;);</span>
<span class="line">System.out.println(&quot;沉默对应的值为：&quot; + value1);</span>
<span class="line"></span>
<span class="line">// 修改键对应的值</span>
<span class="line">hashMap.put(&quot;沉默&quot;, &quot;chenmo&quot;);</span>
<span class="line">String value2 = hashMap.get(&quot;沉默&quot;);</span>
<span class="line">System.out.println(&quot;修改后沉默对应的值为：&quot; + value2);</span>
<span class="line"></span>
<span class="line">// 删除指定键的键值对</span>
<span class="line">hashMap.remove(&quot;王二&quot;);</span>
<span class="line"></span>
<span class="line">// 遍历 HashMap</span>
<span class="line">for (String key : hashMap.keySet()) {</span>
<span class="line">    String value = hashMap.get(key);</span>
<span class="line">    System.out.println(key + &quot; 对应的值为：&quot; + value);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),a("h3",P,[a("a",F,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[186]||(s[186]=[n("LinkedHashMap")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[187]||(s[187]=[n("HashMap 已经非常强大了，但它是无序的。如果我们需要一个有序的 Map，就要用到")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2597]||(s[2597]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[188]||(s[188]=[n("LinkedHashMap")])),_:1}),s[2598]||(s[2598]=n("](https://javabetter.cn/collection/linkedhashmap.html)")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[189]||(s[189]=[n("。LinkedHashMap 是 HashMap 的子类，它使用链表来记录插入/访问元素的顺序。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[190]||(s[190]=[n("LinkedHashMap 可以看作是 HashMap + LinkedList 的合体，它使用了哈希表来存储数据，又用了双向链表来维持顺序。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[191]||(s[191]=[n("来一个简单的例子。")])),_:1}),s[2599]||(s[2599]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">// 创建一个 LinkedHashMap，插入的键值对为 沉默 王二 陈清扬</span>
<span class="line">LinkedHashMap&lt;String, String&gt; linkedHashMap = new LinkedHashMap&lt;&gt;();</span>
<span class="line">linkedHashMap.put(&quot;沉默&quot;, &quot;cenzhong&quot;);</span>
<span class="line">linkedHashMap.put(&quot;王二&quot;, &quot;wanger&quot;);</span>
<span class="line">linkedHashMap.put(&quot;陈清扬&quot;, &quot;chenqingyang&quot;);</span>
<span class="line"></span>
<span class="line">// 遍历 LinkedHashMap</span>
<span class="line">for (String key : linkedHashMap.keySet()) {</span>
<span class="line">    String value = linkedHashMap.get(key);</span>
<span class="line">    System.out.println(key + &quot; 对应的值为：&quot; + value);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[192]||(s[192]=[n("来看输出结果：")])),_:1}),s[2600]||(s[2600]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">沉默 对应的值为：cenzhong</span>
<span class="line">王二 对应的值为：wanger</span>
<span class="line">陈清扬 对应的值为：chenqingyang</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[193]||(s[193]=[n("从结果中可以看得出来，LinkedHashMap 维持了键值对的插入顺序，对吧？为了和 LinkedHashMap 做对比，我们用同样的数据试验一下 HashMap。")])),_:1}),s[2601]||(s[2601]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">// 创建一个HashMap，插入的键值对为 沉默 王二 陈清扬</span>
<span class="line">HashMap&lt;String, String&gt; hashMap = new HashMap&lt;&gt;();</span>
<span class="line">hashMap.put(&quot;沉默&quot;, &quot;cenzhong&quot;);</span>
<span class="line">hashMap.put(&quot;王二&quot;, &quot;wanger&quot;);</span>
<span class="line">hashMap.put(&quot;陈清扬&quot;, &quot;chenqingyang&quot;);</span>
<span class="line"></span>
<span class="line">// 遍历 HashMap</span>
<span class="line">for (String key : hashMap.keySet()) {</span>
<span class="line">    String value = hashMap.get(key);</span>
<span class="line">    System.out.println(key + &quot; 对应的值为：&quot; + value);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[194]||(s[194]=[n("来看输出结果：")])),_:1}),s[2602]||(s[2602]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">沉默 对应的值为：cenzhong</span>
<span class="line">陈清扬 对应的值为：chenqingyang</span>
<span class="line">王二 对应的值为：wanger</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[195]||(s[195]=[n("HashMap 没有维持键值对的插入顺序，对吧？")])),_:1}),a("h3",K,[a("a",R,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[196]||(s[196]=[n("TreeMap")])),_:1})])])]),a("p",null,[a("a",B,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[197]||(s[197]=[n("TreeMap")])),_:1}),l(r)]),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[198]||(s[198]=[n("实现了 SortedMap 接口，可以自动将键按照自然顺序或指定的比较器顺序排序，并保证其元素的顺序。内部使用红黑树来实现键的排序和查找。")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[199]||(s[199]=[n("同样来一个增删改查的 demo：")])),_:1}),s[2603]||(s[2603]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">// 创建一个 TreeMap 对象</span>
<span class="line">Map&lt;String, String&gt; treeMap = new TreeMap&lt;&gt;();</span>
<span class="line"></span>
<span class="line">// 向 TreeMap 中添加键值对</span>
<span class="line">treeMap.put(&quot;沉默&quot;, &quot;cenzhong&quot;);</span>
<span class="line">treeMap.put(&quot;王二&quot;, &quot;wanger&quot;);</span>
<span class="line">treeMap.put(&quot;陈清扬&quot;, &quot;chenqingyang&quot;);</span>
<span class="line"></span>
<span class="line">// 查找键值对</span>
<span class="line">String name = &quot;沉默&quot;;</span>
<span class="line">if (treeMap.containsKey(name)) {</span>
<span class="line">    System.out.println(&quot;找到了 &quot; + name + &quot;: &quot; + treeMap.get(name));</span>
<span class="line">} else {</span>
<span class="line">    System.out.println(&quot;没有找到 &quot; + name);</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">// 修改键值对</span>
<span class="line">name = &quot;王二&quot;;</span>
<span class="line">if (treeMap.containsKey(name)) {</span>
<span class="line">    System.out.println(&quot;修改前的 &quot; + name + &quot;: &quot; + treeMap.get(name));</span>
<span class="line">    treeMap.put(name, &quot;newWanger&quot;);</span>
<span class="line">    System.out.println(&quot;修改后的 &quot; + name + &quot;: &quot; + treeMap.get(name));</span>
<span class="line">} else {</span>
<span class="line">    System.out.println(&quot;没有找到 &quot; + name);</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">// 删除键值对</span>
<span class="line">name = &quot;陈清扬&quot;;</span>
<span class="line">if (treeMap.containsKey(name)) {</span>
<span class="line">    System.out.println(&quot;删除前的 &quot; + name + &quot;: &quot; + treeMap.get(name));</span>
<span class="line">    treeMap.remove(name);</span>
<span class="line">    System.out.println(&quot;删除后的 &quot; + name + &quot;: &quot; + treeMap.get(name));</span>
<span class="line">} else {</span>
<span class="line">    System.out.println(&quot;没有找到 &quot; + name);</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">// 遍历 TreeMap</span>
<span class="line">for (Map.Entry&lt;String, String&gt; entry : treeMap.entrySet()) {</span>
<span class="line">    System.out.println(entry.getKey() + &quot;: &quot; + entry.getValue());</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[200]||(s[200]=[n("与 HashMap 不同的是，TreeMap 会按照键的顺序来进行排序。")])),_:1}),s[2604]||(s[2604]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">// 创建一个 TreeMap 对象</span>
<span class="line">Map&lt;String, String&gt; treeMap = new TreeMap&lt;&gt;();</span>
<span class="line"></span>
<span class="line">// 向 TreeMap 中添加键值对</span>
<span class="line">treeMap.put(&quot;c&quot;, &quot;cat&quot;);</span>
<span class="line">treeMap.put(&quot;a&quot;, &quot;apple&quot;);</span>
<span class="line">treeMap.put(&quot;b&quot;, &quot;banana&quot;);</span>
<span class="line"></span>
<span class="line">// 遍历 TreeMap</span>
<span class="line">for (Map.Entry&lt;String, String&gt; entry : treeMap.entrySet()) {</span>
<span class="line">    System.out.println(entry.getKey() + &quot;: &quot; + entry.getValue());</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[201]||(s[201]=[n("来看输出结果：")])),_:1}),s[2605]||(s[2605]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">a: apple</span>
<span class="line">b: banana</span>
<span class="line">c: cat</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[202]||(s[202]=[n("默认情况下，已经按照键的自然顺序排过了。")])),_:1}),s[2606]||(s[2606]=t(`<h2 id="arraylist-详解-附源码" tabindex="-1"><a class="header-anchor" href="#arraylist-详解-附源码"><span>ArrayList 详解（附源码）</span></a></h2><h3 id="创建-arraylist" tabindex="-1"><a class="header-anchor" href="#创建-arraylist"><span>创建 ArrayList</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> alist <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,3)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[203]||(s[203]=[n("可以通过上面的语句来创建一个字符串类型的 ArrayList（通过尖括号来限定 ArrayList 中元素的类型，如果尝试添加其他类型的元素，将会产生编译错误），更简化的写法如下：")])),_:1}),s[2607]||(s[2607]=t(`<div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> alist <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[204]||(s[204]=[n("由于 ArrayList 实现了 List 接口，所以 alist 变量的类型可以是 List 类型；new 关键字声明后的尖括号中可以不再指定元素的类型，因为编译器可以通过前面尖括号中的类型进行智能推断。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[205]||(s[205]=[n("此时会调用无参构造方法（见下面的代码）")])),_:1}),s[2608]||(s[2608]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[206]||(s[206]=[n("创建一个空的数组，常量 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 的值为 ")])),_:1}),s[2609]||(s[2609]=n("**`**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[207]||(s[207]=[n("{}")])),_:1}),s[2610]||(s[2610]=n("**`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[208]||(s[208]=[n("。")])),_:1}),s[2611]||(s[2611]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public ArrayList() {</span>
<span class="line">    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[209]||(s[209]=[n("如果非常确定 ArrayList 中元素的个数，在创建的时候还可以")])),_:1}),s[2612]||(s[2612]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[210]||(s[210]=[n("指定初始大小")])),_:1}),s[2613]||(s[2613]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[211]||(s[211]=[n("。")])),_:1}),s[2614]||(s[2614]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">List&lt;String&gt; alist = new ArrayList&lt;&gt;(20);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[212]||(s[212]=[n("这样做的好处是，可以有效地避免在添加新的元素时进行不必要的扩容。")])),_:1}),s[2615]||(s[2615]=t(`<h3 id="向-arraylist-中添加元素" tabindex="-1"><a class="header-anchor" href="#向-arraylist-中添加元素"><span>向 ArrayList 中添加元素</span></a></h3><div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">alist.add(&quot;沉默王二&quot;);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,2)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[213]||(s[213]=[n("我们来跟一下源码，看看 add 方法到底执行了哪些操作。跟的过程中，我们也可以偷师到 Java 源码的作者（大师级程序员）是如何优雅地写代码的。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[214]||(s[214]=[n("我先给个结论，全当抛砖引玉。")])),_:1}),s[2616]||(s[2616]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">堆栈过程图示：</span>
<span class="line">add(element)</span>
<span class="line">└── if (size == elementData.length) // 判断是否需要扩容</span>
<span class="line">    ├── grow(minCapacity) // 扩容</span>
<span class="line">    │   └── newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1) // 计算新的数组容量</span>
<span class="line">    │   └── Arrays.copyOf(elementData, newCapacity) // 创建新的数组</span>
<span class="line">    ├── elementData[size++] = element; // 添加新元素</span>
<span class="line">    └── return true; // 添加成功</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[215]||(s[215]=[n("来具体看一下，先是")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2617]||(s[2617]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[216]||(s[216]=[n("add()")])),_:1}),s[2618]||(s[2618]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[217]||(s[217]=[n("方法的源码（已添加好详细地注释）")])),_:1}),s[2619]||(s[2619]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">/**</span>
<span class="line"> * 将指定元素添加到 ArrayList 的末尾</span>
<span class="line"> * @param e 要添加的元素</span>
<span class="line"> * @return 添加成功返回 true</span>
<span class="line"> */</span>
<span class="line">public boolean add(E e) {</span>
<span class="line">    ensureCapacityInternal(size + 1);  // 确保 ArrayList 能够容纳新的元素</span>
<span class="line">    elementData[size++] = e; // 在 ArrayList 的末尾添加指定元素</span>
<span class="line">    return true;</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[218]||(s[218]=[n("参数 e 为要添加的元素，此时的值为“沉默王二”，size 为 ArrayList 的长度，此时为 0。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[219]||(s[219]=[n("继续跟下去，来看看")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2620]||(s[2620]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[220]||(s[220]=[n("ensureCapacityInternal()")])),_:1}),s[2621]||(s[2621]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[221]||(s[221]=[n("方法：")])),_:1}),s[2622]||(s[2622]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">/**</span>
<span class="line"> * 确保 ArrayList 能够容纳指定容量的元素</span>
<span class="line"> * @param minCapacity 指定容量的最小值</span>
<span class="line"> */</span>
<span class="line">private void ensureCapacityInternal(int minCapacity) {</span>
<span class="line">    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { // 如果 elementData 还是默认的空数组</span>
<span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); // 使用 DEFAULT_CAPACITY 和指定容量的最小值中的较大值</span>
<span class="line">    }</span>
<span class="line"></span>
<span class="line">    ensureExplicitCapacity(minCapacity); // 确保容量能够容纳指定容量的元素</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[222]||(s[222]=[n("此时：")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[223]||(s[223]=[n("参数 minCapacity 为 1（size+1 传过来的）")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[224]||(s[224]=[n("elementData 为存放 ArrayList 元素的底层数组，前面声明 ArrayList 的时候讲过了，此时为空")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[226]||(s[226]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[225]||(s[225]=[n("{}")])),_:1}),s[227]||(s[227]=n("`"))]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[228]||(s[228]=[n("DEFAULTCAPACITY_EMPTY_ELEMENTDATA 前面也讲过了，为")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[230]||(s[230]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[229]||(s[229]=[n("{}")])),_:1}),s[231]||(s[231]=n("`"))])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[232]||(s[232]=[n("所以，if 条件此时为 true，if 语句")])),_:1}),s[2623]||(s[2623]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[233]||(s[233]=[n("minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity)")])),_:1}),s[2624]||(s[2624]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[234]||(s[234]=[n("要执行。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[235]||(s[235]=[n("DEFAULT_CAPACITY 为 10（见下面的代码），所以执行完这行代码后，minCapacity 为 10，")])),_:1}),s[2625]||(s[2625]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[236]||(s[236]=[n("Math.max()")])),_:1}),s[2626]||(s[2626]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[237]||(s[237]=[n("方法的作用是取两个当中最大的那个。")])),_:1}),s[2627]||(s[2627]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">private static final int DEFAULT_CAPACITY = 10;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[238]||(s[238]=[n("接下来执行")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2628]||(s[2628]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[239]||(s[239]=[n("ensureExplicitCapacity()")])),_:1}),s[2629]||(s[2629]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[240]||(s[240]=[n("方法，来看一下源码：")])),_:1}),s[2630]||(s[2630]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">/**</span>
<span class="line"> * 检查并确保集合容量足够，如果需要则增加集合容量。</span>
<span class="line"> *</span>
<span class="line"> * @param minCapacity 所需最小容量</span>
<span class="line"> */</span>
<span class="line">private void ensureExplicitCapacity(int minCapacity) {</span>
<span class="line">    // 检查是否超出了数组范围，确保不会溢出</span>
<span class="line">    if (minCapacity - elementData.length &gt; 0)</span>
<span class="line">        // 如果需要增加容量，则调用 grow 方法</span>
<span class="line">        grow(minCapacity);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[241]||(s[241]=[n("此时：")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[242]||(s[242]=[n("参数 minCapacity 为 10")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[243]||(s[243]=[n("elementData.length 为 0（数组为空）")])),_:1})])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[244]||(s[244]=[n("所以 10-0>0，if 条件为 true，进入 if 语句执行")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2631]||(s[2631]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[245]||(s[245]=[n("grow()")])),_:1}),s[2632]||(s[2632]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[246]||(s[246]=[n("方法，来看源码：")])),_:1}),s[2633]||(s[2633]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">/**</span>
<span class="line"> * 扩容 ArrayList 的方法，确保能够容纳指定容量的元素</span>
<span class="line"> * @param minCapacity 指定容量的最小值</span>
<span class="line"> */</span>
<span class="line">private void grow(int minCapacity) {</span>
<span class="line">    // 检查是否会导致溢出，oldCapacity 为当前数组长度</span>
<span class="line">    int oldCapacity = elementData.length;</span>
<span class="line">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 扩容至原来的1.5倍</span>
<span class="line">    if (newCapacity - minCapacity &lt; 0) // 如果还是小于指定容量的最小值</span>
<span class="line">        newCapacity = minCapacity; // 直接扩容至指定容量的最小值</span>
<span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0) // 如果超出了数组的最大长度</span>
<span class="line">        newCapacity = hugeCapacity(minCapacity); // 扩容至数组的最大长度</span>
<span class="line">    // 将当前数组复制到一个新数组中，长度为 newCapacity</span>
<span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[247]||(s[247]=[n("此时：")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[248]||(s[248]=[n("参数 minCapacity 为 10")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[249]||(s[249]=[n("变量 oldCapacity 为 0")])),_:1})])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[250]||(s[250]=[n("所以 newCapacity 也为 0，于是")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2634]||(s[2634]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[251]||(s[251]=[n("newCapacity - minCapacity")])),_:1}),s[2635]||(s[2635]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[252]||(s[252]=[n("等于 -10 小于 0，于是第一个 if 条件为 true，执行第一个 if 语句")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2636]||(s[2636]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[253]||(s[253]=[n("newCapacity = minCapacity")])),_:1}),s[2637]||(s[2637]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[254]||(s[254]=[n("，然后 newCapacity 为 10。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[255]||(s[255]=[n("紧接着执行")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2638]||(s[2638]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[256]||(s[256]=[n("elementData = Arrays.copyOf(elementData, newCapacity);")])),_:1}),s[2639]||(s[2639]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[257]||(s[257]=[n("，也就是进行数组的第一次扩容，长度为 10。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[258]||(s[258]=[n("回到")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2640]||(s[2640]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[259]||(s[259]=[n("add()")])),_:1}),s[2641]||(s[2641]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[260]||(s[260]=[n("方法：")])),_:1}),s[2642]||(s[2642]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public boolean add(E e) {</span>
<span class="line">    ensureCapacityInternal(size + 1);</span>
<span class="line">    elementData[size++] = e;</span>
<span class="line">    return true;</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[261]||(s[261]=[n("执行")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2643]||(s[2643]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[262]||(s[262]=[n("elementData[size++] = e")])),_:1}),s[2644]||(s[2644]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[263]||(s[263]=[n("。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[264]||(s[264]=[n("此时：")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[265]||(s[265]=[n("size 为 0")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[266]||(s[266]=[n("e 为 “沉默王二”")])),_:1})])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[267]||(s[267]=[n("所以数组的第一个元素（下标为 0） 被赋值为“沉默王二”，接着返回 true，第一次 add 方法执行完毕。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[268]||(s[268]=[n("PS：add 过程中会遇到一个令新手感到困惑的右移操作符")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2645]||(s[2645]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[269]||(s[269]=[n(">>")])),_:1}),s[2646]||(s[2646]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[270]||(s[270]=[n("，借这个机会来解释一下。")])),_:1}),a("p",null,[a("strong",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[271]||(s[271]=[n("ArrayList 在第一次执行 add 后会扩容为 10")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[272]||(s[272]=[n("，那 ArrayList 第二次扩容发生在什么时候呢？")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[273]||(s[273]=[n("答案是添加第 11 个元素时，大家可以尝试分析一下这个过程。")])),_:1}),s[2647]||(s[2647]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">alist.add(&quot;沉默王二&quot;);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[274]||(s[274]=[n("我们来跟一下源码，看看 add 方法到底执行了哪些操作。跟的过程中，我们也可以偷师到 Java 源码的作者（大师级程序员）是如何优雅地写代码的。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[275]||(s[275]=[n("我先给个结论，全当抛砖引玉。")])),_:1}),s[2648]||(s[2648]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">堆栈过程图示：</span>
<span class="line">add(element)</span>
<span class="line">└── if (size == elementData.length) // 判断是否需要扩容</span>
<span class="line">    ├── grow(minCapacity) // 扩容</span>
<span class="line">    │   └── newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1) // 计算新的数组容量</span>
<span class="line">    │   └── Arrays.copyOf(elementData, newCapacity) // 创建新的数组</span>
<span class="line">    ├── elementData[size++] = element; // 添加新元素</span>
<span class="line">    └── return true; // 添加成功</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[276]||(s[276]=[n("来具体看一下，先是")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2649]||(s[2649]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[277]||(s[277]=[n("add()")])),_:1}),s[2650]||(s[2650]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[278]||(s[278]=[n("方法的源码（已添加好详细地注释）")])),_:1}),s[2651]||(s[2651]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">/**</span>
<span class="line"> * 将指定元素添加到 ArrayList 的末尾</span>
<span class="line"> * @param e 要添加的元素</span>
<span class="line"> * @return 添加成功返回 true</span>
<span class="line"> */</span>
<span class="line">public boolean add(E e) {</span>
<span class="line">    ensureCapacityInternal(size + 1);  // 确保 ArrayList 能够容纳新的元素</span>
<span class="line">    elementData[size++] = e; // 在 ArrayList 的末尾添加指定元素</span>
<span class="line">    return true;</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[279]||(s[279]=[n("参数 e 为要添加的元素，此时的值为“沉默王二”，size 为 ArrayList 的长度，此时为 0。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[280]||(s[280]=[n("继续跟下去，来看看")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2652]||(s[2652]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[281]||(s[281]=[n("ensureCapacityInternal()")])),_:1}),s[2653]||(s[2653]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[282]||(s[282]=[n("方法：")])),_:1}),s[2654]||(s[2654]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">/**</span>
<span class="line"> * 确保 ArrayList 能够容纳指定容量的元素</span>
<span class="line"> * @param minCapacity 指定容量的最小值</span>
<span class="line"> */</span>
<span class="line">private void ensureCapacityInternal(int minCapacity) {</span>
<span class="line">    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { // 如果 elementData 还是默认的空数组</span>
<span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); // 使用 DEFAULT_CAPACITY 和指定容量的最小值中的较大值</span>
<span class="line">    }</span>
<span class="line"></span>
<span class="line">    ensureExplicitCapacity(minCapacity); // 确保容量能够容纳指定容量的元素</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[283]||(s[283]=[n("此时：")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[284]||(s[284]=[n("参数 minCapacity 为 1（size+1 传过来的）")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[285]||(s[285]=[n("elementData 为存放 ArrayList 元素的底层数组，前面声明 ArrayList 的时候讲过了，此时为空")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[287]||(s[287]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[286]||(s[286]=[n("{}")])),_:1}),s[288]||(s[288]=n("`"))]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[289]||(s[289]=[n("DEFAULTCAPACITY_EMPTY_ELEMENTDATA 前面也讲过了，为")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[291]||(s[291]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[290]||(s[290]=[n("{}")])),_:1}),s[292]||(s[292]=n("`"))])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[293]||(s[293]=[n("所以，if 条件此时为 true，if 语句")])),_:1}),s[2655]||(s[2655]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[294]||(s[294]=[n("minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity)")])),_:1}),s[2656]||(s[2656]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[295]||(s[295]=[n("要执行。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[296]||(s[296]=[n("DEFAULT_CAPACITY 为 10（见下面的代码），所以执行完这行代码后，minCapacity 为 10，")])),_:1}),s[2657]||(s[2657]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[297]||(s[297]=[n("Math.max()")])),_:1}),s[2658]||(s[2658]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[298]||(s[298]=[n("方法的作用是取两个当中最大的那个。")])),_:1}),s[2659]||(s[2659]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">private static final int DEFAULT_CAPACITY = 10;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[299]||(s[299]=[n("接下来执行")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2660]||(s[2660]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[300]||(s[300]=[n("ensureExplicitCapacity()")])),_:1}),s[2661]||(s[2661]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[301]||(s[301]=[n("方法，来看一下源码：")])),_:1}),s[2662]||(s[2662]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">/**</span>
<span class="line"> * 检查并确保集合容量足够，如果需要则增加集合容量。</span>
<span class="line"> *</span>
<span class="line"> * @param minCapacity 所需最小容量</span>
<span class="line"> */</span>
<span class="line">private void ensureExplicitCapacity(int minCapacity) {</span>
<span class="line">    // 检查是否超出了数组范围，确保不会溢出</span>
<span class="line">    if (minCapacity - elementData.length &gt; 0)</span>
<span class="line">        // 如果需要增加容量，则调用 grow 方法</span>
<span class="line">        grow(minCapacity);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[302]||(s[302]=[n("此时：")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[303]||(s[303]=[n("参数 minCapacity 为 10")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[304]||(s[304]=[n("elementData.length 为 0（数组为空）")])),_:1})])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[305]||(s[305]=[n("所以 10-0>0，if 条件为 true，进入 if 语句执行")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2663]||(s[2663]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[306]||(s[306]=[n("grow()")])),_:1}),s[2664]||(s[2664]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[307]||(s[307]=[n("方法，来看源码：")])),_:1}),s[2665]||(s[2665]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">/**</span>
<span class="line"> * 扩容 ArrayList 的方法，确保能够容纳指定容量的元素</span>
<span class="line"> * @param minCapacity 指定容量的最小值</span>
<span class="line"> */</span>
<span class="line">private void grow(int minCapacity) {</span>
<span class="line">    // 检查是否会导致溢出，oldCapacity 为当前数组长度</span>
<span class="line">    int oldCapacity = elementData.length;</span>
<span class="line">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 扩容至原来的1.5倍</span>
<span class="line">    if (newCapacity - minCapacity &lt; 0) // 如果还是小于指定容量的最小值</span>
<span class="line">        newCapacity = minCapacity; // 直接扩容至指定容量的最小值</span>
<span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0) // 如果超出了数组的最大长度</span>
<span class="line">        newCapacity = hugeCapacity(minCapacity); // 扩容至数组的最大长度</span>
<span class="line">    // 将当前数组复制到一个新数组中，长度为 newCapacity</span>
<span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[308]||(s[308]=[n("此时：")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[309]||(s[309]=[n("参数 minCapacity 为 10")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[310]||(s[310]=[n("变量 oldCapacity 为 0")])),_:1})])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[311]||(s[311]=[n("所以 newCapacity 也为 0，于是")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2666]||(s[2666]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[312]||(s[312]=[n("newCapacity - minCapacity")])),_:1}),s[2667]||(s[2667]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[313]||(s[313]=[n("等于 -10 小于 0，于是第一个 if 条件为 true，执行第一个 if 语句")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2668]||(s[2668]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[314]||(s[314]=[n("newCapacity = minCapacity")])),_:1}),s[2669]||(s[2669]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[315]||(s[315]=[n("，然后 newCapacity 为 10。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[316]||(s[316]=[n("紧接着执行")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2670]||(s[2670]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[317]||(s[317]=[n("elementData = Arrays.copyOf(elementData, newCapacity);")])),_:1}),s[2671]||(s[2671]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[318]||(s[318]=[n("，也就是进行数组的第一次扩容，长度为 10。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[319]||(s[319]=[n("回到")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2672]||(s[2672]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[320]||(s[320]=[n("add()")])),_:1}),s[2673]||(s[2673]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[321]||(s[321]=[n("方法：")])),_:1}),s[2674]||(s[2674]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public boolean add(E e) {</span>
<span class="line">    ensureCapacityInternal(size + 1);</span>
<span class="line">    elementData[size++] = e;</span>
<span class="line">    return true;</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[322]||(s[322]=[n("执行")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2675]||(s[2675]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[323]||(s[323]=[n("elementData[size++] = e")])),_:1}),s[2676]||(s[2676]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[324]||(s[324]=[n("。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[325]||(s[325]=[n("此时：")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[326]||(s[326]=[n("size 为 0")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[327]||(s[327]=[n("e 为 “沉默王二”")])),_:1})])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[328]||(s[328]=[n("所以数组的第一个元素（下标为 0） 被赋值为“沉默王二”，接着返回 true，第一次 add 方法执行完毕。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[329]||(s[329]=[n("PS：add 过程中会遇到一个令新手感到困惑的右移操作符")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2677]||(s[2677]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[330]||(s[330]=[n(">>")])),_:1}),s[2678]||(s[2678]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[331]||(s[331]=[n("，借这个机会来解释一下。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[332]||(s[332]=[n("ArrayList 在第一次执行 add 后会扩容为 10，那 ArrayList 第二次扩容发生在什么时候呢？")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[333]||(s[333]=[n("答案是添加第 11 个元素时，大家可以尝试分析一下这个过程。")])),_:1}),s[2679]||(s[2679]=a("h3",{id:"右移操作符",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#右移操作符"},[a("span",null,"右移操作符")])],-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[334]||(s[334]=[n("“oldCapacity 等于 10，")])),_:1}),s[2680]||(s[2680]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[335]||(s[335]=[n("oldCapacity >> 1")])),_:1}),s[2681]||(s[2681]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[336]||(s[336]=[n("这个表达式等于多少呢？三妹你知道吗？”我问三妹。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[337]||(s[337]=[n("“不知道啊，")])),_:1}),s[2682]||(s[2682]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[338]||(s[338]=[n(">>")])),_:1}),s[2683]||(s[2683]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[339]||(s[339]=[n("是什么意思呢？”三妹很疑惑。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[340]||(s[340]=[n("“")])),_:1}),s[2684]||(s[2684]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[341]||(s[341]=[n(">>")])),_:1}),s[2685]||(s[2685]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[342]||(s[342]=[n("是右移运算符，")])),_:1}),s[2686]||(s[2686]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[343]||(s[343]=[n("oldCapacity >> 1")])),_:1}),s[2687]||(s[2687]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[344]||(s[344]=[n("相当于 oldCapacity 除以 2。”我给三妹解释道，“在计算机内部，都是按照二进制存储的，10 的二进制就是 1010，也就是")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2688]||(s[2688]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[345]||(s[345]=[n("0*2^0 + 1*2^1 + 0*2^2 + 1*2^3")])),_:1}),s[2689]||(s[2689]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[346]||(s[346]=[n("=0+2+0+8=10 。。。。。。”")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[347]||(s[347]=[n("还没等我解释完，三妹就打断了我，“二哥，能再详细解释一下到底为什么吗？”")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[348]||(s[348]=[n("“当然可以啊。”我拍着胸脯对三妹说。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[349]||(s[349]=[n("先从位权的含义说起吧。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[350]||(s[350]=[n("平常我们使用的是十进制数，比如说 39，并不是简单的 3 和 9，3 表示的是")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2690]||(s[2690]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[351]||(s[351]=[n("3*10 = 30")])),_:1}),s[2691]||(s[2691]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[352]||(s[352]=[n("，9 表示的是")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2692]||(s[2692]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[353]||(s[353]=[n("9*1 = 9")])),_:1}),s[2693]||(s[2693]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[354]||(s[354]=[n("，和 3 相乘的 10，和 9 相乘的 1，就是")])),_:1}),s[2694]||(s[2694]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[355]||(s[355]=[n("位权")])),_:1}),s[2695]||(s[2695]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[356]||(s[356]=[n("。位数不同，位权就不同，第 1 位是 10 的 0 次方（也就是")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2696]||(s[2696]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[357]||(s[357]=[n("10^0=1")])),_:1}),s[2697]||(s[2697]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[358]||(s[358]=[n("），第 2 位是 10 的 1 次方（")])),_:1}),s[2698]||(s[2698]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[359]||(s[359]=[n("10^1=10")])),_:1}),s[2699]||(s[2699]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[360]||(s[360]=[n("），第 3 位是 10 的 2 次方（")])),_:1}),s[2700]||(s[2700]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[361]||(s[361]=[n("10^2=100")])),_:1}),s[2701]||(s[2701]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[362]||(s[362]=[n("），最右边的是第一位，依次类推。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[363]||(s[363]=[n("位权这个概念同样适用于二进制，第 1 位是 2 的 0 次方（也就是")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2702]||(s[2702]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[364]||(s[364]=[n("2^0=1")])),_:1}),s[2703]||(s[2703]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[365]||(s[365]=[n("），第 2 位是 2 的 1 次方（")])),_:1}),s[2704]||(s[2704]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[366]||(s[366]=[n("2^1=2")])),_:1}),s[2705]||(s[2705]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[367]||(s[367]=[n("），第 3 位是 2 的 2 次方（")])),_:1}),s[2706]||(s[2706]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[368]||(s[368]=[n("2^2=4")])),_:1}),s[2707]||(s[2707]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[369]||(s[369]=[n("），第 4 位是 2 的 3 次方（")])),_:1}),s[2708]||(s[2708]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[370]||(s[370]=[n("2^3=8")])),_:1}),s[2709]||(s[2709]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[371]||(s[371]=[n("）。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[372]||(s[372]=[n("十进制的情况下，10 是基数，二进制的情况下，2 是基数。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[373]||(s[373]=[n("10 在十进制的表示法是")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2710]||(s[2710]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[374]||(s[374]=[n("0*10^0+1*10^1")])),_:1}),s[2711]||(s[2711]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[375]||(s[375]=[n("=0+10=10。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[376]||(s[376]=[n("10 的二进制数是 1010，也就是")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2712]||(s[2712]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[377]||(s[377]=[n("0*2^0 + 1*2^1 + 0*2^2 + 1*2^3")])),_:1}),s[2713]||(s[2713]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[378]||(s[378]=[n("=0+2+0+8=10。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[379]||(s[379]=[n("然后是")])),_:1}),s[2714]||(s[2714]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[380]||(s[380]=[n("移位运算")])),_:1}),s[2715]||(s[2715]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[381]||(s[381]=[n("，移位分为左移和右移，在 Java 中，左移的运算符是")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2716]||(s[2716]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[382]||(s[382]=[n("<<")])),_:1}),s[2717]||(s[2717]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[383]||(s[383]=[n("，右移的运算符")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2718]||(s[2718]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[384]||(s[384]=[n(">>")])),_:1}),s[2719]||(s[2719]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[385]||(s[385]=[n("。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[386]||(s[386]=[n("拿")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2720]||(s[2720]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[387]||(s[387]=[n("oldCapacity >> 1")])),_:1}),s[2721]||(s[2721]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[388]||(s[388]=[n("来说吧，")])),_:1}),s[2722]||(s[2722]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[389]||(s[389]=[n(">>")])),_:1}),s[2723]||(s[2723]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[390]||(s[390]=[n("左边的是被移位的值，此时是 10，也就是二进制")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2724]||(s[2724]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[391]||(s[391]=[n("1010")])),_:1}),s[2725]||(s[2725]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[392]||(s[392]=[n("；")])),_:1}),s[2726]||(s[2726]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[393]||(s[393]=[n(">>")])),_:1}),s[2727]||(s[2727]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[394]||(s[394]=[n("右边的是要移位的位数，此时是 1。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[395]||(s[395]=[n("1010 向右移一位就是 101，空出来的最高位此时要补 0，也就是 0101。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[396]||(s[396]=[n("“那为什么不补 1 呢？”三妹这个问题很尖锐。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[397]||(s[397]=[n("“因为是算术右移，并且是正数，所以最高位补 0；如果表示的是负数，就需要补 1。”我慢吞吞地回答道，“0101 的十进制就刚好是")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2728]||(s[2728]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[398]||(s[398]=[n("1*2^0 + 0*2^1 + 1*2^2 + 0*2^3")])),_:1}),s[2729]||(s[2729]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[399]||(s[399]=[n("=1+0+4+0=5，如果多移几个数来找规律的话，就会发现，右移 1 位是原来的 1/2，右移 2 位是原来的 1/4，诸如此类。”")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[400]||(s[400]=[n("也就是说，ArrayList 的大小会扩容为原来的大小+原来大小/2，也就是 1.5 倍。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[401]||(s[401]=[n("这下明白了吧？")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[402]||(s[402]=[n("你可以通过在 ArrayList 中添加第 11 个元素来 debug 验证一下。")])),_:1}),s[2730]||(s[2730]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726666819842-54c35d16-2cc6-478a-88f3-ccf179250c66.png"},null,-1)),s[2731]||(s[2731]=a("h3",{id:"向指定-arraylist-位置添加元素",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#向指定-arraylist-位置添加元素"},[a("span",null,"向指定 ArrayList 位置添加元素")])],-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[403]||(s[403]=[n("除了")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2732]||(s[2732]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[404]||(s[404]=[n("add(E e)")])),_:1}),s[2733]||(s[2733]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[405]||(s[405]=[n("方法，还可以通过")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2734]||(s[2734]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[406]||(s[406]=[n("add(int index, E element)")])),_:1}),s[2735]||(s[2735]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[407]||(s[407]=[n("方法把元素添加到 ArrayList 的指定位置：")])),_:1}),s[2736]||(s[2736]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">alist.add(0, &quot;沉默王三&quot;);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,1)),a("p",null,[s[409]||(s[409]=a("code",null,'<font style="color:rgb(44, 62, 80);">add(int index, E element)</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[408]||(s[408]=[n("方法的源码如下：")])),_:1})]),s[2737]||(s[2737]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">/**</span>
<span class="line"> * 在指定位置插入一个元素。</span>
<span class="line"> *</span>
<span class="line"> * @param index   要插入元素的位置</span>
<span class="line"> * @param element 要插入的元素</span>
<span class="line"> * @throws IndexOutOfBoundsException 如果索引超出范围，则抛出此异常</span>
<span class="line"> */</span>
<span class="line">public void add(int index, E element) {</span>
<span class="line">    rangeCheckForAdd(index); // 检查索引是否越界</span>
<span class="line"></span>
<span class="line">    ensureCapacityInternal(size + 1);  // 确保容量足够，如果需要扩容就扩容</span>
<span class="line">    System.arraycopy(elementData, index, elementData, index + 1,</span>
<span class="line">            size - index); // 将 index 及其后面的元素向后移动一位</span>
<span class="line">    elementData[index] = element; // 将元素插入到指定位置</span>
<span class="line">    size++; // 元素个数加一</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),a("p",null,[s[415]||(s[415]=a("code",null,'<font style="color:rgb(44, 62, 80);">add(int index, E element)</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[410]||(s[410]=[n("方法会调用到一个非常重要的")])),_:1}),a("a",Q,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[411]||(s[411]=[n("本地方法")])),_:1}),l(r)]),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[416]||(s[416]=a("code",null,'**<font style="color:rgb(44, 62, 80);">System.arraycopy()</font>**',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[412]||(s[412]=[n("，它")])),_:1}),a("strong",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[413]||(s[413]=[n("会对数组进行复制（要插入位置上的元素往后复制）")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[414]||(s[414]=[n("。")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[417]||(s[417]=[n("来细品一下。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[418]||(s[418]=[n("这是 ")])),_:1}),s[2738]||(s[2738]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[419]||(s[419]=[n("arraycopy() ")])),_:1}),s[2739]||(s[2739]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[420]||(s[420]=[n("的语法：")])),_:1}),s[2740]||(s[2740]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[421]||(s[421]=[n("在")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2741]||(s[2741]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[422]||(s[422]=[n("ArrayList.add(int index, E element)")])),_:1}),s[2742]||(s[2742]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[423]||(s[423]=[n("方法中，具体用法如下：")])),_:1}),s[2743]||(s[2743]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">System.arraycopy(elementData, index, elementData, index + 1, size - index);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,1)),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[424]||(s[424]=[n("elementData：表示要复制的源数组，即 ArrayList 中的元素数组。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[425]||(s[425]=[n("index：表示源数组中要复制的起始位置，即需要将 index 及其后面的元素向后移动一位。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[426]||(s[426]=[n("elementData：表示要复制到的目标数组，即 ArrayList 中的元素数组。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[427]||(s[427]=[n("index + 1：表示目标数组中复制的起始位置，即将 index 及其后面的元素向后移动一位后，应该插入到的位置。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[428]||(s[428]=[n("size - index：表示要复制的元素个数，即需要将 index 及其后面的元素向后移动一位，需要移动的元素个数为 size - index。")])),_:1})])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[429]||(s[429]=[n("“三妹，注意看，我画幅图来表示下。”我认真地做起了图。")])),_:1}),s[2744]||(s[2744]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726666870523-dce8f2fe-4588-4b8e-b839-0b022811f465.png"},null,-1)),a("h3",U,[a("a",J,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[430]||(s[430]=[n("更新 ArrayList 中的元素")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[431]||(s[431]=[n("“二哥，那怎么")])),_:1}),s[2745]||(s[2745]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[432]||(s[432]=[n("更新 ArrayList 中的元素")])),_:1}),s[2746]||(s[2746]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[433]||(s[433]=[n("呢？ ”三妹继续问。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[434]||(s[434]=[n("可以使用")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2747]||(s[2747]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[435]||(s[435]=[n("set()")])),_:1}),s[2748]||(s[2748]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[436]||(s[436]=[n("方法来更改 ArrayList 中的元素，需要提供下标和新元素。")])),_:1}),s[2749]||(s[2749]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">alist.set(0, &quot;沉默王四&quot;);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[437]||(s[437]=[n("假设原来 0 位置上的元素为“沉默王三”，现在可以将其更新为“沉默王四”。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[438]||(s[438]=[n("来看一下")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2750]||(s[2750]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[439]||(s[439]=[n("set()")])),_:1}),s[2751]||(s[2751]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[440]||(s[440]=[n("方法的源码：")])),_:1}),s[2752]||(s[2752]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">/**</span>
<span class="line"> * 用指定元素替换指定位置的元素。</span>
<span class="line"> *</span>
<span class="line"> * @param index   要替换的元素的索引</span>
<span class="line"> * @param element 要存储在指定位置的元素</span>
<span class="line"> * @return 先前在指定位置的元素</span>
<span class="line"> * @throws IndexOutOfBoundsException 如果索引超出范围，则抛出此异常</span>
<span class="line"> */</span>
<span class="line">public E set(int index, E element) {</span>
<span class="line">    rangeCheck(index); // 检查索引是否越界</span>
<span class="line"></span>
<span class="line">    E oldValue = elementData(index); // 获取原来在指定位置上的元素</span>
<span class="line">    elementData[index] = element; // 将新元素替换到指定位置上</span>
<span class="line">    return oldValue; // 返回原来在指定位置上的元素</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[441]||(s[441]=[n("该方法会先对指定的下标进行检查，看是否越界，然后替换新值并返回旧值。")])),_:1}),a("h3",Y,[a("a",$,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[442]||(s[442]=[n("删除 ArrayList 中的元素")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[443]||(s[443]=[n("“二哥，那怎么")])),_:1}),s[2753]||(s[2753]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[444]||(s[444]=[n("删除 ArrayList 中的元素")])),_:1}),s[2754]||(s[2754]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[445]||(s[445]=[n("呢？”三妹继续问。")])),_:1}),a("p",null,[s[448]||(s[448]=a("code",null,'<font style="color:rgb(44, 62, 80);">remove(int index)</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[446]||(s[446]=[n("方法用于删除指定下标位置上的元素，")])),_:1}),s[449]||(s[449]=a("code",null,'<font style="color:rgb(44, 62, 80);">remove(Object o)</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[447]||(s[447]=[n("方法用于删除指定值的元素。")])),_:1})]),s[2755]||(s[2755]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">alist.remove(1);</span>
<span class="line">alist.remove(&quot;沉默王四&quot;);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[450]||(s[450]=[n("先来看")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2756]||(s[2756]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[451]||(s[451]=[n("remove(int index)")])),_:1}),s[2757]||(s[2757]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[452]||(s[452]=[n("方法的源码：")])),_:1}),s[2758]||(s[2758]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">/**</span>
<span class="line"> * 删除指定位置的元素。</span>
<span class="line"> *</span>
<span class="line"> * @param index 要删除的元素的索引</span>
<span class="line"> * @return 先前在指定位置的元素</span>
<span class="line"> * @throws IndexOutOfBoundsException 如果索引超出范围，则抛出此异常</span>
<span class="line"> */</span>
<span class="line">public E remove(int index) {</span>
<span class="line">    rangeCheck(index); // 检查索引是否越界</span>
<span class="line"></span>
<span class="line">    E oldValue = elementData(index); // 获取要删除的元素</span>
<span class="line"></span>
<span class="line">    int numMoved = size - index - 1; // 计算需要移动的元素个数</span>
<span class="line">    if (numMoved &gt; 0) // 如果需要移动元素，就用 System.arraycopy 方法实现</span>
<span class="line">        System.arraycopy(elementData, index+1, elementData, index,</span>
<span class="line">                numMoved);</span>
<span class="line">    elementData[--size] = null; // 将数组末尾的元素置为 null，让 GC 回收该元素占用的空间</span>
<span class="line"></span>
<span class="line">    return oldValue; // 返回被删除的元素</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[453]||(s[453]=[n("需要注意的是，在 ArrayList 中，删除元素时，需要将删除位置后面的元素向前移动一位，以填补删除位置留下的空缺。如果需要移动元素，则需要使用 System.arraycopy 方法将删除位置后面的元素向前移动一位。最后，将数组末尾的元素置为 null，以便让垃圾回收机制回收该元素占用的空间。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[454]||(s[454]=[n("再来看")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2759]||(s[2759]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[455]||(s[455]=[n("remove(Object o)")])),_:1}),s[2760]||(s[2760]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[456]||(s[456]=[n("方法的源码：")])),_:1}),s[2761]||(s[2761]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">/**</span>
<span class="line"> * 删除列表中第一次出现的指定元素（如果存在）。</span>
<span class="line"> *</span>
<span class="line"> * @param o 要删除的元素</span>
<span class="line"> * @return 如果列表包含指定元素，则返回 true；否则返回 false</span>
<span class="line"> */</span>
<span class="line">public boolean remove(Object o) {</span>
<span class="line">    if (o == null) { // 如果要删除的元素是 null</span>
<span class="line">        for (int index = 0; index &lt; size; index++) // 遍历列表</span>
<span class="line">            if (elementData[index] == null) { // 如果找到了 null 元素</span>
<span class="line">                fastRemove(index); // 调用 fastRemove 方法快速删除元素</span>
<span class="line">                return true; // 返回 true，表示成功删除元素</span>
<span class="line">            }</span>
<span class="line">    } else { // 如果要删除的元素不是 null</span>
<span class="line">        for (int index = 0; index &lt; size; index++) // 遍历列表</span>
<span class="line">            if (o.equals(elementData[index])) { // 如果找到了要删除的元素</span>
<span class="line">                fastRemove(index); // 调用 fastRemove 方法快速删除元素</span>
<span class="line">                return true; // 返回 true，表示成功删除元素</span>
<span class="line">            }</span>
<span class="line">    }</span>
<span class="line">    return false; // 如果找不到要删除的元素，则返回 false</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[457]||(s[457]=[n("该方法通过遍历的方式找到要删除的元素，null 的时候使用 == 操作符判断，非 null 的时候使用")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2762]||(s[2762]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[458]||(s[458]=[n("equals()")])),_:1}),s[2763]||(s[2763]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[459]||(s[459]=[n("方法，然后调用")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2764]||(s[2764]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[460]||(s[460]=[n("fastRemove()")])),_:1}),s[2765]||(s[2765]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[461]||(s[461]=[n("方法。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[462]||(s[462]=[n("注意：")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[463]||(s[463]=[n("有相同元素时，只会删除第一个。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[464]||(s[464]=[n("判断两个元素是否相等，可以参考")])),_:1}),s[466]||(s[466]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[465]||(s[465]=[n("Java如何判断两个字符串是否相等")])),_:1}),s[467]||(s[467]=n("](https://javabetter.cn/string/equals.html)"))])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[468]||(s[468]=[n("继续往后面跟，来看一下")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2766]||(s[2766]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[469]||(s[469]=[n("fastRemove()")])),_:1}),s[2767]||(s[2767]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[470]||(s[470]=[n("方法：")])),_:1}),s[2768]||(s[2768]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">/**</span>
<span class="line"> * 快速删除指定位置的元素。</span>
<span class="line"> *</span>
<span class="line"> * @param index 要删除的元素的索引</span>
<span class="line"> */</span>
<span class="line">private void fastRemove(int index) {</span>
<span class="line">    int numMoved = size - index - 1; // 计算需要移动的元素个数</span>
<span class="line">    if (numMoved &gt; 0) // 如果需要移动元素，就用 System.arraycopy 方法实现</span>
<span class="line">        System.arraycopy(elementData, index+1, elementData, index,</span>
<span class="line">                numMoved);</span>
<span class="line">    elementData[--size] = null; // 将数组末尾的元素置为 null，让 GC 回收该元素占用的空间</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[471]||(s[471]=[n("同样是调用")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2769]||(s[2769]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[472]||(s[472]=[n("System.arraycopy()")])),_:1}),s[2770]||(s[2770]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[473]||(s[473]=[n("方法对数组进行复制和移动。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[474]||(s[474]=[n("“三妹，注意看，我画幅图来表示下。”我认真地做起了图。")])),_:1}),s[2771]||(s[2771]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726666870509-bb5402aa-5283-4381-8067-e7e22307a2a2.png"},null,-1)),a("h3",W,[a("a",X,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[475]||(s[475]=[n("查找 ArrayList 中的元素")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[476]||(s[476]=[n("“二哥，那怎么")])),_:1}),s[2772]||(s[2772]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[477]||(s[477]=[n("查找 ArrayList 中的元素")])),_:1}),s[2773]||(s[2773]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[478]||(s[478]=[n("呢？”三妹继续问。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[479]||(s[479]=[n("如果要正序查找一个元素，可以使用")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2774]||(s[2774]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[480]||(s[480]=[n("indexOf()")])),_:1}),s[2775]||(s[2775]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[481]||(s[481]=[n("方法；如果要倒序查找一个元素，可以使用")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2776]||(s[2776]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[482]||(s[482]=[n("lastIndexOf()")])),_:1}),s[2777]||(s[2777]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[483]||(s[483]=[n("方法。")])),_:1}),s[2778]||(s[2778]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">alist.indexOf(&quot;沉默王二&quot;);</span>
<span class="line">alist.lastIndexOf(&quot;沉默王二&quot;);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[484]||(s[484]=[n("来看一下")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2779]||(s[2779]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[485]||(s[485]=[n("indexOf()")])),_:1}),s[2780]||(s[2780]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[486]||(s[486]=[n("方法的源码：")])),_:1}),s[2781]||(s[2781]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">/**</span>
<span class="line"> * 返回指定元素在列表中第一次出现的位置。</span>
<span class="line"> * 如果列表不包含该元素，则返回 -1。</span>
<span class="line"> *</span>
<span class="line"> * @param o 要查找的元素</span>
<span class="line"> * @return 指定元素在列表中第一次出现的位置；如果列表不包含该元素，则返回 -1</span>
<span class="line"> */</span>
<span class="line">public int indexOf(Object o) {</span>
<span class="line">    if (o == null) { // 如果要查找的元素是 null</span>
<span class="line">        for (int i = 0; i &lt; size; i++) // 遍历列表</span>
<span class="line">            if (elementData[i]==null) // 如果找到了 null 元素</span>
<span class="line">                return i; // 返回元素的索引</span>
<span class="line">    } else { // 如果要查找的元素不是 null</span>
<span class="line">        for (int i = 0; i &lt; size; i++) // 遍历列表</span>
<span class="line">            if (o.equals(elementData[i])) // 如果找到了要查找的元素</span>
<span class="line">                return i; // 返回元素的索引</span>
<span class="line">    }</span>
<span class="line">    return -1; // 如果找不到要查找的元素，则返回 -1</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[487]||(s[487]=[n("如果元素为 null 的时候使用“==”操作符，否则使用")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2782]||(s[2782]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[488]||(s[488]=[n("equals()")])),_:1}),s[2783]||(s[2783]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[489]||(s[489]=[n("方法。")])),_:1}),a("p",null,[s[492]||(s[492]=a("code",null,'<font style="color:rgb(44, 62, 80);">lastIndexOf()</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[490]||(s[490]=[n("方法和")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[493]||(s[493]=a("code",null,'<font style="color:rgb(44, 62, 80);">indexOf()</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[491]||(s[491]=[n("方法类似，不过遍历的时候从最后开始。")])),_:1})]),s[2784]||(s[2784]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">/**</span>
<span class="line"> * 返回指定元素在列表中最后一次出现的位置。</span>
<span class="line"> * 如果列表不包含该元素，则返回 -1。</span>
<span class="line"> *</span>
<span class="line"> * @param o 要查找的元素</span>
<span class="line"> * @return 指定元素在列表中最后一次出现的位置；如果列表不包含该元素，则返回 -1</span>
<span class="line"> */</span>
<span class="line">public int lastIndexOf(Object o) {</span>
<span class="line">    if (o == null) { // 如果要查找的元素是 null</span>
<span class="line">        for (int i = size-1; i &gt;= 0; i--) // 从后往前遍历列表</span>
<span class="line">            if (elementData[i]==null) // 如果找到了 null 元素</span>
<span class="line">                return i; // 返回元素的索引</span>
<span class="line">    } else { // 如果要查找的元素不是 null</span>
<span class="line">        for (int i = size-1; i &gt;= 0; i--) // 从后往前遍历列表</span>
<span class="line">            if (o.equals(elementData[i])) // 如果找到了要查找的元素</span>
<span class="line">                return i; // 返回元素的索引</span>
<span class="line">    }</span>
<span class="line">    return -1; // 如果找不到要查找的元素，则返回 -1</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),a("p",null,[s[496]||(s[496]=a("code",null,'<font style="color:rgb(44, 62, 80);">contains()</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[494]||(s[494]=[n("方法可以判断 ArrayList 中是否包含某个元素，其内部就是通过")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[497]||(s[497]=a("code",null,'<font style="color:rgb(44, 62, 80);">indexOf()</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[495]||(s[495]=[n("方法实现的：")])),_:1})]),s[2785]||(s[2785]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public boolean contains(Object o) {</span>
<span class="line">    return indexOf(o) &gt;= 0;</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),a("h3",G,[a("a",Z,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[498]||(s[498]=[n("二分查找法")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[499]||(s[499]=[n("如果 ArrayList 中的元素是经过排序的，就可以使用二分查找法，效率更快。")])),_:1}),a("p",null,[a("a",h,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[500]||(s[500]=[n("Collections")])),_:1}),l(r)]),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[501]||(s[501]=[n("类的")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[503]||(s[503]=a("code",null,'<font style="color:rgb(44, 62, 80);">sort()</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[502]||(s[502]=[n("方法可以对 ArrayList 进行排序，该方法会按照字母顺序对 String 类型的列表进行排序。如果是自定义类型的列表，还可以指定 Comparator 进行排序。")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[504]||(s[504]=[n("这里先简单地了解一下，后面会详细地讲。")])),_:1}),s[2786]||(s[2786]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">List&lt;String&gt; copy = new ArrayList&lt;&gt;(alist);</span>
<span class="line">copy.add(&quot;a&quot;);</span>
<span class="line">copy.add(&quot;c&quot;);</span>
<span class="line">copy.add(&quot;b&quot;);</span>
<span class="line">copy.add(&quot;d&quot;);</span>
<span class="line"></span>
<span class="line">Collections.sort(copy);</span>
<span class="line">System.out.println(copy);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[505]||(s[505]=[n("输出结果如下所示：")])),_:1}),s[2787]||(s[2787]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">[a, b, c, d]</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[506]||(s[506]=[n("排序后就可以使用二分查找法了：")])),_:1}),s[2788]||(s[2788]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">int index = Collections.binarySearch(copy, &quot;b&quot;);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,1)),a("h3",_,[a("a",ss,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[507]||(s[507]=[n("ArrayList增删改查时的时间复杂度")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[508]||(s[508]=[n("“最后，三妹，我们来简单总结一下 ArrayList 的时间复杂度吧，方便后面学习 LinkedList 时对比。”我喝了一口水后补充道。")])),_:1}),a("h4",ns,[a("a",ls,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[509]||(s[509]=[n("查询")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[510]||(s[510]=[n("时间复杂度为 O(1)，因为 ArrayList 内部使用数组来存储元素，所以可以直接根据索引来访问元素。")])),_:1}),s[2789]||(s[2789]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">/**</span>
<span class="line"> * 返回列表中指定位置的元素。</span>
<span class="line"> *</span>
<span class="line"> * @param index 要返回的元素的索引</span>
<span class="line"> * @return 列表中指定位置的元素</span>
<span class="line"> * @throws IndexOutOfBoundsException 如果索引超出范围（index &lt; 0 || index &gt;= size()）</span>
<span class="line"> */</span>
<span class="line">public E get(int index) {</span>
<span class="line">    rangeCheck(index); // 检查索引是否合法</span>
<span class="line">    return elementData(index); // 调用 elementData 方法获取元素</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">/**</span>
<span class="line"> * 返回列表中指定位置的元素。</span>
<span class="line"> * 此方法不进行边界检查，因此只应由内部方法和迭代器调用。</span>
<span class="line"> *</span>
<span class="line"> * @param index 要返回的元素的索引</span>
<span class="line"> * @return 列表中指定位置的元素</span>
<span class="line"> */</span>
<span class="line">E elementData(int index) {</span>
<span class="line">    return (E) elementData[index]; // 返回指定索引位置上的元素</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),a("h4",es,[a("a",is,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[511]||(s[511]=[n("插入")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[512]||(s[512]=[n("添加一个元素（调用")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2790]||(s[2790]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[513]||(s[513]=[n("add()")])),_:1}),s[2791]||(s[2791]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[514]||(s[514]=[n("方法时）的时间复杂度最好情况为 O(1)，最坏情况为 O(n)。")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[515]||(s[515]=[n("如果在列表末尾添加元素，时间复杂度为 O(1)。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[516]||(s[516]=[n("如果要在列表的中间或开头插入元素，则需要将插入位置之后的元素全部向后移动一位，时间复杂度为 O(n)。")])),_:1})])]),a("h4",as,[a("a",ts,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[517]||(s[517]=[n("删除")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[518]||(s[518]=[n("删除一个元素（调用")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2792]||(s[2792]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[519]||(s[519]=[n("remove(Object)")])),_:1}),s[2793]||(s[2793]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[520]||(s[520]=[n("方法时）的时间复杂度最好情况 O(1)，最坏情况 O(n)。")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[521]||(s[521]=[n("如果要删除列表末尾的元素，时间复杂度为 O(1)。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[522]||(s[522]=[n("如果要删除列表中间或开头的元素，则需要将删除位置之后的元素全部向前移动一位，时间复杂度为 O(n)。")])),_:1})])]),a("h4",rs,[a("a",ds,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[523]||(s[523]=[n("修改")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[524]||(s[524]=[n("修改一个元素（调用")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2794]||(s[2794]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[525]||(s[525]=[n("set()")])),_:1}),s[2795]||(s[2795]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[526]||(s[526]=[n("方法时）与查询操作类似，可以直接根据索引来访问元素，时间复杂度为 O(1)。")])),_:1}),s[2796]||(s[2796]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">/**</span>
<span class="line"> * 用指定元素替换列表中指定位置的元素。</span>
<span class="line"> *</span>
<span class="line"> * @param index 要替换元素的索引</span>
<span class="line"> * @param element 要放入列表中的元素</span>
<span class="line"> * @return 原来在指定位置上的元素</span>
<span class="line"> * @throws IndexOutOfBoundsException 如果索引超出范围（index &lt; 0 || index &gt;= size()）</span>
<span class="line"> */</span>
<span class="line">public E set(int index, E element) {</span>
<span class="line">    rangeCheck(index); // 检查索引是否合法</span>
<span class="line"></span>
<span class="line">    E oldValue = elementData(index); // 获取原来在指定位置上的元素</span>
<span class="line">    elementData[index] = element; // 将指定位置上的元素替换为新元素</span>
<span class="line">    return oldValue; // 返回原来在指定位置上的元素</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),a("h3",ps,[a("a",os,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[527]||(s[527]=[n("总结")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[528]||(s[528]=[n("ArrayList，如果有个中文名的话，应该叫动态数组，也就是可增长的数组，可调整大小的数组。动态数组克服了静态数组的限制，静态数组的容量是固定的，只能在首次创建的时候指定。而动态数组会随着元素的增加自动调整大小，更符合实际的开发需求。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[529]||(s[529]=[n("学习集合框架，ArrayList 是第一课，也是新手进阶的重要一课。要想完全掌握 ArrayList，扩容这个机制是必须得掌握，也是面试中经常考察的一个点。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[530]||(s[530]=[n("要想掌握扩容机制，就必须得读源码，也就肯定会遇到 ")])),_:1}),s[2797]||(s[2797]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[531]||(s[531]=[n("oldCapacity >> 1")])),_:1}),s[2798]||(s[2798]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[532]||(s[532]=[n("，有些初学者会选择跳过，虽然不影响整体上的学习，但也错过了一个精进的机会")])),_:1}),s[2799]||(s[2799]=a("h2",{id:"linkedlist-2",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#linkedlist-2"},[a("span",null,"LinkedList")])],-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[533]||(s[533]=[n("大家好，我是 LinkedList，和 ArrayList 是同门师兄弟，但我俩练的内功却完全不同。师兄练的是动态数组，我练的是链表。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[534]||(s[534]=[n("问大家一个问题，知道我为什么要练链表这门内功吗？")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[535]||(s[535]=[n("举个例子来讲吧，假如你们手头要管理一推票据，可能有一张，也可能有一亿张。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[536]||(s[536]=[n("该怎么办呢？")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[537]||(s[537]=[n("申请一个 10G 的大数组等着？那万一票据只有 100 张呢？")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[538]||(s[538]=[n("申请一个默认大小的数组，随着数据量的增大扩容？要知道扩容是需要重新复制数组的，很耗时间。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[539]||(s[539]=[n("关键是，数组还有一个弊端就是，假如现在有 500 万张票据，现在要从中间删除一个票据，就需要把 250 万张票据往前移动一格。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[540]||(s[540]=[n("遇到这种情况的时候，我师兄几乎情绪崩溃，难受的要命。师父不忍心看到师兄这样痛苦，于是打我进入师门那一天，就强迫我练链表这门内功，一开始我很不理解，害怕师父偏心，不把师门最厉害的内功教我。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[541]||(s[541]=[n("直到有一天，我亲眼目睹师兄差点因为移动数据而走火入魔，我才明白师父的良苦用心。从此以后，我苦练“链表”这门内功，取得了显著的进步，师父和师兄都夸我有天赋。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[542]||(s[542]=[n("链表这门内功大致分为三个层次：")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[543]||(s[543]=[n("第一层叫做“单向链表”，我只有一个后指针，指向下一个数据；")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[544]||(s[544]=[n("第二层叫做“双向链表”，我有两个指针，后指针指向下一个数据，前指针指向上一个数据。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[545]||(s[545]=[n("第三层叫做“二叉树”，把后指针去掉，换成左右指针。")])),_:1})])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[546]||(s[546]=[n("但我现在的功力还达不到第三层，不过师父说我有这个潜力，练成神功是早晚的事。但可悲的是，我爹一直嫌弃我。")])),_:1}),s[2800]||(s[2800]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726668224511-9f2029f4-115c-4899-8b46-62415b8b6850.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[547]||(s[547]=[n("Josh Bloch是 Java 集合框架的作者")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[548]||(s[548]=[n("LinkedList的内功心法")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[549]||(s[549]=[n("好了，经过我这么样的一个剖白后，大家对我应该已经不陌生了。那么接下来，我给大家展示一下我的内功心法。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[550]||(s[550]=[n("我的内功心法主要是一个私有的静态内部类，叫 Node，也就是节点。")])),_:1}),s[2801]||(s[2801]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">/**</span>
<span class="line"> * 链表中的节点类。</span>
<span class="line"> */</span>
<span class="line">private static class Node&lt;E&gt; {</span>
<span class="line">    E item; // 节点中存储的元素</span>
<span class="line">    Node&lt;E&gt; next; // 指向下一个节点的指针</span>
<span class="line">    Node&lt;E&gt; prev; // 指向上一个节点的指针</span>
<span class="line"></span>
<span class="line">    /**</span>
<span class="line">     * 构造一个新的节点。</span>
<span class="line">     *</span>
<span class="line">     * @param prev 前一个节点</span>
<span class="line">     * @param element 节点中要存储的元素</span>
<span class="line">     * @param next 后一个节点</span>
<span class="line">     */</span>
<span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {</span>
<span class="line">        this.item = element; // 存储元素</span>
<span class="line">        this.next = next; // 设置下一个节点</span>
<span class="line">        this.prev = prev; // 设置上一个节点</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[551]||(s[551]=[n("它由三部分组成：")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[552]||(s[552]=[n("节点上的元素")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[553]||(s[553]=[n("下一个节点")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[554]||(s[554]=[n("上一个节点")])),_:1})])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[555]||(s[555]=[n("我画幅图给你们展示下吧。")])),_:1}),s[2802]||(s[2802]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726668222484-7a90a738-a0be-4a1f-a7b3-39f71577d427.png"},null,-1)),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[556]||(s[556]=[n("对于第一个节点来说，prev 为 null；")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[557]||(s[557]=[n("对于最后一个节点来说，next 为 null；")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[558]||(s[558]=[n("其余的节点呢，prev 指向前一个，next 指向后一个。")])),_:1})])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[559]||(s[559]=[n("我的内功心法就这么简单，其实我早已经牢记在心了。但师父叮嘱我，每天早上醒来的时候，每天晚上睡觉的时候，一定要默默地背诵一遍。虽然我有些厌烦，但我对师父的教诲从来都是言听计从。")])),_:1}),a("p",null,[a("a",us,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[560]||(s[560]=[n("02、LinkedList的招式")])),_:1}),l(r)])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[561]||(s[561]=[n("和师兄 ArrayList 一样，我的招式也无外乎“增删改查”这 4 种。在此之前，我们都必须得初始化。")])),_:1}),s[2803]||(s[2803]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">LinkedList&lt;String&gt; list = new LinkedList();</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[562]||(s[562]=[n("师兄在初始化的时候可以指定大小，也可以不指定，等到添加第一个元素的时候进行第一次扩容。而我，没有大小，只要内存够大，我就可以无穷大。")])),_:1}),a("h3",vs,[a("a",bs,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[563]||(s[563]=[n("招式一：增")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[564]||(s[564]=[n("可以调用 add 方法添加元素：")])),_:1}),s[2804]||(s[2804]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">list.add(&quot;沉默王二&quot;);</span>
<span class="line">list.add(&quot;沉默王三&quot;);</span>
<span class="line">list.add(&quot;沉默王四&quot;);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[565]||(s[565]=[n("add 方法内部其实调用的是 linkLast 方法：")])),_:1}),s[2805]||(s[2805]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">/**</span>
<span class="line"> * 将指定的元素添加到列表的尾部。</span>
<span class="line"> *</span>
<span class="line"> * @param e 要添加到列表的元素</span>
<span class="line"> * @return 始终为 true（根据 Java 集合框架规范）</span>
<span class="line"> */</span>
<span class="line">public boolean add(E e) {</span>
<span class="line">    linkLast(e); // 在列表的尾部添加元素</span>
<span class="line">    return true; // 添加元素成功，返回 true</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[566]||(s[566]=[n("linkLast，顾名思义，就是在链表的尾部添加元素：")])),_:1}),s[2806]||(s[2806]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">/**</span>
<span class="line"> * 在列表的尾部添加指定的元素。</span>
<span class="line"> *</span>
<span class="line"> * @param e 要添加到列表的元素</span>
<span class="line"> */</span>
<span class="line">void linkLast(E e) {</span>
<span class="line">    final Node&lt;E&gt; l = last; // 获取链表的最后一个节点</span>
<span class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); // 创建一个新的节点，并将其设置为链表的最后一个节点</span>
<span class="line">    last = newNode; // 将新的节点设置为链表的最后一个节点</span>
<span class="line">    if (l == null) // 如果链表为空，则将新节点设置为头节点</span>
<span class="line">        first = newNode;</span>
<span class="line">    else</span>
<span class="line">        l.next = newNode; // 否则将新节点链接到链表的尾部</span>
<span class="line">    size++; // 增加链表的元素个数</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[567]||(s[567]=[n("添加第一个元素的时候，first 和 last 都为 null。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[568]||(s[568]=[n("然后新建一个节点 newNode，它的 prev 和 next 也为 null。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[569]||(s[569]=[n("然后把 last 和 first 都赋值为 newNode。")])),_:1})])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[570]||(s[570]=[n("此时还不能称之为链表，因为前后节点都是断裂的。")])),_:1}),s[2807]||(s[2807]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726668222260-67157bfe-f45b-4f54-b269-773bdd1aebcd.png"},null,-1)),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[571]||(s[571]=[n("添加第二个元素的时候，first 和 last 都指向的是第一个节点。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[572]||(s[572]=[n("然后新建一个节点 newNode，它的 prev 指向的是第一个节点，next 为 null。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[573]||(s[573]=[n("然后把第一个节点的 next 赋值为 newNode。")])),_:1})])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[574]||(s[574]=[n("此时的链表还不完整。")])),_:1}),s[2808]||(s[2808]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726668222235-2a10dd90-41c3-4839-95e1-7ffb50b1ac98.png"},null,-1)),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[575]||(s[575]=[n("添加第三个元素的时候，first 指向的是第一个节点，last 指向的是最后一个节点。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[576]||(s[576]=[n("然后新建一个节点 newNode，它的 prev 指向的是第二个节点，next 为 null。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[577]||(s[577]=[n("然后把第二个节点的 next 赋值为 newNode。")])),_:1})])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[578]||(s[578]=[n("此时的链表已经完整了。")])),_:1}),s[2809]||(s[2809]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726668222528-68c9e200-837f-4f66-884a-65a5a7f48501.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[579]||(s[579]=[n("我这个增的招式，还可以演化成另外两个版本：")])),_:1}),a("ul",null,[a("li",null,[s[581]||(s[581]=a("code",null,'<font style="color:rgb(44, 62, 80);">addFirst()</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[580]||(s[580]=[n("方法将元素添加到第一位；")])),_:1})]),a("li",null,[s[583]||(s[583]=a("code",null,'<font style="color:rgb(44, 62, 80);">addLast()</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[582]||(s[582]=[n("方法将元素添加到末尾。")])),_:1})])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[584]||(s[584]=[n("addFirst 内部其实调用的是 linkFirst：")])),_:1}),s[2810]||(s[2810]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">/**</span>
<span class="line"> * 在列表的开头添加指定的元素。</span>
<span class="line"> *</span>
<span class="line"> * @param e 要添加到列表的元素</span>
<span class="line"> */</span>
<span class="line">public void addFirst(E e) {</span>
<span class="line">    linkFirst(e); // 在列表的开头添加元素</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[585]||(s[585]=[n("linkFirst 负责把新的节点设为 first，并将新的 first 的 next 更新为之前的 first。")])),_:1}),s[2811]||(s[2811]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">/**</span>
<span class="line"> * 在列表的开头添加指定的元素。</span>
<span class="line"> *</span>
<span class="line"> * @param e 要添加到列表的元素</span>
<span class="line"> */</span>
<span class="line">private void linkFirst(E e) {</span>
<span class="line">    final Node&lt;E&gt; f = first; // 获取链表的第一个节点</span>
<span class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); // 创建一个新的节点，并将其设置为链表的第一个节点</span>
<span class="line">    first = newNode; // 将新的节点设置为链表的第一个节点</span>
<span class="line">    if (f == null) // 如果链表为空，则将新节点设置为尾节点</span>
<span class="line">        last = newNode;</span>
<span class="line">    else</span>
<span class="line">        f.prev = newNode; // 否则将新节点链接到链表的头部</span>
<span class="line">    size++; // 增加链表的元素个数</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[586]||(s[586]=[n("addLast 的内核其实和 addFirst 差不多，内部调用的是 linkLast 方法，前面分析过了。")])),_:1}),s[2812]||(s[2812]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">/**</span>
<span class="line"> * 在列表的尾部添加指定的元素。</span>
<span class="line"> *</span>
<span class="line"> * @param e 要添加到列表的元素</span>
<span class="line"> * @return 始终为 true（根据 Java 集合框架规范）</span>
<span class="line"> */</span>
<span class="line">public boolean addLast(E e) {</span>
<span class="line">    linkLast(e); // 在列表的尾部添加元素</span>
<span class="line">    return true; // 添加元素成功，返回 true</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),a("h3",ms,[a("a",gs,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[587]||(s[587]=[n("招式二：删")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[588]||(s[588]=[n("我这个删的招式还挺多的：")])),_:1}),a("ul",null,[a("li",null,[s[590]||(s[590]=a("code",null,'<font style="color:rgb(44, 62, 80);">remove()</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[589]||(s[589]=[n("：删除第一个节点")])),_:1})]),a("li",null,[s[592]||(s[592]=a("code",null,'<font style="color:rgb(44, 62, 80);">remove(int)</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[591]||(s[591]=[n("：删除指定位置的节点")])),_:1})]),a("li",null,[s[594]||(s[594]=a("code",null,'<font style="color:rgb(44, 62, 80);">remove(Object)</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[593]||(s[593]=[n("：删除指定元素的节点")])),_:1})]),a("li",null,[s[596]||(s[596]=a("code",null,'<font style="color:rgb(44, 62, 80);">removeFirst()</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[595]||(s[595]=[n("：删除第一个节点")])),_:1})]),a("li",null,[s[598]||(s[598]=a("code",null,'<font style="color:rgb(44, 62, 80);">removeLast()</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[597]||(s[597]=[n("：删除最后一个节点")])),_:1})])]),a("p",null,[s[601]||(s[601]=a("code",null,'<font style="color:rgb(44, 62, 80);">remove()</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[599]||(s[599]=[n("内部调用的是")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[602]||(s[602]=a("code",null,'<font style="color:rgb(44, 62, 80);">removeFirst()</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[600]||(s[600]=[n("，所以这两个招式的功效一样。")])),_:1})]),a("p",null,[s[604]||(s[604]=a("code",null,'<font style="color:rgb(44, 62, 80);">remove(int)</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[603]||(s[603]=[n("内部其实调用的是 unlink 方法。")])),_:1})]),s[2813]||(s[2813]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">/**</span>
<span class="line"> * 删除指定位置上的元素。</span>
<span class="line"> *</span>
<span class="line"> * @param index 要删除的元素的索引</span>
<span class="line"> * @return 从列表中删除的元素</span>
<span class="line"> * @throws IndexOutOfBoundsException 如果索引越界（index &amp;lt; 0 || index &amp;gt;= size()）</span>
<span class="line"> */</span>
<span class="line">public E remove(int index) {</span>
<span class="line">    checkElementIndex(index); // 检查索引是否越界</span>
<span class="line">    return unlink(node(index)); // 删除指定位置的节点，并返回节点的元素</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[605]||(s[605]=[n("unlink 方法其实很好理解，就是更新当前节点的 next 和 prev，然后把当前节点上的元素设为 null。")])),_:1}),s[2814]||(s[2814]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">/**</span>
<span class="line"> * 从链表中删除指定节点。</span>
<span class="line"> *</span>
<span class="line"> * @param x 要删除的节点</span>
<span class="line"> * @return 从链表中删除的节点的元素</span>
<span class="line"> */</span>
<span class="line">E unlink(Node&lt;E&gt; x) {</span>
<span class="line">    final E element = x.item; // 获取要删除节点的元素</span>
<span class="line">    final Node&lt;E&gt; next = x.next; // 获取要删除节点的下一个节点</span>
<span class="line">    final Node&lt;E&gt; prev = x.prev; // 获取要删除节点的上一个节点</span>
<span class="line"></span>
<span class="line">    if (prev == null) { // 如果要删除节点是第一个节点</span>
<span class="line">        first = next; // 将链表的头节点设置为要删除节点的下一个节点</span>
<span class="line">    } else {</span>
<span class="line">        prev.next = next; // 将要删除节点的上一个节点指向要删除节点的下一个节点</span>
<span class="line">        x.prev = null; // 将要删除节点的上一个节点设置为空</span>
<span class="line">    }</span>
<span class="line"></span>
<span class="line">    if (next == null) { // 如果要删除节点是最后一个节点</span>
<span class="line">        last = prev; // 将链表的尾节点设置为要删除节点的上一个节点</span>
<span class="line">    } else {</span>
<span class="line">        next.prev = prev; // 将要删除节点的下一个节点指向要删除节点的上一个节点</span>
<span class="line">        x.next = null; // 将要删除节点的下一个节点设置为空</span>
<span class="line">    }</span>
<span class="line"></span>
<span class="line">    x.item = null; // 将要删除节点的元素设置为空</span>
<span class="line">    size--; // 减少链表的元素个数</span>
<span class="line">    return element; // 返回被删除节点的元素</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[606]||(s[606]=[n("remove(Object) 内部也调用了 unlink 方法，只不过在此之前要先找到元素所在的节点：")])),_:1}),s[2815]||(s[2815]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">/**</span>
<span class="line"> * 从链表中删除指定元素。</span>
<span class="line"> *</span>
<span class="line"> * @param o 要从链表中删除的元素</span>
<span class="line"> * @return 如果链表包含指定元素，则返回 true；否则返回 false</span>
<span class="line"> */</span>
<span class="line">public boolean remove(Object o) {</span>
<span class="line">    if (o == null) { // 如果要删除的元素为 null</span>
<span class="line">        for (Node&lt;E&gt; x = first; x != null; x = x.next) { // 遍历链表</span>
<span class="line">            if (x.item == null) { // 如果节点的元素为 null</span>
<span class="line">                unlink(x); // 删除节点</span>
<span class="line">                return true; // 返回 true 表示删除成功</span>
<span class="line">            }</span>
<span class="line">        }</span>
<span class="line">    } else { // 如果要删除的元素不为 null</span>
<span class="line">        for (Node&lt;E&gt; x = first; x != null; x = x.next) { // 遍历链表</span>
<span class="line">            if (o.equals(x.item)) { // 如果节点的元素等于要删除的元素</span>
<span class="line">                unlink(x); // 删除节点</span>
<span class="line">                return true; // 返回 true 表示删除成功</span>
<span class="line">            }</span>
<span class="line">        }</span>
<span class="line">    }</span>
<span class="line">    return false; // 如果链表中不包含要删除的元素，则返回 false 表示删除失败</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[607]||(s[607]=[n("元素为 null 的时候，必须使用 == 来判断；元素为非 null 的时候，要使用 equals 来判断。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[608]||(s[608]=[n("removeFirst 内部调用的是 unlinkFirst 方法：")])),_:1}),s[2816]||(s[2816]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">/**</span>
<span class="line"> * 从链表中删除第一个元素并返回它。</span>
<span class="line"> * 如果链表为空，则抛出 NoSuchElementException 异常。</span>
<span class="line"> *</span>
<span class="line"> * @return 从链表中删除的第一个元素</span>
<span class="line"> * @throws NoSuchElementException 如果链表为空</span>
<span class="line"> */</span>
<span class="line">public E removeFirst() {</span>
<span class="line">    final Node&lt;E&gt; f = first; // 获取链表的第一个节点</span>
<span class="line">    if (f == null) // 如果链表为空</span>
<span class="line">        throw new NoSuchElementException(); // 抛出 NoSuchElementException 异常</span>
<span class="line">    return unlinkFirst(f); // 调用 unlinkFirst 方法删除第一个节点并返回它的元素</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[609]||(s[609]=[n("unlinkFirst 负责的就是把第一个节点毁尸灭迹，并且捎带把后一个节点的 prev 设为 null。")])),_:1}),s[2817]||(s[2817]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">/**</span>
<span class="line"> * 删除链表中的第一个节点并返回它的元素。</span>
<span class="line"> *</span>
<span class="line"> * @param f 要删除的第一个节点</span>
<span class="line"> * @return 被删除节点的元素</span>
<span class="line"> */</span>
<span class="line">private E unlinkFirst(Node&lt;E&gt; f) {</span>
<span class="line">    final E element = f.item; // 获取要删除的节点的元素</span>
<span class="line">    final Node&lt;E&gt; next = f.next; // 获取要删除的节点的下一个节点</span>
<span class="line">    f.item = null; // 将要删除的节点的元素设置为 null</span>
<span class="line">    f.next = null; // 将要删除的节点的下一个节点设置为 null</span>
<span class="line">    first = next; // 将链表的头节点设置为要删除的节点的下一个节点</span>
<span class="line">    if (next == null) // 如果链表只有一个节点</span>
<span class="line">        last = null; // 将链表的尾节点设置为 null</span>
<span class="line">    else</span>
<span class="line">        next.prev = null; // 将要删除节点的下一个节点的前驱设置为 null</span>
<span class="line">    size--; // 减少链表的大小</span>
<span class="line">    return element; // 返回被删除节点的元素</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),a("h3",ys,[a("a",fs,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[610]||(s[610]=[n("招式三：改")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[611]||(s[611]=[n("可以调用")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2818]||(s[2818]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[612]||(s[612]=[n("set()")])),_:1}),s[2819]||(s[2819]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[613]||(s[613]=[n("方法来更新元素：")])),_:1}),s[2820]||(s[2820]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">list.set(0, &quot;沉默王五&quot;);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[614]||(s[614]=[n("来看一下")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2821]||(s[2821]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[615]||(s[615]=[n("set()")])),_:1}),s[2822]||(s[2822]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[616]||(s[616]=[n("方法：")])),_:1}),s[2823]||(s[2823]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">/**</span>
<span class="line"> * 将链表中指定位置的元素替换为指定元素，并返回原来的元素。</span>
<span class="line"> *</span>
<span class="line"> * @param index 要替换元素的位置（从 0 开始）</span>
<span class="line"> * @param element 要插入的元素</span>
<span class="line"> * @return 替换前的元素</span>
<span class="line"> * @throws IndexOutOfBoundsException 如果索引超出范围（index &lt; 0 || index &gt;= size()）</span>
<span class="line"> */</span>
<span class="line">public E set(int index, E element) {</span>
<span class="line">    checkElementIndex(index); // 检查索引是否超出范围</span>
<span class="line">    Node&lt;E&gt; x = node(index); // 获取要替换的节点</span>
<span class="line">    E oldVal = x.item; // 获取要替换节点的元素</span>
<span class="line">    x.item = element; // 将要替换的节点的元素设置为指定元素</span>
<span class="line">    return oldVal; // 返回替换前的元素</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[617]||(s[617]=[n("来看一下node方法：")])),_:1}),s[2824]||(s[2824]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">/**</span>
<span class="line"> * 获取链表中指定位置的节点。</span>
<span class="line"> *</span>
<span class="line"> * @param index 节点的位置（从 0 开始）</span>
<span class="line"> * @return 指定位置的节点</span>
<span class="line"> * @throws IndexOutOfBoundsException 如果索引超出范围（index &lt; 0 || index &gt;= size()）</span>
<span class="line"> */</span>
<span class="line">Node&lt;E&gt; node(int index) {</span>
<span class="line">    if (index &lt; (size &gt;&gt; 1)) { // 如果索引在链表的前半部分</span>
<span class="line">        Node&lt;E&gt; x = first;</span>
<span class="line">        for (int i = 0; i &lt; index; i++) // 从头节点开始向后遍历链表，直到找到指定位置的节点</span>
<span class="line">            x = x.next;</span>
<span class="line">        return x; // 返回指定位置的节点</span>
<span class="line">    } else { // 如果索引在链表的后半部分</span>
<span class="line">        Node&lt;E&gt; x = last;</span>
<span class="line">        for (int i = size - 1; i &gt; index; i--) // 从尾节点开始向前遍历链表，直到找到指定位置的节点</span>
<span class="line">            x = x.prev;</span>
<span class="line">        return x; // 返回指定位置的节点</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),a("p",null,[s[619]||(s[619]=a("code",null,'<font style="color:rgb(44, 62, 80);">size >> 1</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[618]||(s[618]=[n("：也就是右移一位，相当于除以 2。对于计算机来说，移位比除法运算效率更高，因为数据在计算机内部都是以二进制存储的。")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[620]||(s[620]=[n("换句话说，node 方法会对下标进行一个初步判断，如果靠近前半截，就从下标 0 开始遍历；如果靠近后半截，就从末尾开始遍历，这样可以提高效率，最大能提高一半的效率。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[621]||(s[621]=[n("找到指定下标的节点就简单了，直接把原有节点的元素替换成新的节点就 OK 了，prev 和 next 都不用改动。")])),_:1}),a("h3",ks,[a("a",cs,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[622]||(s[622]=[n("招式四：查")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[623]||(s[623]=[n("我这个查的招式可以分为两种：")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[624]||(s[624]=[n("indexOf(Object)：查找某个元素所在的位置")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[625]||(s[625]=[n("get(int)：查找某个位置上的元素")])),_:1})])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[626]||(s[626]=[n("来看一下 indexOf 方法的源码。")])),_:1}),s[2825]||(s[2825]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">/**</span>
<span class="line"> * 返回链表中首次出现指定元素的位置，如果不存在该元素则返回 -1。</span>
<span class="line"> *</span>
<span class="line"> * @param o 要查找的元素</span>
<span class="line"> * @return 首次出现指定元素的位置，如果不存在该元素则返回 -1</span>
<span class="line"> */</span>
<span class="line">public int indexOf(Object o) {</span>
<span class="line">    int index = 0; // 初始化索引为 0</span>
<span class="line">    if (o == null) { // 如果要查找的元素为 null</span>
<span class="line">        for (Node&lt;E&gt; x = first; x != null; x = x.next) { // 从头节点开始向后遍历链表</span>
<span class="line">            if (x.item == null) // 如果找到了要查找的元素</span>
<span class="line">                return index; // 返回该元素的索引</span>
<span class="line">            index++; // 索引加 1</span>
<span class="line">        }</span>
<span class="line">    } else { // 如果要查找的元素不为 null</span>
<span class="line">        for (Node&lt;E&gt; x = first; x != null; x = x.next) { // 从头节点开始向后遍历链表</span>
<span class="line">            if (o.equals(x.item)) // 如果找到了要查找的元素</span>
<span class="line">                return index; // 返回该元素的索引</span>
<span class="line">            index++; // 索引加 1</span>
<span class="line">        }</span>
<span class="line">    }</span>
<span class="line">    return -1; // 如果没有找到要查找的元素，则返回 -1</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[627]||(s[627]=[n("get 方法的内核其实还是 node 方法，node 方法之前已经说明过了，这里略过。")])),_:1}),s[2826]||(s[2826]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public E get(int index) {</span>
<span class="line">    checkElementIndex(index);</span>
<span class="line">    return node(index).item;</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[628]||(s[628]=[n("其实，查这个招式还可以演化为其他的一些，比如说：")])),_:1}),a("ul",null,[a("li",null,[s[630]||(s[630]=a("code",null,'<font style="color:rgb(44, 62, 80);">getFirst()</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[629]||(s[629]=[n("方法用于获取第一个元素；")])),_:1})]),a("li",null,[s[632]||(s[632]=a("code",null,'<font style="color:rgb(44, 62, 80);">getLast()</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[631]||(s[631]=[n("方法用于获取最后一个元素；")])),_:1})]),a("li",null,[s[635]||(s[635]=a("code",null,'<font style="color:rgb(44, 62, 80);">poll()</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[633]||(s[633]=[n("和")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[636]||(s[636]=a("code",null,'<font style="color:rgb(44, 62, 80);">pollFirst()</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[634]||(s[634]=[n("方法用于删除并返回第一个元素（两个方法尽管名字不同，但方法体是完全相同的）；")])),_:1})]),a("li",null,[s[638]||(s[638]=a("code",null,'<font style="color:rgb(44, 62, 80);">pollLast()</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[637]||(s[637]=[n("方法用于删除并返回最后一个元素；")])),_:1})]),a("li",null,[s[640]||(s[640]=a("code",null,'<font style="color:rgb(44, 62, 80);">peekFirst()</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[639]||(s[639]=[n("方法用于返回但不删除第一个元素。")])),_:1})])]),a("h3",qs,[a("a",xs,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[641]||(s[641]=[n("LinkedList 的挑战")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[642]||(s[642]=[n("说句实在话，我不是很喜欢和师兄 ArrayList 拿来比较，因为我们各自修炼的内功不同，没有孰高孰低。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[643]||(s[643]=[n("虽然师兄经常喊我一声师弟，但我们之间其实挺和谐的。但我知道，在外人眼里，同门师兄弟，总要一较高下的。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[644]||(s[644]=[n("比如说，我们俩在增删改查时候的时间复杂度。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[645]||(s[645]=[n("也许这就是命运吧，从我进入师门的那天起，这种争论就一直没有停息过。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[646]||(s[646]=[n("无论外人怎么看待我们，在我眼里，师兄永远都是一哥，我敬重他，他也愿意保护我。")])),_:1}),a("p",null,[a("a",Ls,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[647]||(s[647]=[n("好戏在后头")])),_:1}),l(r)]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[648]||(s[648]=[n("，等着瞧吧。")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[649]||(s[649]=[n("我这里先简单聊一下，权当抛砖引玉。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[650]||(s[650]=[n("想象一下，你在玩一款游戏，游戏中有一个道具栏，你需要不断地往里面添加、删除道具。如果你使用的是我的师兄 ArrayList，那么每次添加、删除道具时都需要将后面的道具向后移动或向前移动，这样就会非常耗费时间。但是如果你使用的是我 LinkedList，那么只需要将新道具插入到链表中的指定位置，或者将要删除的道具从链表中删除即可，这样就可以快速地完成道具栏的更新。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[651]||(s[651]=[n("除了游戏中的道具栏，我 LinkedList 还可以用于实现 LRU（Least Recently Used）缓存淘汰算法。LRU ")])),_:1}),s[2827]||(s[2827]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[652]||(s[652]=[n("缓存淘汰算法")])),_:1}),s[2828]||(s[2828]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[653]||(s[653]=[n("是一种常用的缓存淘汰策略，它的基本思想是，当缓存空间不够时，优先淘汰最近最少使用的缓存数据。在实现 LRU 缓存淘汰算法时，你可以使用我 LinkedList 来存储缓存数据，每次访问缓存数据时，将该数据从链表中删除并移动到链表的头部，这样链表的尾部就是最近最少使用的缓存数据，当缓存空间不够时，只需要将链表尾部的缓存数据淘汰即可。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[654]||(s[654]=[n("总之，各有各的好，且行且珍惜。")])),_:1}),a("h3",Ms,[a("a",ws,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[655]||(s[655]=[n("LinkedList 的应用")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[656]||(s[656]=[n("如果你打算通过我来练练手，那么推荐你试一下 LeetCode 的")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2829]||(s[2829]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[657]||(s[657]=[n("002.两数相加")])),_:1}),s[2830]||(s[2830]=n("](https://paicoding.com/column/7/2)")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[658]||(s[658]=[n("、")])),_:1}),s[2831]||(s[2831]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[659]||(s[659]=[n("019.删除链表的第 N 个节点")])),_:1}),s[2832]||(s[2832]=n("](https://paicoding.com/column/7/19)")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[660]||(s[660]=[n("题目，我把题解链接放在了技术派上：")])),_:1}),a("ul",null,[a("li",null,[a("a",Cs,[l(e,{style:{color:"rgb(102, 102, 102)"}},{default:i(()=>s[661]||(s[661]=[n("002.两数相加")])),_:1}),l(r)])]),a("li",null,[a("a",Ss,[s[662]||(s[662]=n("019.删除链表的倒数第 N 个节点——通过手绘图和 LinkedList 源码的讲解，你一定看得懂")),l(r)])])]),s[2833]||(s[2833]=a("h2",{id:"栈-stack-详解",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#栈-stack-详解"},[a("span",null,"栈 Stack 详解")])],-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[663]||(s[663]=[n("讲真，Stack 这个类在 Java 应用中并不常用，但栈这个数据结构在整个计算机体系中却十分重要。所以我们还是放到")])),_:1}),s[2834]||(s[2834]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[664]||(s[664]=[n("集合框架")])),_:1}),s[2835]||(s[2835]=n("](https://javabetter.cn/collection/gailan.html)")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[665]||(s[665]=[n("里来讲一讲。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[666]||(s[666]=[n("栈（stack），有些地方喜欢称呼它为堆栈，我就很不喜欢，很容易和 heap（堆）搞混，尤其是对于新手来说，简直就是虐心。")])),_:1}),a("h3",As,[a("a",Es,[a("span",null,[a("a",js,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[667]||(s[667]=[n("栈数据结构")])),_:1}),l(r)])])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[668]||(s[668]=[n("栈是一种非常有用的数据结构，它就像一摞盘子，第一个放在最下面，第二个放在第一个上面，第三个放在第二个上面，最后一个放在最上面。")])),_:1}),s[2836]||(s[2836]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726668276848-4ae31312-aa7e-41a1-b43c-5e42dbf6b8c9.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[669]||(s[669]=[n("对于这一摞盘子，我们可以做两件事情：")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[670]||(s[670]=[n("在最上面放一个新盘子")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[671]||(s[671]=[n("把顶部的盘子拿走")])),_:1})])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[672]||(s[672]=[n("这两件事情做起来很容易，但如果从中间或者底部抽出来一个盘子，就很难办到。如果我们想要拿到最下面的盘子，就必须把它上面的所有盘子都拿走，像这样的一个操作，我们称之为后进先出，也就是“Last In First Out”（简称 ")])),_:1}),s[2837]||(s[2837]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[673]||(s[673]=[n("LIFO")])),_:1}),s[2838]||(s[2838]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[674]||(s[674]=[n("）——最后的一个进的，最先出去。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[675]||(s[675]=[n("对于栈这样一个数据结构来说，它有两个常见的动作：")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[676]||(s[676]=[n("push，中文释义有很多种，我个人更喜欢叫它“压入”，非常形象。当我们要把一个元素放入栈的顶部，这个动作就叫做 push。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[677]||(s[677]=[n("pop，同样的，我个人更喜欢叫它“弹出”，带有很强烈的动画效果，有没有？当我们要从栈中移除一个元素时，这个动作就叫做 pop。")])),_:1})])]),s[2839]||(s[2839]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726668276853-0ee8feb3-5f70-4b27-b1dd-1564e5c4e784.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[678]||(s[678]=[n("对于上面这幅图来说，3 这个元素最后放进去，却是最先被移除的——遵循 LIFO 的原则。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[679]||(s[679]=[n("明白了栈的基本操作后，我们需要去深入地思考一下，栈是如何工作的。换句话说，为了使栈这个数据结构按照栈的方式去工作，它需要什么？")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[680]||(s[680]=[n("1）栈需要有一个指针，我们称之为")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2840]||(s[2840]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[681]||(s[681]=[n("TOP")])),_:1}),s[2841]||(s[2841]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[682]||(s[682]=[n("，用它来指向栈中最顶部的那个元素。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[683]||(s[683]=[n("2）当我们初始化一个栈的时候，我们把")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2842]||(s[2842]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[684]||(s[684]=[n("TOP")])),_:1}),s[2843]||(s[2843]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[685]||(s[685]=[n("的值设置为")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2844]||(s[2844]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[686]||(s[686]=[n("-1")])),_:1}),s[2845]||(s[2845]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[687]||(s[687]=[n("，这样我们就可以通过")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2846]||(s[2846]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[688]||(s[688]=[n("TOP == -1")])),_:1}),s[2847]||(s[2847]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[689]||(s[689]=[n("来判断栈是否为空。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[690]||(s[690]=[n("3）当我们要在栈中压入一个元素的时候，我们把")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2848]||(s[2848]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[691]||(s[691]=[n("TOP")])),_:1}),s[2849]||(s[2849]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[692]||(s[692]=[n("的值加 1，然后把新压入的元素指向 TOP。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[693]||(s[693]=[n("4）当我们要从栈中弹出一个元素的时候，我们把")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2850]||(s[2850]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[694]||(s[694]=[n("TOP")])),_:1}),s[2851]||(s[2851]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[695]||(s[695]=[n("的值减 1，然后把保持在最顶部的那个元素指向 TOP。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[696]||(s[696]=[n("5）当我们压入一个元素的时候，需要检查栈是否已经满了。也就是说，需要有一个")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2852]||(s[2852]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[697]||(s[697]=[n("isFull()")])),_:1}),s[2853]||(s[2853]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[698]||(s[698]=[n("的方法来判断。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[699]||(s[699]=[n("6）当我们要弹出一个元素的时候，需要检查栈是否已经空了。也就是说，需要有一个")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2854]||(s[2854]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[700]||(s[700]=[n("isEmpty()")])),_:1}),s[2855]||(s[2855]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[701]||(s[701]=[n("的方法来判断。")])),_:1}),s[2856]||(s[2856]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726668276668-44410e7f-56bf-493e-976a-522ec66cea92.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[702]||(s[702]=[n("空栈的时候，TOP 等于 -1；把元素 1 压入栈中的时候，")])),_:1}),s[2857]||(s[2857]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[703]||(s[703]=[n("stack[0]")])),_:1}),s[2858]||(s[2858]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[704]||(s[704]=[n("为 1，TOP 加 1 变为 0；把元素 2 压入栈中的时候，")])),_:1}),s[2859]||(s[2859]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[705]||(s[705]=[n("stack[1]")])),_:1}),s[2860]||(s[2860]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[706]||(s[706]=[n("为 2，TOP 加 1 变为 1；把元素 3 压入栈中的时候，")])),_:1}),s[2861]||(s[2861]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[707]||(s[707]=[n("stack[2]")])),_:1}),s[2862]||(s[2862]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[708]||(s[708]=[n("为 3，TOP 加 1 变为 2；把元素 3 从栈中弹出后，返回元素")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2863]||(s[2863]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[709]||(s[709]=[n("stack[2]")])),_:1}),s[2864]||(s[2864]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[710]||(s[710]=[n("，TOP 减 1 变为 1。")])),_:1}),a("h3",Is,[a("a",Hs,[a("span",null,[a("a",Ts,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[711]||(s[711]=[n("自定义栈")])),_:1}),l(r)])])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[712]||(s[712]=[n("假设栈中的元素是 int 类型，我们可以用 Java 语言来自定义一个最简单的栈。它需要 3 个字段：")])),_:1}),a("ul",null,[a("li",null,[s[714]||(s[714]=a("code",null,'<font style="color:rgb(44, 62, 80);">int arr[]</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[713]||(s[713]=[n("，一个 int 类型的数组，来存放数据")])),_:1})]),a("li",null,[s[716]||(s[716]=a("code",null,'<font style="color:rgb(44, 62, 80);">int top</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[715]||(s[715]=[n("，一个 int 类型的标记")])),_:1})]),a("li",null,[s[718]||(s[718]=a("code",null,'<font style="color:rgb(44, 62, 80);">int capacity</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[717]||(s[717]=[n("，一个 int 类型的容量")])),_:1})])]),s[2865]||(s[2865]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">class Stack { </span>
<span class="line">     private int arr[]; </span>
<span class="line">     private int top; </span>
<span class="line">     private int capacity; </span>
<span class="line"> }</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[719]||(s[719]=[n("初始化栈：")])),_:1}),s[2866]||(s[2866]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">Stack(int size) { </span>
<span class="line">     arr = new int[size]; </span>
<span class="line">     capacity = size; </span>
<span class="line">     top = -1; </span>
<span class="line"> }</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[720]||(s[720]=[n("往栈中压入元素：")])),_:1}),s[2867]||(s[2867]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public void push(int x) { </span>
<span class="line">     if (isFull()) { </span>
<span class="line">         System.out.println(&quot;溢出\\n程序终止\\n&quot;); </span>
<span class="line">         System.exit(1); </span>
<span class="line">     } </span>
<span class="line">  </span>
<span class="line">     System.out.println(&quot;压入 &quot; + x); </span>
<span class="line">     arr[++top] = x; </span>
<span class="line"> }</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[721]||(s[721]=[n("从栈中弹出元素：")])),_:1}),s[2868]||(s[2868]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public int pop() { </span>
<span class="line">     if (isEmpty()) { </span>
<span class="line">         System.out.println(&quot;栈是空的&quot;); </span>
<span class="line">         System.exit(1); </span>
<span class="line">     } </span>
<span class="line">     return arr[top--]; </span>
<span class="line"> }</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[722]||(s[722]=[n("返回栈的大小：")])),_:1}),s[2869]||(s[2869]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public int size() { </span>
<span class="line">     return top + 1; </span>
<span class="line"> }</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[723]||(s[723]=[n("检查栈是否为空：")])),_:1}),s[2870]||(s[2870]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public Boolean isEmpty() { </span>
<span class="line">     return top == -1; </span>
<span class="line"> }</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[724]||(s[724]=[n("检查栈是否已经满了：")])),_:1}),s[2871]||(s[2871]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public Boolean isFull() { </span>
<span class="line">     return top == capacity - 1; </span>
<span class="line"> }</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[725]||(s[725]=[n("来个")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2872]||(s[2872]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[726]||(s[726]=[n("main()")])),_:1}),s[2873]||(s[2873]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[727]||(s[727]=[n("方法直接测试下：")])),_:1}),s[2874]||(s[2874]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public void printStack() { </span>
<span class="line">     for (int i = 0; i &lt;= top; i++) { </span>
<span class="line">         System.out.println(arr[i]); </span>
<span class="line">     } </span>
<span class="line"> } </span>
<span class="line">  </span>
<span class="line"> public static void main(String[] args) { </span>
<span class="line">     Stack stack = new Stack(5); </span>
<span class="line">  </span>
<span class="line">     stack.push(1); </span>
<span class="line">     stack.push(2); </span>
<span class="line">     stack.push(3); </span>
<span class="line">     stack.push(4); </span>
<span class="line">  </span>
<span class="line">     stack.pop(); </span>
<span class="line">     System.out.println(&quot;\\n弹出元素后&quot;); </span>
<span class="line">  </span>
<span class="line">     stack.printStack(); </span>
<span class="line"> }</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[728]||(s[728]=[n("打印结果如下所示：")])),_:1}),s[2875]||(s[2875]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">压入 1 </span>
<span class="line">压入 2 </span>
<span class="line">压入 3 </span>
<span class="line">压入 4 </span>
<span class="line"></span>
<span class="line">弹出元素后 </span>
<span class="line">1 </span>
<span class="line">2 </span>
<span class="line">3</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[729]||(s[729]=[n("由于我们是通过")])),_:1}),s[2876]||(s[2876]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[730]||(s[730]=[n("数组")])),_:1}),s[2877]||(s[2877]=n("](https://javabetter.cn/array/array.html)")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[731]||(s[731]=[n("来实现的栈，所以")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2878]||(s[2878]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[732]||(s[732]=[n("push")])),_:1}),s[2879]||(s[2879]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[733]||(s[733]=[n("和")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2880]||(s[2880]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[734]||(s[734]=[n("pop")])),_:1}),s[2881]||(s[2881]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[735]||(s[735]=[n("的")])),_:1}),s[2882]||(s[2882]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[736]||(s[736]=[n("时间复杂度")])),_:1}),s[2883]||(s[2883]=n("](https://javabetter.cn/collection/time-complexity.html)")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[737]||(s[737]=[n("就是")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2884]||(s[2884]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[738]||(s[738]=[n("O(1)")])),_:1}),s[2885]||(s[2885]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[739]||(s[739]=[n("。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[740]||(s[740]=[n("尽管栈是一种非常简单的数据结构，通过上面的代码大家应该也能感受得出来，轻而易举地就实现了，但是栈却是一种非常强有力的数据结构，可以在很多场景中使用，比如说：")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[741]||(s[741]=[n("1）")])),_:1}),s[2886]||(s[2886]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[742]||(s[742]=[n("反转一串字符")])),_:1}),s[2887]||(s[2887]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[743]||(s[743]=[n("：由于栈是")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2888]||(s[2888]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[744]||(s[744]=[n("LIFO")])),_:1}),s[2889]||(s[2889]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[745]||(s[745]=[n("的，所以反转一串字符很容易，按照正常的顺序把字符压入栈中，然后再弹出来就行了。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[746]||(s[746]=[n("2）")])),_:1}),s[2890]||(s[2890]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[747]||(s[747]=[n("用于计算器")])),_:1}),s[2891]||(s[2891]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[748]||(s[748]=[n("：记得我实习的时候，公司就给我们新人安排了我们一个小项目——模仿一个 Win 7 的计算机，用来考察我们是不是真材实料，要想计算一个复杂的表达式，比如说")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2892]||(s[2892]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[749]||(s[749]=[n("2 + 5 / 3 * (6 - 2)")])),_:1}),s[2893]||(s[2893]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[750]||(s[750]=[n("，就需要一个栈来容纳这些数字和运算符，然后按照优先级弹出后进行计算。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[751]||(s[751]=[n("嗯，这个计算要比想象中复杂一些，新手同学可以私底下实现一下，不仅能够提高对栈这种数据结构的理解，还能对运算符的一个优先级进行思考。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[752]||(s[752]=[n("很显然，栈，给我赢得了一次实习的机会，避免了被刷下去的危机。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[753]||(s[753]=[n("3）")])),_:1}),s[2894]||(s[2894]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[754]||(s[754]=[n("用于浏览器")])),_:1}),s[2895]||(s[2895]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[755]||(s[755]=[n("：浏览器的后退按钮会把我们访问的 URL 压入一个栈中，每次我们访问一个新的页面，新的 URL 就压入了栈的顶部，当我们点了后退按钮，最新的那个 URL 就从栈中移除，之前的那个 URL 就被访问到了。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[756]||(s[756]=[n("好了，下课，今天的栈就到此为止吧。")])),_:1}),a("h3",Ds,[a("a",Ns,[a("span",null,[a("a",Os,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[757]||(s[757]=[n("Stack 类")])),_:1}),l(r)])])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[758]||(s[758]=[n("其实 Java 已经帮我们实现了一个栈，就是")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2896]||(s[2896]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[759]||(s[759]=[n("java.util.Stack")])),_:1}),s[2897]||(s[2897]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[760]||(s[760]=[n("，它继承自")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2898]||(s[2898]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[761]||(s[761]=[n("Vector")])),_:1}),s[2899]||(s[2899]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[762]||(s[762]=[n("，是线程安全的，有点")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2900]||(s[2900]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[763]||(s[763]=[n("StringBuffer")])),_:1}),s[2901]||(s[2901]=n("](https://javabetter.cn/string/builder-buffer.html)")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[764]||(s[764]=[n("的感觉，笨笨的。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[765]||(s[765]=[n("先来个简单的例子：")])),_:1}),s[2902]||(s[2902]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">Stack&lt;String&gt; stack = new Stack&lt;&gt;();</span>
<span class="line">stack.push(&quot;沉默王二&quot;);</span>
<span class="line">stack.push(&quot;沉默王三&quot;);</span>
<span class="line">stack.push(&quot;一个文章真特么有趣的程序员&quot;);</span>
<span class="line"></span>
<span class="line">System.out.println(stack);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[766]||(s[766]=[n("Stack 类并不复杂，仅有几个重要的方法，比如说")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2903]||(s[2903]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[767]||(s[767]=[n("push")])),_:1}),s[2904]||(s[2904]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[768]||(s[768]=[n("、")])),_:1}),s[2905]||(s[2905]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[769]||(s[769]=[n("pop")])),_:1}),s[2906]||(s[2906]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[770]||(s[770]=[n("、")])),_:1}),s[2907]||(s[2907]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[771]||(s[771]=[n("peek")])),_:1}),s[2908]||(s[2908]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[772]||(s[772]=[n("、")])),_:1}),s[2909]||(s[2909]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[773]||(s[773]=[n("empty")])),_:1}),s[2910]||(s[2910]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[774]||(s[774]=[n("、")])),_:1}),s[2911]||(s[2911]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[775]||(s[775]=[n("search")])),_:1}),s[2912]||(s[2912]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[776]||(s[776]=[n("等等。")])),_:1}),s[2913]||(s[2913]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726668277822-8555075c-4a39-4b45-ab42-1d5339466947.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[777]||(s[777]=[n("我们来看一下")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2914]||(s[2914]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[778]||(s[778]=[n("push")])),_:1}),s[2915]||(s[2915]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[779]||(s[779]=[n("方法的源码：")])),_:1}),s[2916]||(s[2916]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public E push(E item) { </span>
<span class="line">     addElement(item); </span>
<span class="line">  </span>
<span class="line">     return item; </span>
<span class="line"> }</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),a("p",null,[s[786]||(s[786]=a("code",null,'<font style="color:rgb(44, 62, 80);">push</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[780]||(s[780]=[n("方法虽然没有")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),a("a",zs,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[781]||(s[781]=[n("synchronized")])),_:1}),l(r)]),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[782]||(s[782]=[n("关键字，但调用了")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[787]||(s[787]=a("code",null,'<font style="color:rgb(44, 62, 80);">Vector</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[783]||(s[783]=[n("类的")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[788]||(s[788]=a("code",null,'<font style="color:rgb(44, 62, 80);">addElement</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[784]||(s[784]=[n("方法，该方法上添加了")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[789]||(s[789]=a("code",null,'<font style="color:rgb(44, 62, 80);">synchronized</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[785]||(s[785]=[n("关键字。")])),_:1})]),s[2917]||(s[2917]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public synchronized void addElement(E obj) { </span>
<span class="line">     modCount++; </span>
<span class="line">     ensureCapacityHelper(elementCount + 1); </span>
<span class="line">     elementData[elementCount++] = obj; </span>
<span class="line"> }</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[790]||(s[790]=[n("再来看一下")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2918]||(s[2918]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[791]||(s[791]=[n("pop")])),_:1}),s[2919]||(s[2919]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[792]||(s[792]=[n("方法的源码：")])),_:1}),s[2920]||(s[2920]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public synchronized E pop() { </span>
<span class="line">     E obj; </span>
<span class="line">     int len = size(); </span>
<span class="line">  </span>
<span class="line">     obj = peek(); </span>
<span class="line">     removeElementAt(len - 1); </span>
<span class="line">  </span>
<span class="line">     return obj; </span>
<span class="line"> }</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[793]||(s[793]=[n("该方法添加了")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2921]||(s[2921]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[794]||(s[794]=[n("synchronized")])),_:1}),s[2922]||(s[2922]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[795]||(s[795]=[n("关键字，并且先调用")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2923]||(s[2923]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[796]||(s[796]=[n("peek")])),_:1}),s[2924]||(s[2924]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[797]||(s[797]=[n("方法获取到栈顶元素：")])),_:1}),s[2925]||(s[2925]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public synchronized E peek() {</span>
<span class="line">    int     len = size();</span>
<span class="line"></span>
<span class="line">    if (len == 0)</span>
<span class="line">        throw new EmptyStackException();</span>
<span class="line">    return elementAt(len - 1);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[798]||(s[798]=[n("接着调用 Vector 类的")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2926]||(s[2926]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[799]||(s[799]=[n("removeElementAt")])),_:1}),s[2927]||(s[2927]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[800]||(s[800]=[n("方法移除栈顶元素。")])),_:1}),s[2928]||(s[2928]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726668276885-8ec447ce-c006-48ea-8670-91708fd6be9a.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[801]||(s[801]=[n("注意该方法如果移除的不是栈顶元素，还会调用")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2929]||(s[2929]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[802]||(s[802]=[n("System.arraycopy")])),_:1}),s[2930]||(s[2930]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[803]||(s[803]=[n("进行数组的拷贝，因为栈的底层是由数组实现的。")])),_:1}),s[2931]||(s[2931]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public class Vector&lt;E&gt;</span>
<span class="line">    extends AbstractList&lt;E&gt;</span>
<span class="line">    implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span>
<span class="line">{</span>
<span class="line">    protected Object[] elementData;</span>
<span class="line">    protected int elementCount;</span>
<span class="line">    protected int capacityIncrement;</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),a("h3",Vs,[a("a",Ps,[a("span",null,[a("a",Fs,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[804]||(s[804]=[n("小结")])),_:1}),l(r)])])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[805]||(s[805]=[n("栈是一种非常有用的数据结构，它的特点是后进先出，可以用来反转一串字符、实现计算器、浏览器的后退按钮等等。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[806]||(s[806]=[n("虽然 Stack 类并不常用，但栈这个数据结构却很重要。在 Java 中，推荐使用 ArrayDeque 来代替 Stack，因为")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2932]||(s[2932]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[807]||(s[807]=[n("ArrayDeque")])),_:1}),s[2933]||(s[2933]=n("](https://javabetter.cn/collection/arraydeque.html)")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[808]||(s[808]=[n("是非线程安全的，性能更好。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[809]||(s[809]=[n("如果想通过 LeetCode 进行练习的话，可以尝试一下这道题：")])),_:1}),a("p",null,[a("a",Ks,[s[810]||(s[810]=n("020.有效的括号，用栈来解决的 Java 版 LeetCode 刷题笔记")),l(r)]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[811]||(s[811]=[n("，我把题解放到了技术派上，大家可以参考。")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}}),a("h2",Rs,[a("a",Bs,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[812]||(s[812]=[n("HashMap 详解（附源码）")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[813]||(s[813]=[n("接下来会详细透彻地讲清楚 hash 方法的原理、HashMap 的扩容机制、HashMap 的加载因子为什么是 0.75 而不是 0.6、0.8，以及 HashMap 为什么是线程不安全的，基本上 HashMap 的常见面试题，都会在这一篇文章里讲明白。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[814]||(s[814]=[n("HashMap 是 Java 中常用的数据结构之一，用于存储键值对。在 HashMap 中，每个键都映射到一个唯一的值，可以通过键来快速访问对应的值，算法时间复杂度可以达到 O(1)。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[815]||(s[815]=[n("HashMap 不仅在日常开发中经常用到，在面试中也是重点考察的对象。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),a("h3",Qs,[a("a",Us,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[816]||(s[816]=[n("HashMap 增删改查的简单例子")])),_:1})])])]),a("p",null,[a("strong",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[817]||(s[817]=[n("1）增加元素")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[818]||(s[818]=[n("：")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[819]||(s[819]=[n("将一个键值对（元素）添加到 HashMap 中，可以使用 put() 方法。例如，将名字和年龄作为键值对添加到 HashMap 中：")])),_:1}),s[2934]||(s[2934]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();</span>
<span class="line">map.put(&quot;沉默&quot;, 20);</span>
<span class="line">map.put(&quot;王二&quot;, 25);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),a("p",null,[a("strong",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[820]||(s[820]=[n("2）删除元素")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[821]||(s[821]=[n("：")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[822]||(s[822]=[n('从 HashMap 中删除一个键值对，可以使用 remove() 方法。例如，删除名字为 "沉默" 的键值对：')])),_:1}),s[2935]||(s[2935]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">map.remove(&quot;沉默&quot;);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,1)),a("p",null,[a("strong",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[823]||(s[823]=[n("3）修改元素")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[824]||(s[824]=[n("：")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[825]||(s[825]=[n('修改 HashMap 中的一个键值对，可以使用 put() 方法。例如，将名字为 "沉默" 的年龄修改为 30：')])),_:1}),s[2936]||(s[2936]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">map.put(&quot;沉默&quot;, 30);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[826]||(s[826]=[n("为什么和添加元素的方法一样呢？这个我们后面会讲，先简单说一下，是因为 HashMap 的键是唯一的，所以再次 put 的时候会覆盖掉之前的键值对。")])),_:1}),a("p",null,[a("strong",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[827]||(s[827]=[n("4）查找元素")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[828]||(s[828]=[n("：")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[829]||(s[829]=[n('从 HashMap 中查找一个键对应的值，可以使用 get() 方法。例如，查找名字为 "沉默" 的年龄：')])),_:1}),s[2937]||(s[2937]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">int age = map.get(&quot;沉默&quot;);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[830]||(s[830]=[n("在实际应用中，HashMap 可以用于缓存、索引等场景。例如，可以将用户 ID 作为键，用户信息作为值，将用户信息缓存到 HashMap 中，以便快速查找。又如，可以将关键字作为键，文档 ID 列表作为值，将文档索引缓存到 HashMap 中，以便快速搜索文档。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[831]||(s[831]=[n("HashMap 的实现原理是基于哈希表的，它的底层是一个数组，数组的每个位置可能是一个链表或红黑树，也可能只是一个键值对（后面会讲）。当添加一个键值对时，HashMap 会根据键的哈希值计算出该键对应的数组下标（索引），然后将键值对插入到对应的位置。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[832]||(s[832]=[n("当通过键查找值时，HashMap 也会根据键的哈希值计算出数组下标，并查找对应的值。")])),_:1}),a("h3",Js,[a("a",Ys,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[833]||(s[833]=[n("hash 方法的原理")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[834]||(s[834]=[n("简单了解 HashMap 后，我们来讨论第一个问题：hash 方法的原理，对吃透 HashMap 会大有帮助。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[835]||(s[835]=[n("来看一下 hash 方法的源码（JDK 8 中的 HashMap）：")])),_:1}),s[2938]||(s[2938]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">static final int hash(Object key) {</span>
<span class="line">    int h;</span>
<span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[836]||(s[836]=[n("这段代码究竟是用来干嘛的呢？")])),_:1}),a("p",null,[a("strong",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[837]||(s[837]=[n("将 key 的 hashCode 值进行处理，得到最终的哈希值")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[838]||(s[838]=[n("。")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[839]||(s[839]=[n("怎么理解这句话呢？不要着急。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[840]||(s[840]=[n("我们来 new 一个 HashMap，并通过 put 方法添加一个元素。")])),_:1}),s[2939]||(s[2939]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();</span>
<span class="line">map.put(&quot;chenmo&quot;, &quot;沉默&quot;);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[841]||(s[841]=[n("来看一下 put 方法的源码。")])),_:1}),s[2940]||(s[2940]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public V put(K key, V value) {</span>
<span class="line">    return putVal(hash(key), key, value, false, true);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[842]||(s[842]=[n("看到 hash 方法的身影了吧？")])),_:1}),a("h4",$s,[a("a",Ws,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[843]||(s[843]=[n("hash 方法的作用")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[844]||(s[844]=[n("前面也说了，HashMap 的底层是通过数组的形式实现的，")])),_:1}),s[2941]||(s[2941]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[845]||(s[845]=[n("初始大小是 16")])),_:1}),s[2942]||(s[2942]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[846]||(s[846]=[n("（这个后面会讲），先记住。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[847]||(s[847]=[n("也就是说，HashMap 在添加第一个元素的时候，需要通过键的哈希码在大小为 16 的数组中确定一个位置（索引），怎么确定呢？")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[848]||(s[848]=[n("为了方便大家直观的感受，我这里画了一副图，16 个方格子（可以把它想象成一个一个桶），每个格子都有一个编号，对应大小为 16 的数组下标（索引）。")])),_:1}),s[2943]||(s[2943]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726668349148-50ebc5af-8e15-46fa-8a13-8d155c40fc00.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[849]||(s[849]=[n("现在，我们要把 key 为 “chenmo”，value 为“沉默”的键值对放到这 16 个格子中的一个。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[850]||(s[850]=[n("怎么确定位置（索引）呢？")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[851]||(s[851]=[n("我先告诉大家结论，通过这个与运算")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2944]||(s[2944]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[852]||(s[852]=[n("(n - 1) & hash")])),_:1}),s[2945]||(s[2945]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[853]||(s[853]=[n("，其中变量 n 为数组的长度，变量 hash 就是通过")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2946]||(s[2946]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[854]||(s[854]=[n("hash()")])),_:1}),s[2947]||(s[2947]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[855]||(s[855]=[n("方法计算后的结果。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[856]||(s[856]=[n("那“chenmo”这个 key 计算后的位置（索引）是多少呢？")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[857]||(s[857]=[n("答案是 8，也就是说")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2948]||(s[2948]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[858]||(s[858]=[n('map.put("chenmo", "沉默")')])),_:1}),s[2949]||(s[2949]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[859]||(s[859]=[n("会把 key 为 “chenmo”，value 为“沉默”的键值对放到下标为 8 的位置上（也就是索引为 8 的桶上）。")])),_:1}),s[2950]||(s[2950]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726668349291-326c2f19-1124-49ac-8b39-942760ffac68.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[860]||(s[860]=[n("这样大家就会对 HashMap 存放键值对（元素）的时候有一个大致的印象。其中的一点是，hash 方法对计算键值对的位置起到了至关重要的作用。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[861]||(s[861]=[n("回到 hash 方法：")])),_:1}),s[2951]||(s[2951]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">static final int hash(Object key) {</span>
<span class="line">    int h;</span>
<span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[862]||(s[862]=[n("下面是对该方法的一些解释：")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[863]||(s[863]=[n("参数 key：需要计算哈希码的键值。")])),_:1})]),a("li",null,[s[866]||(s[866]=a("code",null,'<font style="color:rgb(44, 62, 80);">key == null ? 0 : (h = key.hashCode()) ^ (h >>> 16)</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[864]||(s[864]=[n("：这是一个三目运算符，如果键值为 null，则哈希码为 0（依旧是说如果键为 null，则存放在第一个位置）；否则，通过调用")])),_:1}),s[867]||(s[867]=a("code",null,'<font style="color:rgb(44, 62, 80);">hashCode()</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[865]||(s[865]=[n("方法获取键的哈希码，并将其与右移 16 位的哈希码进行异或运算。")])),_:1})]),a("li",null,[s[869]||(s[869]=a("code",null,'<font style="color:rgb(44, 62, 80);">^</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[868]||(s[868]=[n("运算符：异或运算符是 Java 中的一种位运算符，它用于将两个数的二进制位进行比较，如果相同则为 0，不同则为 1。")])),_:1})]),a("li",null,[s[871]||(s[871]=a("code",null,'<font style="color:rgb(44, 62, 80);">h >>> 16</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[870]||(s[870]=[n("：将哈希码向右移动 16 位，相当于将原来的哈希码分成了两个 16 位的部分。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[872]||(s[872]=[n("最终返回的是经过异或运算后得到的哈希码值。")])),_:1})])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[873]||(s[873]=[n("这短短的一行代码，汇聚不少计算机巨佬们的聪明才智。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[874]||(s[874]=[n("理论上，哈希值（哈希码）是一个 int 类型，范围从-2147483648 到 2147483648。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[875]||(s[875]=[n("前后加起来大概 40 亿的映射空间，只要哈希值映射得比较均匀松散，一般是不会出现哈希碰撞（哈希冲突会降低 HashMap 的效率）。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[876]||(s[876]=[n("但问题是一个 40 亿长度的数组，内存是放不下的。HashMap 扩容之前的数组初始大小只有 16，所以这个哈希值是不能直接拿来用的，用之前要和数组的长度做与运算（前文提到的")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2952]||(s[2952]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[877]||(s[877]=[n("(n - 1) & hash")])),_:1}),s[2953]||(s[2953]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[878]||(s[878]=[n("，有些地方叫取模预算，有些地方叫取余运算），用得到的值来访问数组下标才行。")])),_:1}),a("h4",Xs,[a("a",Gs,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[879]||(s[879]=[n("取模运算 VS 取余运算 VS 与运算")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[880]||(s[880]=[n("那这里就顺带补充一些取模预算/取余运算和与运算的知识点哈。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[881]||(s[881]=[n("取模运算（Modulo Operation）和取余运算（Remainder Operation）从严格意义上来讲，是两种不同的运算方式，它们在计算机中的实现也不同。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[882]||(s[882]=[n("在 Java 中，通常使用 % 运算符来表示取余，用")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2954]||(s[2954]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[883]||(s[883]=[n("Math.floorMod()")])),_:1}),s[2955]||(s[2955]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[884]||(s[884]=[n("来表示取模。")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[885]||(s[885]=[n("当操作数都是正数的话，取模运算和取余运算的结果是一样的。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[886]||(s[886]=[n("只有当操作数出现负数的情况，结果才会有所不同。")])),_:1})]),a("li",null,[a("strong",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[887]||(s[887]=[n("取模运算的商向负无穷靠近；取余运算的商向 0 靠近")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[888]||(s[888]=[n("。这是导致它们两个在处理有负数情况下，结果不同的根本原因。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[889]||(s[889]=[n("当数组的长度是 2 的 n 次方，或者 n 次幂，或者 n 的整数倍时，取模运算/取余运算可以用位运算来代替，效率更高，毕竟计算机本身只认二进制嘛。")])),_:1})])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[890]||(s[890]=[n("我们通过一个实际的例子来看一下。")])),_:1}),s[2956]||(s[2956]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">int a = -7;</span>
<span class="line">int b = 3;</span>
<span class="line"></span>
<span class="line">// a 对 b 取余</span>
<span class="line">int remainder = a % b;</span>
<span class="line">// a 对 b 取模</span>
<span class="line">int modulus = Math.floorMod(a, b);</span>
<span class="line"></span>
<span class="line">System.out.println(&quot;数字: a = &quot; + a + &quot;, b = &quot; + b);</span>
<span class="line">System.out.println(&quot;取余 (%): &quot; + remainder);</span>
<span class="line">System.out.println(&quot;取模 (Math.floorMod): &quot; + modulus);</span>
<span class="line"></span>
<span class="line">// 改变 a 和 b 的正负情况</span>
<span class="line">a = 7;</span>
<span class="line">b = -3;</span>
<span class="line"></span>
<span class="line">remainder = a % b;</span>
<span class="line">modulus = Math.floorMod(a, b);</span>
<span class="line"></span>
<span class="line">System.out.println(&quot;\\n数字: a = &quot; + a + &quot;, b = &quot; + b);</span>
<span class="line">System.out.println(&quot;取余 (%): &quot; + remainder);</span>
<span class="line">System.out.println(&quot;取模 (Math.floorMod): &quot; + modulus);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[891]||(s[891]=[n("输出结果如下所示：")])),_:1}),s[2957]||(s[2957]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">数字: a = -7, b = 3</span>
<span class="line">取余 (%): -1</span>
<span class="line">取模 (Math.floorMod): 2</span>
<span class="line"></span>
<span class="line">数字: a = 7, b = -3</span>
<span class="line">取余 (%): 1</span>
<span class="line">取模 (Math.floorMod): -2</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[892]||(s[892]=[n("为什么会有这样的结果呢？")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[893]||(s[893]=[n("首先，我们来考虑一下常规除法。当我们将一个数除以另一个数时，我们将得到一个商和一个余数。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[894]||(s[894]=[n("例如，当我们把 7 除以 3 时，我们得到商 2 和余数 1，因为 (7 = 3 × 2 + 1)。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[895]||(s[895]=[n("推荐阅读：")])),_:1}),s[2958]||(s[2958]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[896]||(s[896]=[n("Java 取模和取余")])),_:1}),s[2959]||(s[2959]=n("](https://www.cnblogs.com/doondo/p/14678204.html)")),a("p",null,[a("strong",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[897]||(s[897]=[n("01、取余")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[898]||(s[898]=[n("：")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[899]||(s[899]=[n("余数的定义是基于常规除法的，所以它的符号总是与被除数相同。商趋向于 0。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[900]||(s[900]=[n("例如，对于")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2960]||(s[2960]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[901]||(s[901]=[n("-7 % 3")])),_:1}),s[2961]||(s[2961]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[902]||(s[902]=[n("，余数是")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2962]||(s[2962]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[903]||(s[903]=[n("-1")])),_:1}),s[2963]||(s[2963]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[904]||(s[904]=[n("。因为 -7 / 3 可以有两种结果，一种是商 -2 余 -1；一种是商 -3 余 2，对吧？")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[905]||(s[905]=[n("因为取余的商趋向于 0，-2 比 -3 更接近于 0，所以取余的结果是 -1。")])),_:1}),a("p",null,[a("strong",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[906]||(s[906]=[n("02、取模")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[907]||(s[907]=[n("：")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[908]||(s[908]=[n("取模也是基于除法的，只不过它的符号总是与除数相同。商趋向于负无穷。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[909]||(s[909]=[n("例如，对于")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2964]||(s[2964]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[910]||(s[910]=[n("Math.floorMod(-7, 3)")])),_:1}),s[2965]||(s[2965]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[911]||(s[911]=[n("，结果是")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2966]||(s[2966]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[912]||(s[912]=[n("2")])),_:1}),s[2967]||(s[2967]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[913]||(s[913]=[n("。同理，因为 -7 / 3 可以有两种结果，一种是商 -2 余 -1；一种是商 -3 余 2，对吧？")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[914]||(s[914]=[n("因为取模的商趋向于负无穷，-3 比 -2 更接近于负无穷，所以取模的结果是 2。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[915]||(s[915]=[n("需要注意的是，不管是取模还是取余，除数都不能为 0，因为取模和取余都是基于除法运算的。")])),_:1}),a("p",null,[a("strong",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[916]||(s[916]=[n("03、与运算")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[917]||(s[917]=[n("：")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[918]||(s[918]=[n("当除数和被除数都是正数的情况下，取模运算和取余运算的结果是一样的。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[919]||(s[919]=[n("比如说，7 对 3 取余，和 7 对 3 取模，结果都是 1。因为两者都是基于除法运算的，7 / 3 的商是 2，余数是 1。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[920]||(s[920]=[n("于是，我们会在很多地方看到，")])),_:1}),s[2968]||(s[2968]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[921]||(s[921]=[n("取余就是取模，取模就是取余。这是一种不准确的说法，基于操作数都是正数的情况下")])),_:1}),s[2969]||(s[2969]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[922]||(s[922]=[n("。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[923]||(s[923]=[n("对于 HashMap 来说，它需要通过")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2970]||(s[2970]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[924]||(s[924]=[n("hash % table.length")])),_:1}),s[2971]||(s[2971]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[925]||(s[925]=[n("来确定元素在数组中的位置，这种做法可以在很大程度上让元素均匀的分布在数组中。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[926]||(s[926]=[n("比如说，数组长度是 3，hash 是 7，那么 7 % 3 的结果就是 1，也就是此时可以把元素放在下标为 1 的位置。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[927]||(s[927]=[n("当 hash 是 8，8 % 3 的结果就是 2，也就是可以把元素放在下标为 2 的位置。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[928]||(s[928]=[n("当 hash 是 9，9 % 3 的结果就是 0，也就是可以把元素放在下标为 0 的位置上。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[929]||(s[929]=[n("是不是很奇妙，数组的大小为 3，刚好 3 个位置都利用上了。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[930]||(s[930]=[n("那为什么 HashMap 在计算下标的时候，并没有直接使用取余运算（或者取模运算），而是直接使用位与运算 & 呢？")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[931]||(s[931]=[n("因为当数组的长度是 2 的 n 次方时，")])),_:1}),s[2972]||(s[2972]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[932]||(s[932]=[n("hash & (length - 1) = hash % length")])),_:1}),s[2973]||(s[2973]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[933]||(s[933]=[n("。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[934]||(s[934]=[n("比如说 9 % 4 = 1，9 的二进制是 1001，4 - 1 = 3，3 的二进制是 0011，9 & 3 = 1001 & 0011 = 0001 = 1。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[935]||(s[935]=[n("再比如说 10 % 4 = 2，10 的二进制是 1010，4 - 1 = 3，3 的二进制是 0011，10 & 3 = 1010 & 0011 = 0010 = 2。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[936]||(s[936]=[n("当数组的长度不是 2 的 n 次方时，")])),_:1}),s[2974]||(s[2974]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[937]||(s[937]=[n("hash % length")])),_:1}),s[2975]||(s[2975]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[938]||(s[938]=[n("和")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2976]||(s[2976]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[939]||(s[939]=[n("hash & (length - 1)")])),_:1}),s[2977]||(s[2977]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[940]||(s[940]=[n("的结果就不一致了。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[941]||(s[941]=[n("比如说 7 % 3 = 1，7 的二进制是 0111，3 - 1 = 2，2 的二进制是 0010，7 & 2 = 0111 & 0010 = 0010 = 2。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[942]||(s[942]=[n("那为什么呢？")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[943]||(s[943]=[n("因为从二进制角度来看，hash / length = hash / ${2^n}$ = hash >> n，即把 hash 右移 n 位，此时得到了 hash / ${2^n}$ 的商。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[944]||(s[944]=[n("而被移调的部分，则是 hash % ${2^n}$，也就是余数。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[945]||(s[945]=[n("${2^n}$ 的二进制形式为 1，后面跟着 n 个 0，那 ${2^n}$ - 1 的二进制则是 n 个 1。例如 8 = ${2^3}$，二进制是 1000，7 = ${2^3}$ - 1，二进制为 0111。")])),_:1}),a("p",null,[s[947]||(s[947]=a("code",null,'<font style="color:rgb(44, 62, 80);">hash % length</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[946]||(s[946]=[n("的操作是求 hash 除以 ${2^n}$ 的余数。在二进制中，这个操作的结果就是 hash 的二进制表示中最低 n 位的值。")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[948]||(s[948]=[n("因为在 ${2^n}$ 取模的操作中，高于 ${2^n}$ 表示位的所有数值对结果没有贡献，只有低于这个阈值的部分才决定余数。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[949]||(s[949]=[n("比如说 26 的二进制是 11010，要计算 26 % 8，8 是 ${2^3}$，所以我们关注的是 26 的二进制表示中最低 3 位：11010 的最低 3 位是 010。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[950]||(s[950]=[n("010 对应于十进制中的 2，26 % 8 的结果是 2。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[951]||(s[951]=[n("当执行")])),_:1}),s[2978]||(s[2978]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[952]||(s[952]=[n("hash & (length - 1)")])),_:1}),s[2979]||(s[2979]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[953]||(s[953]=[n("时，实际上是保留 hash 二进制表示的最低 n 位，其他高位都被清零。")])),_:1}),l(e,{style:{color:"rgb(102, 102, 102)"}},{default:i(()=>s[954]||(s[954]=[n("& 与运算：两个操作数中位都为 1，结果才为 1，否则结果为 0。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[955]||(s[955]=[n("举个例子，hash 为 14，n 为 3，也就是数组长度为 ${2^3}$，也就是 8。")])),_:1}),s[2980]||(s[2980]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">1110 (hash = 14)</span>
<span class="line">&amp; 0111 (length - 1 = 7)</span>
<span class="line">  ----</span>
<span class="line">  0110 (结果 = 6)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[956]||(s[956]=[n("保留 14 的最低 3 位，高位被清零。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[957]||(s[957]=[n("从此，两个运算")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2981]||(s[2981]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[958]||(s[958]=[n("hash % length")])),_:1}),s[2982]||(s[2982]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[959]||(s[959]=[n("和")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2983]||(s[2983]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[960]||(s[960]=[n("hash & (length - 1)")])),_:1}),s[2984]||(s[2984]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[961]||(s[961]=[n("有了完美的闭环。在计算机中，位运算的速度要远高于取余运算，因为计算机本质上就是二进制嘛。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[962]||(s[962]=[n("HashMap 的取模运算有两处。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[963]||(s[963]=[n("一处是往 HashMap 中 put 的时候（会调用私有的")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2985]||(s[2985]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[964]||(s[964]=[n("putVal")])),_:1}),s[2986]||(s[2986]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[965]||(s[965]=[n("方法）：")])),_:1}),s[2987]||(s[2987]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {</span>
<span class="line">    // 数组</span>
<span class="line">    HashMap.Node&lt;K,V&gt;[] tab;</span>
<span class="line">    // 元素</span>
<span class="line">    HashMap.Node&lt;K,V&gt; p;</span>
<span class="line"></span>
<span class="line">    // n 为数组的长度 i 为下标</span>
<span class="line">    int n, i;</span>
<span class="line">    // 数组为空的时候</span>
<span class="line">    if ((tab = table) == null || (n = tab.length) == 0)</span>
<span class="line">        // 第一次扩容后的数组长度</span>
<span class="line">        n = (tab = resize()).length;</span>
<span class="line">    // 计算节点的插入位置，如果该位置为空，则新建一个节点插入</span>
<span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span>
<span class="line">        tab[i] = newNode(hash, key, value, null);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[966]||(s[966]=[n("其中")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2988]||(s[2988]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[967]||(s[967]=[n("(n - 1) & hash")])),_:1}),s[2989]||(s[2989]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[968]||(s[968]=[n("为取模运算，为什么没用")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2990]||(s[2990]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[969]||(s[969]=[n("%")])),_:1}),s[2991]||(s[2991]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[970]||(s[970]=[n("，我们随后解释。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[971]||(s[971]=[n("一处是从 HashMap 中 get 的时候（会调用")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2992]||(s[2992]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[972]||(s[972]=[n("getNode")])),_:1}),s[2993]||(s[2993]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[973]||(s[973]=[n("方法）：")])),_:1}),s[2994]||(s[2994]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) {</span>
<span class="line">    // 获取当前的数组和长度，以及当前节点链表的第一个节点（根据索引直接从数组中找）</span>
<span class="line">    Node&lt;K,V&gt;[] tab;</span>
<span class="line">    Node&lt;K,V&gt; first, e;</span>
<span class="line">    int n;</span>
<span class="line">    K k;</span>
<span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span>
<span class="line">            (first = tab[(n - 1) &amp; hash]) != null) {</span>
<span class="line">        // 如果第一个节点就是要查找的节点，则直接返回</span>
<span class="line">        if (first.hash == hash &amp;&amp; ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span>
<span class="line">            return first;</span>
<span class="line">        // 如果第一个节点不是要查找的节点，则遍历节点链表查找</span>
<span class="line">        if ((e = first.next) != null) {</span>
<span class="line">            do {</span>
<span class="line">                if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span>
<span class="line">                    return e;</span>
<span class="line">            } while ((e = e.next) != null);</span>
<span class="line">        }</span>
<span class="line">    }</span>
<span class="line">    // 如果节点链表中没有找到对应的节点，则返回 null</span>
<span class="line">    return null;</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[974]||(s[974]=[n("看到没，取模运算")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2995]||(s[2995]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[975]||(s[975]=[n("(n - 1) & hash")])),_:1}),s[2996]||(s[2996]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[976]||(s[976]=[n("再次出现，说简单点，就是把键的哈希码经过")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2997]||(s[2997]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[977]||(s[977]=[n("hash()")])),_:1}),s[2998]||(s[2998]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[978]||(s[978]=[n("方法计算后，再和（数组长度-1）做了一个“与”运算。")])),_:1}),a("h4",Zs,[a("a",hs,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[979]||(s[979]=[n("取模运算%和位运算&")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[980]||(s[980]=[n("可能大家在疑惑：")])),_:1}),s[2999]||(s[2999]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[981]||(s[981]=[n("取模运算难道不该用")])),_:1}),s[3e3]||(s[3e3]=n("****")),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3001]||(s[3001]=n("**`**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[982]||(s[982]=[n("%")])),_:1}),s[3002]||(s[3002]=n("**`**")),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3003]||(s[3003]=n("****")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[983]||(s[983]=[n("吗？为什么要用位运算")])),_:1}),s[3004]||(s[3004]=n("****")),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3005]||(s[3005]=n("**`**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[984]||(s[984]=[n("&")])),_:1}),s[3006]||(s[3006]=n("**`**")),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3007]||(s[3007]=n("****")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[985]||(s[985]=[n("呢")])),_:1}),s[3008]||(s[3008]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[986]||(s[986]=[n("？")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[987]||(s[987]=[n("这是因为")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3009]||(s[3009]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[988]||(s[988]=[n("&")])),_:1}),s[3010]||(s[3010]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[989]||(s[989]=[n("运算比")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3011]||(s[3011]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[990]||(s[990]=[n("%")])),_:1}),s[3012]||(s[3012]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[991]||(s[991]=[n("更加高效，并且当 b 为 2 的 n 次方时，存在下面这样一个公式。")])),_:1}),l(e,{style:{color:"rgb(102, 102, 102)"}},{default:i(()=>s[992]||(s[992]=[n("a % b = a & (b-1)")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[993]||(s[993]=[n("用 ${2^n}$ 替换下 b 就是：")])),_:1}),l(e,{style:{color:"rgb(102, 102, 102)"}},{default:i(()=>s[994]||(s[994]=[n("a % ${2^n}$ = a & (${2^n}$-1)")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[995]||(s[995]=[n("我们来验证一下，假如 a = 14，b = 8，也就是 ${2^3}$，n=3。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[996]||(s[996]=[n("14%8（余数为 6）。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[997]||(s[997]=[n("14 的二进制为 1110，8 的二进制 1000，8-1 = 7，7 的二进制为 0111，1110&0111=0110，也就是 0")])),_:1}),s[3013]||(s[3013]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[998]||(s[998]=[n("*")])),_:1}),s[3014]||(s[3014]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[999]||(s[999]=[n("${2")])),_:1}),a("sup",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1e3]||(s[1e3]=[n("0}$+1`*`${2")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1001]||(s[1001]=[n("1}$+1")])),_:1}),s[3015]||(s[3015]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1002]||(s[1002]=[n("*")])),_:1}),s[3016]||(s[3016]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1003]||(s[1003]=[n("${2")])),_:1}),a("sup",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1004]||(s[1004]=[n("2}$+0`*`${2")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1005]||(s[1005]=[n("3}$=0+2+4+0=6，14%8 刚好也等于 6。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1006]||(s[1006]=[n("害，计算机就是这么讲道理，没办法，")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1007]||(s[1007]=[n("😝")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1008]||(s[1008]=[n("这也正好解释了")])),_:1}),s[3017]||(s[3017]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1009]||(s[1009]=[n("为什么 HashMap 的数组长度要取 2 的整次方")])),_:1}),s[3018]||(s[3018]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1010]||(s[1010]=[n("。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1011]||(s[1011]=[n("为什么会这样巧呢？")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1012]||(s[1012]=[n("因为（数组长度-1）正好相当于一个“低位掩码”——这个掩码的低位最好全是 1，这样 & 操作才有意义，否则结果就肯定是 0。")])),_:1}),l(e,{style:{color:"rgb(102, 102, 102)"}},{default:i(()=>s[1013]||(s[1013]=[n("a&b 操作的结果是：a、b 中对应位同时为 1，则对应结果位为 1，否则为 0。例如 5&3=1，5 的二进制是 0101，3 的二进制是 0011，5&3=0001=1。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1014]||(s[1014]=[n("2 的整次幂刚好是偶数，偶数-1 是奇数，奇数的二进制最后一位是 1，保证了")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3019]||(s[3019]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1015]||(s[1015]=[n("hash &(length-1)")])),_:1}),s[3020]||(s[3020]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1016]||(s[1016]=[n("的最后一位可能为 0，也可能为 1（取决于 hash 的值），即 & 运算后的结果可能为偶数，也可能为奇数，这样便可以保证哈希值的均匀分布。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1017]||(s[1017]=[n("换句话说，& 操作的结果就是将哈希值的高位全部归零，只保留低位值。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1018]||(s[1018]=[n("假设某哈希值的二进制为")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3021]||(s[3021]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1019]||(s[1019]=[n("10100101 11000100 00100101")])),_:1}),s[3022]||(s[3022]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1020]||(s[1020]=[n("，用它来做 & 运算，我们来看一下结果。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1021]||(s[1021]=[n("我们知道，HashMap 的初始长度为 16，16-1=15，二进制是")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3023]||(s[3023]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1022]||(s[1022]=[n("00000000 00000000 00001111")])),_:1}),s[3024]||(s[3024]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1023]||(s[1023]=[n("（高位用 0 来补齐）：")])),_:1}),s[3025]||(s[3025]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">10100101 11000100 00100101</span>
<span class="line">&amp;	 00000000 00000000 00001111</span>
<span class="line">----------------------------------</span>
<span class="line">	 00000000 00000000 00000101</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1024]||(s[1024]=[n("因为 15 的高位全部是 0，所以 & 运算后的高位结果肯定也是 0，只剩下 4 个低位")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3026]||(s[3026]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1025]||(s[1025]=[n("0101")])),_:1}),s[3027]||(s[3027]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1026]||(s[1026]=[n("，也就是十进制的 5。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1027]||(s[1027]=[n("这样，哈希值为")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3028]||(s[3028]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1028]||(s[1028]=[n("10100101 11000100 00100101")])),_:1}),s[3029]||(s[3029]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1029]||(s[1029]=[n("的键就会放在数组的第 5 个位置上。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1030]||(s[1030]=[n("当然了，如果你是新手，上面这些 01 串看不太懂，也没关系。记住 &运算是为了计算数组的下标就可以了。")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1031]||(s[1031]=[n("put 的时候计算下标，把键值对放到对应的桶上。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1032]||(s[1032]=[n("get 的时候通过下标，把键值对从对应的桶上取出来。")])),_:1})])]),a("h4",_s,[a("a",sn,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1033]||(s[1033]=[n("为什么取模运算之前要调用 hash 方法呢？")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1034]||(s[1034]=[n("看下面这个图。")])),_:1}),s[3030]||(s[3030]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726668343936-037cb272-88df-47f6-a8c6-48c91702a975.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1035]||(s[1035]=[n("某哈希值为")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3031]||(s[3031]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1036]||(s[1036]=[n("11111111 11111111 11110000 1110 1010")])),_:1}),s[3032]||(s[3032]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1037]||(s[1037]=[n("，将它右移 16 位（h >>> 16），刚好是")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3033]||(s[3033]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1038]||(s[1038]=[n("00000000 00000000 11111111 11111111")])),_:1}),s[3034]||(s[3034]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1039]||(s[1039]=[n("，再进行异或操作（h ^ (h >>> 16)），结果是")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3035]||(s[3035]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1040]||(s[1040]=[n("11111111 11111111 00001111 00010101")])),_:1}),s[3036]||(s[3036]=n("`")),l(e,{style:{color:"rgb(102, 102, 102)"}},{default:i(()=>s[1041]||(s[1041]=[n("异或（")])),_:1}),s[3037]||(s[3037]=n("`")),l(e,{style:{color:"rgb(102, 102, 102)"}},{default:i(()=>s[1042]||(s[1042]=[n("^")])),_:1}),s[3038]||(s[3038]=n("`")),l(e,{style:{color:"rgb(102, 102, 102)"}},{default:i(()=>s[1043]||(s[1043]=[n("）运算是基于二进制的位运算，采用符号 XOR 或者")])),_:1}),s[3039]||(s[3039]=n("`")),l(e,{style:{color:"rgb(102, 102, 102)"}},{default:i(()=>s[1044]||(s[1044]=[n("^")])),_:1}),s[3040]||(s[3040]=n("`")),l(e,{style:{color:"rgb(102, 102, 102)"}},{default:i(()=>s[1045]||(s[1045]=[n("来表示，运算规则是：如果是同值取 0、异值取 1")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1046]||(s[1046]=[n("由于混合了原来哈希值的高位和低位，所以低位的随机性加大了（掺杂了部分高位的特征，高位的信息也得到了保留）。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1047]||(s[1047]=[n("结果再与数组长度-1（")])),_:1}),s[3041]||(s[3041]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1048]||(s[1048]=[n("00000000 00000000 00000000 00001111")])),_:1}),s[3042]||(s[3042]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1049]||(s[1049]=[n("）做取模运算，得到的下标就是")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3043]||(s[3043]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1050]||(s[1050]=[n("00000000 00000000 00000000 00000101")])),_:1}),s[3044]||(s[3044]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1051]||(s[1051]=[n("，也就是 5。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1052]||(s[1052]=[n("还记得之前我们假设的某哈希值")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3045]||(s[3045]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1053]||(s[1053]=[n("10100101 11000100 00100101")])),_:1}),s[3046]||(s[3046]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1054]||(s[1054]=[n("吗？在没有调用 hash 方法之前，与 15 做取模运算后的结果也是 5，我们不妨来看看调用 hash 之后的取模运算结果是多少。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1055]||(s[1055]=[n("某哈希值")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3047]||(s[3047]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1056]||(s[1056]=[n("00000000 10100101 11000100 00100101")])),_:1}),s[3048]||(s[3048]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1057]||(s[1057]=[n("（补齐 32 位），将它右移 16 位（h >>> 16），刚好是")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3049]||(s[3049]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1058]||(s[1058]=[n("00000000 00000000 00000000 10100101")])),_:1}),s[3050]||(s[3050]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1059]||(s[1059]=[n("，再进行异或操作（h ^ (h >>> 16)），结果是")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3051]||(s[3051]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1060]||(s[1060]=[n("00000000 10100101 00111011 10000000")])),_:1}),s[3052]||(s[3052]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1061]||(s[1061]=[n("结果再与数组长度-1（")])),_:1}),s[3053]||(s[3053]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1062]||(s[1062]=[n("00000000 00000000 00000000 00001111")])),_:1}),s[3054]||(s[3054]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1063]||(s[1063]=[n("）做取模运算，得到的下标就是")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3055]||(s[3055]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1064]||(s[1064]=[n("00000000 00000000 00000000 00000000")])),_:1}),s[3056]||(s[3056]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1065]||(s[1065]=[n("，也就是 0。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1066]||(s[1066]=[n("综上所述，")])),_:1}),s[3057]||(s[3057]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1067]||(s[1067]=[n("hash 方法是用来做哈希值优化的")])),_:1}),s[3058]||(s[3058]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1068]||(s[1068]=[n("，把哈希值右移 16 位，也就正好是自己长度的一半，之后与原哈希值做异或运算，这样就混合了原哈希值中的高位和低位，增大了随机性。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1069]||(s[1069]=[n("说白了，")])),_:1}),s[3059]||(s[3059]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1070]||(s[1070]=[n("hash 方法就是为了增加随机性，让数据元素更加均衡的分布，减少碰撞")])),_:1}),s[3060]||(s[3060]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1071]||(s[1071]=[n("。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1072]||(s[1072]=[n("我这里写了一段测试代码，假如 HashMap 的容量就是第一次扩容时候的 16，我在里面放了五个键值对，来看一下键的 hash 值（经过")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3061]||(s[3061]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1073]||(s[1073]=[n("hash()")])),_:1}),s[3062]||(s[3062]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1074]||(s[1074]=[n("方法计算后的哈希码）和索引（取模运算后）")])),_:1}),s[3063]||(s[3063]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();</span>
<span class="line">map.put(&quot;chenmo&quot;, &quot;沉默&quot;);</span>
<span class="line">map.put(&quot;wanger&quot;, &quot;王二&quot;);</span>
<span class="line">map.put(&quot;chenqingyang&quot;, &quot;陈清扬&quot;);</span>
<span class="line">map.put(&quot;xiaozhuanling&quot;, &quot;小转铃&quot;);</span>
<span class="line">map.put(&quot;fangxiaowan&quot;, &quot;方小婉&quot;);</span>
<span class="line"></span>
<span class="line">// 遍历 HashMap</span>
<span class="line">for (String key : map.keySet()) {</span>
<span class="line">    int h, n = 16;</span>
<span class="line">    int hash = (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span>
<span class="line">    int i = (n - 1) &amp; hash;</span>
<span class="line">    // 打印 key 的 hash 值 和 索引 i</span>
<span class="line">    System.out.println(key + &quot;的hash值 : &quot; + hash +&quot; 的索引 : &quot; + i);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1075]||(s[1075]=[n("输出结果如下所示：")])),_:1}),s[3064]||(s[3064]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">xiaozhuanling的hash值 : 14597045 的索引 : 5</span>
<span class="line">fangxiaowan的hash值 : -392727066 的索引 : 6</span>
<span class="line">chenmo的hash值 : -1361556696 的索引 : 8</span>
<span class="line">chenqingyang的hash值 : -613818743 的索引 : 9</span>
<span class="line">wanger的hash值 : -795084437 的索引 : 11</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1076]||(s[1076]=[n("也就是说，此时还没有发生哈希冲突，索引值都是比较均匀分布的，5、6、8、9、11，这其中的很大一部分功劳，就来自于 hash 方法。")])),_:1}),a("h4",nn,[a("a",ln,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1077]||(s[1077]=[n("小结")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1078]||(s[1078]=[n("hash 方法的主要作用是将 key 的 hashCode 值进行处理，得到最终的哈希值。由于 key 的 hashCode 值是不确定的，可能会出现哈希冲突，因此需要将哈希值通过一定的算法映射到 HashMap 的实际存储位置上。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1079]||(s[1079]=[n("hash 方法的原理是，先获取 key 对象的 hashCode 值，然后将其高位与低位进行异或操作，得到一个新的哈希值。为什么要进行异或操作呢？因为对于 hashCode 的高位和低位，它们的分布是比较均匀的，如果只是简单地将它们加起来或者进行位运算，容易出现哈希冲突，而异或操作可以避免这个问题。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1080]||(s[1080]=[n("然后将新的哈希值取模（mod），得到一个实际的存储位置。这个取模操作的目的是将哈希值映射到桶（Bucket）的索引上，桶是 HashMap 中的一个数组，每个桶中会存储着一个链表（或者红黑树），装载哈希值相同的键值对（没有相同哈希值的话就只存储一个键值对）。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1081]||(s[1081]=[n("总的来说，HashMap 的 hash 方法就是将 key 对象的 hashCode 值进行处理，得到最终的哈希值，并通过一定的算法映射到实际的存储位置上。这个过程决定了 HashMap 内部键值对的查找效率。")])),_:1}),a("h3",en,[a("a",an,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1082]||(s[1082]=[n("HashMap 的扩容机制")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1083]||(s[1083]=[n("好，理解了 hash 方法后我们来看第二个问题，HashMap 的扩容机制。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1084]||(s[1084]=[n("大家都知道，数组一旦初始化后大小就无法改变了，所以就有了")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3065]||(s[3065]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1085]||(s[1085]=[n("ArrayList")])),_:1}),s[3066]||(s[3066]=n("](https://javabebetter.cn/collection/arraylist.html)")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1086]||(s[1086]=[n("这种“动态数组”，可以自动扩容。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1087]||(s[1087]=[n("HashMap 的底层用的也是数组。向 HashMap 里不停地添加元素，当数组无法装载更多元素时，就需要对数组进行扩容，以便装入更多的元素；除此之外，容量的提升也会相应地提高查询效率，因为“桶（坑）”更多了嘛，原来需要通过链表存储的（查询的时候需要遍历），扩容后可能就有自己专属的“坑位”了（直接就能查出来）。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1088]||(s[1088]=[n("来看这个例子，容量我们定位 16：")])),_:1}),s[3067]||(s[3067]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();</span>
<span class="line">map.put(&quot;chenmo&quot;, &quot;沉默&quot;);</span>
<span class="line">map.put(&quot;wanger&quot;, &quot;王二&quot;);</span>
<span class="line">map.put(&quot;chenqingyang&quot;, &quot;陈清扬&quot;);</span>
<span class="line">map.put(&quot;xiaozhuanling&quot;, &quot;小转铃&quot;);</span>
<span class="line">map.put(&quot;fangxiaowan&quot;, &quot;方小婉&quot;);</span>
<span class="line">map.put(&quot;yexin&quot;, &quot;叶辛&quot;);</span>
<span class="line">map.put(&quot;liuting&quot;,&quot;刘婷&quot;);</span>
<span class="line">map.put(&quot;yaoxiaojuan&quot;,&quot;姚小娟&quot;);</span>
<span class="line"></span>
<span class="line">// 遍历 HashMap</span>
<span class="line">for (String key : map.keySet()) {</span>
<span class="line">    int h, n = 16;</span>
<span class="line">    int hash = (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span>
<span class="line">    int i = (n - 1) &amp; hash;</span>
<span class="line">    // 打印 key 的 hash 值 和 索引 i</span>
<span class="line">    System.out.println(key + &quot;的hash值 : &quot; + hash +&quot; 的索引 : &quot; + i);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1089]||(s[1089]=[n("来看输出结果：")])),_:1}),s[3068]||(s[3068]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">liuting的hash值 : 183821170 的索引 : 2</span>
<span class="line">xiaozhuanling的hash值 : 14597045 的索引 : 5</span>
<span class="line">fangxiaowan的hash值 : -392727066 的索引 : 6</span>
<span class="line">yaoxiaojuan的hash值 : 1231568918 的索引 : 6</span>
<span class="line">chenmo的hash值 : -1361556696 的索引 : 8</span>
<span class="line">chenqingyang的hash值 : -613818743 的索引 : 9</span>
<span class="line">yexin的hash值 : 114873289 的索引 : 9</span>
<span class="line">wanger的hash值 : -795084437 的索引 : 11</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1090]||(s[1090]=[n("看到没？")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1091]||(s[1091]=[n("fangxiaowan（方小婉）和 yaoxiaojuan（姚小娟）的索引都是 6；")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1092]||(s[1092]=[n("chenqingyang（陈清扬）和 yexin（叶辛）的索引都是 9")])),_:1})])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1093]||(s[1093]=[n("这就意味着，要采用拉链法（后面会讲）将他们放在同一个索引的链表上。查询的时候，就不能直接通过索引的方式直接拿到（")])),_:1}),s[3069]||(s[3069]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1094]||(s[1094]=[n("时间复杂度")])),_:1}),s[3070]||(s[3070]=n("](https://javabebetter.cn/collection/time-complexity.html)")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1095]||(s[1095]=[n("为 O(1)），而要通过遍历的方式（时间复杂度为 O(n)）。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1096]||(s[1096]=[n("那假如把数组的长度由 16 扩容为 32 呢？")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1097]||(s[1097]=[n("将之前示例中的 n 由 16 改为 32 即可得到如下的答案：")])),_:1}),s[3071]||(s[3071]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">liuting的hash值 : 183821170 的索引 : 18</span>
<span class="line">xiaozhuanling的hash值 : 14597045 的索引 : 21</span>
<span class="line">fangxiaowan的hash值 : -392727066 的索引 : 6</span>
<span class="line">yaoxiaojuan的hash值 : 1231568918 的索引 : 22</span>
<span class="line">chenmo的hash值 : -1361556696 的索引 : 8</span>
<span class="line">chenqingyang的hash值 : -613818743 的索引 : 9</span>
<span class="line">yexin的hash值 : 114873289 的索引 : 9</span>
<span class="line">wanger的hash值 : -795084437 的索引 : 11</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1098]||(s[1098]=[n("可以看到：")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1099]||(s[1099]=[n("虽然 chenqingyang（陈清扬）和 yexin（叶辛）的索引仍然是 9。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1100]||(s[1100]=[n("但 fangxiaowan（方小婉）的索引为 6，yaoxiaojuan（姚小娟）的索引由 6 变为 22，各自都有坑了。")])),_:1})])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1101]||(s[1101]=[n("当然了，数组是无法自动扩容的，所以如果要扩容的话，就需要新建一个大的数组，然后把之前小的数组的元素复制过去，并且要重新计算哈希值和重新分配桶（重新散列），这个过程也是挺耗时的。")])),_:1}),a("h4",tn,[a("a",rn,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1102]||(s[1102]=[n("resize 方法")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1103]||(s[1103]=[n("HashMap 的扩容是通过 resize 方法来实现的，JDK 8 中融入了红黑树（链表长度超过 8 的时候，会将链表转化为红黑树来提高查询效率），对于新手来说，可能比较难理解。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1104]||(s[1104]=[n("为了减轻大家的学习压力，就还使用 JDK 7 的源码，搞清楚了 JDK 7 的，再看 JDK 8 的就会轻松很多。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1105]||(s[1105]=[n("来看 Java7 的 resize 方法源码，我加了注释：")])),_:1}),s[3072]||(s[3072]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">// newCapacity为新的容量</span>
<span class="line">void resize(int newCapacity) {</span>
<span class="line">    // 小数组，临时过度下</span>
<span class="line">    Entry[] oldTable = table;</span>
<span class="line">    // 扩容前的容量</span>
<span class="line">    int oldCapacity = oldTable.length;</span>
<span class="line">    // MAXIMUM_CAPACITY 为最大容量，2 的 30 次方 = 1&lt;&lt;30</span>
<span class="line">    if (oldCapacity == MAXIMUM_CAPACITY) {</span>
<span class="line">        // 容量调整为 Integer 的最大值 0x7fffffff（十六进制）=2 的 31 次方-1</span>
<span class="line">        threshold = Integer.MAX_VALUE;</span>
<span class="line">        return;</span>
<span class="line">    }</span>
<span class="line"></span>
<span class="line">    // 初始化一个新的数组（大容量）</span>
<span class="line">    Entry[] newTable = new Entry[newCapacity];</span>
<span class="line">    // 把小数组的元素转移到大数组中</span>
<span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span>
<span class="line">    // 引用新的大数组</span>
<span class="line">    table = newTable;</span>
<span class="line">    // 重新计算阈值</span>
<span class="line">    threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1106]||(s[1106]=[n("该方法接收一个新的容量 newCapacity，然后将 HashMap 的容量扩大到 newCapacity。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1107]||(s[1107]=[n("首先，方法获取当前 HashMap 的旧数组 oldTable 和旧容量 oldCapacity。如果旧容量已经达到 HashMap 支持的最大容量 MAXIMUM_CAPACITY（ 2 的 30 次方），就将新的阈值 threshold 调整为 Integer.MAX_VALUE（2 的 31 次方 - 1），这是因为 HashMap 的容量不能超过 MAXIMUM_CAPACITY。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1108]||(s[1108]=[n("因为 2,147,483,647（Integer.MAX_VALUE） - 1,073,741,824（MAXIMUM_CAPACITY） = 1,073,741,823，刚好相差一倍（HashMap 每次扩容都是之前的一倍）。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1109]||(s[1109]=[n("接着，方法创建一个新的数组 newTable，并将旧数组 oldTable 中的元素转移到新数组 newTable 中。转移过程是通过调用 transfer 方法来实现的。该方法遍历旧数组中的每个桶，并将每个桶中的键值对重新计算哈希值后，将其插入到新数组对应的桶中。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1110]||(s[1110]=[n("转移完成后，方法将 HashMap 内部的数组引用 table 指向新数组 newTable，并重新计算阈值 threshold。新的阈值是新容量 newCapacity 乘以负载因子 loadFactor 的结果，但如果计算结果超过了 HashMap 支持的最大容量 MAXIMUM_CAPACITY，则将阈值设置为 MAXIMUM_CAPACITY + 1，这是因为 HashMap 的元素数量不能超过 MAXIMUM_CAPACITY。")])),_:1}),a("h4",dn,[a("a",pn,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1111]||(s[1111]=[n("新容量 newCapacity")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1112]||(s[1112]=[n("那 newCapacity 是如何计算的呢？")])),_:1}),s[3073]||(s[3073]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">int newCapacity = oldCapacity * 2;</span>
<span class="line">if (newCapacity &lt; 0 || newCapacity &gt;= MAXIMUM_CAPACITY) {</span>
<span class="line">    newCapacity = MAXIMUM_CAPACITY;</span>
<span class="line">} else if (newCapacity &lt; DEFAULT_INITIAL_CAPACITY) {</span>
<span class="line">    newCapacity = DEFAULT_INITIAL_CAPACITY;</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1113]||(s[1113]=[n("新容量 newCapacity 被初始化为原容量 oldCapacity 的两倍。然后，如果 newCapacity 超过了 HashMap 的容量限制 MAXIMUM_CAPACITY（2^30），就将 newCapacity 设置为 MAXIMUM_CAPACITY。如果 newCapacity 小于默认初始容量 DEFAULT_INITIAL_CAPACITY（16），就将 newCapacity 设置为 DEFAULT_INITIAL_CAPACITY。这样可以避免新容量太小或太大导致哈希冲突过多或者浪费空间。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1114]||(s[1114]=[n("Java 8 的时候，newCapacity 的计算方式发生了一些细微的变化。")])),_:1}),s[3074]||(s[3074]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">int newCapacity = oldCapacity &lt;&lt; 1;</span>
<span class="line">if (newCapacity &gt;= DEFAULT_INITIAL_CAPACITY &amp;&amp; oldCapacity &gt;= DEFAULT_INITIAL_CAPACITY) {</span>
<span class="line">    if (newCapacity &gt; MAXIMUM_CAPACITY)</span>
<span class="line">        newCapacity = MAXIMUM_CAPACITY;</span>
<span class="line">} else {</span>
<span class="line">    if (newCapacity &lt; DEFAULT_INITIAL_CAPACITY)</span>
<span class="line">        newCapacity = DEFAULT_INITIAL_CAPACITY;</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1115]||(s[1115]=[n("注意，")])),_:1}),s[3075]||(s[3075]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1116]||(s[1116]=[n("oldCapacity * 2")])),_:1}),s[3076]||(s[3076]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1117]||(s[1117]=[n("变成了")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3077]||(s[3077]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1118]||(s[1118]=[n("oldCapacity << 1")])),_:1}),s[3078]||(s[3078]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1119]||(s[1119]=[n("，出现了左移（")])),_:1}),s[3079]||(s[3079]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1120]||(s[1120]=[n("<<")])),_:1}),s[3080]||(s[3080]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1121]||(s[1121]=[n("），这里简单介绍一下：")])),_:1}),s[3081]||(s[3081]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">a=39</span>
<span class="line">b = a &lt;&lt; 2</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1122]||(s[1122]=[n("十进制 39 用 8 位的二进制来表示，就是 00100111，左移两位后是 10011100（低位用 0 补上），再转成十进制数就是 156。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1123]||(s[1123]=[n("移位运算通常可以用来代替乘法运算和除法运算。例如，将 0010011（39）左移两位就是 10011100（156），刚好变成了原来的 4 倍。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1124]||(s[1124]=[n("实际上呢，二进制数左移后会变成原来的 2 倍、4 倍、8 倍，记住这个就好。")])),_:1}),a("h4",on,[a("a",un,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1125]||(s[1125]=[n("transfer 方法")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1126]||(s[1126]=[n("接下来，来说 transfer 方法，该方法用来转移，将旧的小数组元素拷贝到新的大数组中。")])),_:1}),s[3082]||(s[3082]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">void transfer(Entry[] newTable, boolean rehash) {</span>
<span class="line">    // 新的容量</span>
<span class="line">    int newCapacity = newTable.length;</span>
<span class="line">    // 遍历小数组</span>
<span class="line">    for (Entry&lt;K,V&gt; e : table) {</span>
<span class="line">        while(null != e) {</span>
<span class="line">            // 拉链法，相同 key 上的不同值</span>
<span class="line">            Entry&lt;K,V&gt; next = e.next;</span>
<span class="line">            // 是否需要重新计算 hash</span>
<span class="line">            if (rehash) {</span>
<span class="line">                e.hash = null == e.key ? 0 : hash(e.key);</span>
<span class="line">            }</span>
<span class="line">            // 根据大数组的容量，和键的 hash 计算元素在数组中的下标</span>
<span class="line">            int i = indexFor(e.hash, newCapacity);</span>
<span class="line"></span>
<span class="line">            // 同一位置上的新元素被放在链表的头部</span>
<span class="line">            e.next = newTable[i];</span>
<span class="line"></span>
<span class="line">            // 放在新的数组上</span>
<span class="line">            newTable[i] = e;</span>
<span class="line"></span>
<span class="line">            // 链表上的下一个元素</span>
<span class="line">            e = next;</span>
<span class="line">        }</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1127]||(s[1127]=[n("该方法接受一个新的 Entry 数组 newTable 和一个布尔值 rehash 作为参数，其中 newTable 表示新的哈希表，rehash 表示是否需要重新计算键的哈希值。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1128]||(s[1128]=[n("在方法中，首先获取新哈希表（数组）的长度 newCapacity，然后遍历旧哈希表中的每个 Entry。对于每个 Entry，使用拉链法将相同 key 值的不同 value 值存储在同一个链表中。如果 rehash 为 true，则需要重新计算键的哈希值，并将新的哈希值存储在 Entry 的 hash 属性中。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1129]||(s[1129]=[n("接着，根据新哈希表的长度和键的哈希值，计算 Entry 在新数组中的位置 i，然后将该 Entry 添加到新数组的 i 位置上。由于新元素需要被放在链表的头部，因此将新元素的下一个元素设置为当前数组位置上的元素。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1130]||(s[1130]=[n("最后，遍历完旧哈希表中的所有元素后，转移工作完成，新的哈希表 newTable 已经包含了旧哈希表中的所有元素。")])),_:1}),a("h4",vn,[a("a",bn,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1131]||(s[1131]=[n("拉链法")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1132]||(s[1132]=[n("注意，")])),_:1}),s[3083]||(s[3083]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1133]||(s[1133]=[n("e.next = newTable[i]")])),_:1}),s[3084]||(s[3084]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1134]||(s[1134]=[n("，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素最终会被放到链表的尾部，这就会导致")])),_:1}),s[3085]||(s[3085]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1135]||(s[1135]=[n("在旧数组中同一个链表上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上")])),_:1}),s[3086]||(s[3086]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1136]||(s[1136]=[n("。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1137]||(s[1137]=[n("为了解决这个问题，Java 8 做了很大的优化（讲扩容的时候会讲到）。")])),_:1}),a("h4",mn,[a("a",gn,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1138]||(s[1138]=[n("Java 8 扩容")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1139]||(s[1139]=[n("JDK 8 的扩容源代码：")])),_:1}),s[3087]||(s[3087]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">final Node&lt;K,V&gt;[] resize() {</span>
<span class="line">    Node&lt;K,V&gt;[] oldTab = table; // 获取原来的数组 table</span>
<span class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length; // 获取数组长度 oldCap</span>
<span class="line">    int oldThr = threshold; // 获取阈值 oldThr</span>
<span class="line">    int newCap, newThr = 0;</span>
<span class="line">    if (oldCap &gt; 0) { // 如果原来的数组 table 不为空</span>
<span class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) { // 超过最大值就不再扩充了，就只好随你碰撞去吧</span>
<span class="line">            threshold = Integer.MAX_VALUE;</span>
<span class="line">            return oldTab;</span>
<span class="line">        }</span>
<span class="line">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; // 没超过最大值，就扩充为原来的2倍</span>
<span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span>
<span class="line">            newThr = oldThr &lt;&lt; 1; // double threshold</span>
<span class="line">    }</span>
<span class="line">    else if (oldThr &gt; 0) // initial capacity was placed in threshold</span>
<span class="line">        newCap = oldThr;</span>
<span class="line">    else { // zero initial threshold signifies using defaults</span>
<span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span>
<span class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span>
<span class="line">    }</span>
<span class="line">    // 计算新的 resize 上限</span>
<span class="line">    if (newThr == 0) {</span>
<span class="line">        float ft = (float)newCap * loadFactor;</span>
<span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span>
<span class="line">                  (int)ft : Integer.MAX_VALUE);</span>
<span class="line">    }</span>
<span class="line">    threshold = newThr; // 将新阈值赋值给成员变量 threshold</span>
<span class="line">    @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})</span>
<span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; // 创建新数组 newTab</span>
<span class="line">    table = newTab; // 将新数组 newTab 赋值给成员变量 table</span>
<span class="line">    if (oldTab != null) { // 如果旧数组 oldTab 不为空</span>
<span class="line">        for (int j = 0; j &lt; oldCap; ++j) { // 遍历旧数组的每个元素</span>
<span class="line">            Node&lt;K,V&gt; e;</span>
<span class="line">            if ((e = oldTab[j]) != null) { // 如果该元素不为空</span>
<span class="line">                oldTab[j] = null; // 将旧数组中该位置的元素置为 null，以便垃圾回收</span>
<span class="line">                if (e.next == null) // 如果该元素没有冲突</span>
<span class="line">                    newTab[e.hash &amp; (newCap - 1)] = e; // 直接将该元素放入新数组</span>
<span class="line">                else if (e instanceof TreeNode) // 如果该元素是树节点</span>
<span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); // 将该树节点分裂成两个链表</span>
<span class="line">                else { // 如果该元素是链表</span>
<span class="line">                    Node&lt;K,V&gt; loHead = null, loTail = null; // 低位链表的头结点和尾结点</span>
<span class="line">                    Node&lt;K,V&gt; hiHead = null, hiTail = null; // 高位链表的头结点和尾结点</span>
<span class="line">                    Node&lt;K,V&gt; next;</span>
<span class="line">                    do { // 遍历该链表</span>
<span class="line">                        next = e.next;</span>
<span class="line">                        if ((e.hash &amp; oldCap) == 0) { // 如果该元素在低位链表中</span>
<span class="line">                            if (loTail == null) // 如果低位链表还没有结点</span>
<span class="line">                                loHead = e; // 将该元素作为低位链表的头结点</span>
<span class="line">                            else</span>
<span class="line">                                loTail.next = e; // 如果低位链表已经有结点，将该元素加入低位链表的尾部</span>
<span class="line">                            loTail = e; // 更新低位链表的尾结点</span>
<span class="line">                        }</span>
<span class="line">                        else { // 如果该元素在高位链表中</span>
<span class="line">                            if (hiTail == null) // 如果高位链表还没有结点</span>
<span class="line">                                hiHead = e; // 将该元素作为高位链表的头结点</span>
<span class="line">                            else</span>
<span class="line">                                hiTail.next = e; // 如果高位链表已经有结点，将该元素加入高位链表的尾部</span>
<span class="line">                            hiTail = e; // 更新高位链表的尾结点</span>
<span class="line">                        }</span>
<span class="line">                    } while ((e = next) != null); //</span>
<span class="line">                    if (loTail != null) { // 如果低位链表不为空</span>
<span class="line">                        loTail.next = null; // 将低位链表的尾结点指向 null，以便垃圾回收</span>
<span class="line">                        newTab[j] = loHead; // 将低位链表作为新数组对应位置的元素</span>
<span class="line">                    }</span>
<span class="line">                    if (hiTail != null) { // 如果高位链表不为空</span>
<span class="line">                        hiTail.next = null; // 将高位链表的尾结点指向 null，以便垃圾回收</span>
<span class="line">                        newTab[j + oldCap] = hiHead; // 将高位链表作为新数组对应位置的元素</span>
<span class="line">                    }</span>
<span class="line">                }</span>
<span class="line">            }</span>
<span class="line">        }</span>
<span class="line">    }</span>
<span class="line">    return newTab; // 返回新数组</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1140]||(s[1140]=[n("1、获取原来的数组 table、数组长度 oldCap 和阈值 oldThr。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1141]||(s[1141]=[n("2、如果原来的数组 table 不为空，则根据扩容规则计算新数组长度 newCap 和新阈值 newThr，然后将原数组中的元素复制到新数组中。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1142]||(s[1142]=[n("3、如果原来的数组 table 为空但阈值 oldThr 不为零，则说明是通过带参数构造方法创建的 HashMap，此时将阈值作为新数组长度 newCap。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1143]||(s[1143]=[n("4、如果原来的数组 table 和阈值 oldThr 都为零，则说明是通过无参数构造方法创建的 HashMap，此时将默认初始容量")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3088]||(s[3088]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1144]||(s[1144]=[n("DEFAULT_INITIAL_CAPACITY（16）")])),_:1}),s[3089]||(s[3089]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1145]||(s[1145]=[n("和默认负载因子")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3090]||(s[3090]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1146]||(s[1146]=[n("DEFAULT_LOAD_FACTOR（0.75）")])),_:1}),s[3091]||(s[3091]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1147]||(s[1147]=[n("计算出新数组长度 newCap 和新阈值 newThr。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1148]||(s[1148]=[n("5、计算新阈值 threshold，并将其赋值给成员变量 threshold。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1149]||(s[1149]=[n("6、创建新数组 newTab，并将其赋值给成员变量 table。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1150]||(s[1150]=[n("7、如果旧数组 oldTab 不为空，则遍历旧数组的每个元素，将其复制到新数组中。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1151]||(s[1151]=[n("8、返回新数组 newTab。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1152]||(s[1152]=[n("在 JDK 7 中，定位元素位置的代码是这样的：")])),_:1}),s[3092]||(s[3092]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">static int indexFor(int h, int length) {</span>
<span class="line">    // assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</span>
<span class="line">    return h &amp; (length-1);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1153]||(s[1153]=[n("其实就相当于用键的哈希值和数组大小取模，也就是")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3093]||(s[3093]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1154]||(s[1154]=[n("hashCode % table.length")])),_:1}),s[3094]||(s[3094]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1155]||(s[1155]=[n("。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1156]||(s[1156]=[n("那我们来假设：")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1157]||(s[1157]=[n("数组 table 的长度为 2")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1158]||(s[1158]=[n("键的哈希值为 3、7、5")])),_:1})])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1159]||(s[1159]=[n("取模运算后，键发生了哈希冲突，都到")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3095]||(s[3095]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1160]||(s[1160]=[n("table[1]")])),_:1}),s[3096]||(s[3096]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1161]||(s[1161]=[n("上了。那么扩容前就是这个样子。")])),_:1}),s[3097]||(s[3097]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726668343020-04d1159a-ce25-4345-a646-0be97e9db864.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1162]||(s[1162]=[n("数组的容量为 2，key 为 3、7、5 的元素在")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3098]||(s[3098]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1163]||(s[1163]=[n("table[1]")])),_:1}),s[3099]||(s[3099]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1164]||(s[1164]=[n("上，需要通过拉链法来解决哈希冲突。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1165]||(s[1165]=[n("假设负载因子 loadFactor 为 1，也就是当元素的个数大于 table 的长度时进行扩容。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1166]||(s[1166]=[n("扩容后的数组容量为 4。")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1167]||(s[1167]=[n("key 3 取模（3%4）后是 3，放在")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[1170]||(s[1170]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1168]||(s[1168]=[n("table[3]")])),_:1}),s[1171]||(s[1171]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1169]||(s[1169]=[n("上。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1172]||(s[1172]=[n("key 7 取模（7%4）后是 3，放在")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[1175]||(s[1175]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1173]||(s[1173]=[n("table[3]")])),_:1}),s[1176]||(s[1176]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1174]||(s[1174]=[n("上的链表头部。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1177]||(s[1177]=[n("key 5 取模（5%4）后是 1，放在")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[1180]||(s[1180]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1178]||(s[1178]=[n("table[1]")])),_:1}),s[1181]||(s[1181]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1179]||(s[1179]=[n("上。")])),_:1})])]),s[3100]||(s[3100]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726668343514-109d9ab2-42e9-4174-9659-d5eba7be7ace.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1182]||(s[1182]=[n("7 跑到 3 的前面了，因为 JDK 7 使用的是头插法。")])),_:1}),s[3101]||(s[3101]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">e.next = newTable[i];</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1183]||(s[1183]=[n("同时，扩容后的 5 跑到了下标为 1 的位置。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1184]||(s[1184]=[n("最好的情况就是，扩容后的 7 在 3 的后面，5 在 7 的后面，保持原来的顺序。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1185]||(s[1185]=[n("JDK 8 完全扭转了这个局面，因为 JDK 8 的哈希算法进行了优化，当数组长度为 2 的幂次方时，能够很巧妙地解决 JDK 7 中遇到的问题。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1186]||(s[1186]=[n("JDK 8 的扩容代码如下所示：")])),_:1}),s[3102]||(s[3102]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">Node&lt;K,V&gt;[] newTab = new Node[newCapacity];</span>
<span class="line">for (int j = 0; j &lt; oldTab.length; j++) {</span>
<span class="line">    Node&lt;K,V&gt; e = oldTab[j];</span>
<span class="line">    if (e != null) {</span>
<span class="line">        int hash = e.hash;</span>
<span class="line">        int newIndex = hash &amp; (newCapacity - 1); // 计算在新数组中的位置</span>
<span class="line">        // 将节点移动到新数组的对应位置</span>
<span class="line">        newTab[newIndex] = e;</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1187]||(s[1187]=[n("新索引的计算方式是")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3103]||(s[3103]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1188]||(s[1188]=[n("hash & (newCapacity - 1)")])),_:1}),s[3104]||(s[3104]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1189]||(s[1189]=[n("，和 JDK 7 的")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3105]||(s[3105]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1190]||(s[1190]=[n("h & (length-1)")])),_:1}),s[3106]||(s[3106]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1191]||(s[1191]=[n("没什么大的差别，差别主要在 hash 方法上，JDK 8 是这样：")])),_:1}),s[3107]||(s[3107]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">static final int hash(Object key) {</span>
<span class="line">    int h;</span>
<span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1192]||(s[1192]=[n("过将键的")])),_:1}),s[3108]||(s[3108]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1193]||(s[1193]=[n("hashCode()")])),_:1}),s[3109]||(s[3109]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1194]||(s[1194]=[n("返回的 32 位哈希值与这个哈希值无符号右移 16 位的结果进行异或。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1195]||(s[1195]=[n("JDK 7 是这样：")])),_:1}),s[3110]||(s[3110]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">final int hash(Object k) {</span>
<span class="line">    int h = hashSeed;</span>
<span class="line">    if (0 != h &amp;&amp; k instanceof String) {</span>
<span class="line">        return sun.misc.Hashing.stringHash32((String) k);</span>
<span class="line">    }</span>
<span class="line"></span>
<span class="line">    h ^= k.hashCode();</span>
<span class="line"></span>
<span class="line">    // This function ensures that hashCodes that differ only by</span>
<span class="line">    // constant multiples at each bit position have a bounded</span>
<span class="line">    // number of collisions (approximately 8 at default load factor).</span>
<span class="line">    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</span>
<span class="line">    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1196]||(s[1196]=[n("我们用 JDK 8 的哈希算法来计算一下哈希值，就会发现别有洞天。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1197]||(s[1197]=[n("假设扩容前的数组长度为 16（n-1 也就是二进制的 0000 1111，1X$2")])),_:1}),a("sup",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1198]||(s[1198]=[n("0$+1X$2")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1199]||(s[1199]=[n("1$+1X$2")])),_:1}),a("sup",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1200]||(s[1200]=[n("2$+1X$2")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1201]||(s[1201]=[n("3$=1+2+4+8=15），key1 为 5（二进制为 0000 0101），key2 为 21（二进制为 0001 0101）。")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1202]||(s[1202]=[n("key1 和 n-1 做 & 运算后为 0000 0101，也就是 5；")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1203]||(s[1203]=[n("key2 和 n-1 做 & 运算后为 0000 0101，也就是 5。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1204]||(s[1204]=[n("此时哈希冲突了，用拉链法来解决哈希冲突。")])),_:1})])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1205]||(s[1205]=[n("现在，HashMap 进行了扩容，容量为原来的 2 倍，也就是 32（n-1 也就是二进制的 0001 1111，1X$2")])),_:1}),a("sup",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1206]||(s[1206]=[n("0$+1X$2")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1207]||(s[1207]=[n("1$+1X$2")])),_:1}),a("sup",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1208]||(s[1208]=[n("2$+1X$2")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1209]||(s[1209]=[n("3$+1X$2^4$=1+2+4+8+16=31）。")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1210]||(s[1210]=[n("key1 和 n-1 做 & 运算后为 0000 0101，也就是 5；")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1211]||(s[1211]=[n("key2 和 n-1 做 & 运算后为 0001 0101，也就是 21=5+16，也就是数组扩容前的位置+原数组的长度。")])),_:1})])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1212]||(s[1212]=[n("神奇吧？")])),_:1}),s[3111]||(s[3111]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726668344027-ba92d6c1-82e3-4871-acdc-719d0804672a.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1213]||(s[1213]=[n("三分恶面渣逆袭：扩容位置变化")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1214]||(s[1214]=[n("也就是说，在 JDK 8 的新 hash 算法下，数组扩容后的索引位置，要么就是原来的索引位置，要么就是“原索引+原来的容量”，遵循一定的规律。")])),_:1}),s[3112]||(s[3112]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726668344500-c9bb0109-fc99-4ff3-bab4-e90c3cecfe3e.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1215]||(s[1215]=[n("三分恶面渣逆袭：扩容节点迁移示意图")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1216]||(s[1216]=[n("当然了，这个功劳既属于新的哈希算法，也离不开 n 为 2 的整数次幂这个前提，这是它俩通力合作后的结果")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3113]||(s[3113]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1217]||(s[1217]=[n("hash & (newCapacity - 1)")])),_:1}),s[3114]||(s[3114]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1218]||(s[1218]=[n("。")])),_:1}),a("h4",yn,[a("a",fn,[a("span",null,[a("a",kn,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1219]||(s[1219]=[n("小结")])),_:1}),l(r)])])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1220]||(s[1220]=[n("当我们往 HashMap 中不断添加元素时，HashMap 会自动进行扩容操作（条件是元素数量达到负载因子（load factor）乘以数组长度时），以保证其存储的元素数量不会超出其容量限制。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1221]||(s[1221]=[n("在进行扩容操作时，HashMap 会先将数组的长度扩大一倍，然后将原来的元素重新散列到新的数组中。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1222]||(s[1222]=[n("由于元素的位置是通过 key 的 hash 和数组长度进行与运算得到的，因此在数组长度扩大后，元素的位置也会发生一些改变。一部分索引不变，另一部分索引为“原索引+旧容量”。")])),_:1}),a("h3",cn,[a("a",qn,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1223]||(s[1223]=[n("加载因子为什么是 0.75")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1224]||(s[1224]=[n("上一个问题提到了加载因子（或者叫负载因子），那么这个问题我们来讨论为什么加载因子是 0.75 而不是 0.6、0.8。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1225]||(s[1225]=[n("我们知道，HashMap 是用数组+链表/红黑树实现的，我们要想往 HashMap 中添加数据（元素/键值对）或者取数据，就需要确定数据在数组中的下标（索引）。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1226]||(s[1226]=[n("先把数据的键进行一次 hash：")])),_:1}),s[3115]||(s[3115]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">static final int hash(Object key) {</span>
<span class="line">    int h;</span>
<span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1227]||(s[1227]=[n("再做一次取模运算确定下标：")])),_:1}),s[3116]||(s[3116]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">i = (n - 1) &amp; hash</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1228]||(s[1228]=[n("那这样的过程容易产生两个问题：")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1229]||(s[1229]=[n("数组的容量过小，经过哈希计算后的下标，容易出现冲突；")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1230]||(s[1230]=[n("数组的容量过大，导致空间利用率不高。")])),_:1})])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1231]||(s[1231]=[n("加载因子是用来表示 HashMap 中数据的填满程度：")])),_:1}),l(e,{style:{color:"rgb(102, 102, 102)"}},{default:i(()=>s[1232]||(s[1232]=[n("加载因子 = 填入哈希表中的数据个数 / 哈希表的长度")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1233]||(s[1233]=[n("这就意味着：")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1234]||(s[1234]=[n("加载因子越小，填满的数据就越少，哈希冲突的几率就减少了，但浪费了空间，而且还会提高扩容的触发几率；")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1235]||(s[1235]=[n("加载因子越大，填满的数据就越多，空间利用率就高，但哈希冲突的几率就变大了。")])),_:1})])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1236]||(s[1236]=[n("好难！！！！")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1237]||(s[1237]=[n("这就必须在“")])),_:1}),s[3117]||(s[3117]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1238]||(s[1238]=[n("哈希冲突")])),_:1}),s[3118]||(s[3118]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1239]||(s[1239]=[n("”与“")])),_:1}),s[3119]||(s[3119]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1240]||(s[1240]=[n("空间利用率")])),_:1}),s[3120]||(s[3120]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1241]||(s[1241]=[n("”两者之间有所取舍，尽量保持平衡，谁也不碍着谁。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1242]||(s[1242]=[n("我们知道，HashMap 是通过拉链法来解决哈希冲突的。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1243]||(s[1243]=[n("为了减少哈希冲突发生的概率，当 HashMap 的数组长度达到一个")])),_:1}),s[3121]||(s[3121]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1244]||(s[1244]=[n("临界值")])),_:1}),s[3122]||(s[3122]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1245]||(s[1245]=[n("的时候，就会触发扩容，扩容后会将之前小数组中的元素转移到大数组中，这是一个相当耗时的操作。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1246]||(s[1246]=[n("这个临界值由什么来确定呢？")])),_:1}),l(e,{style:{color:"rgb(102, 102, 102)"}},{default:i(()=>s[1247]||(s[1247]=[n("临界值 = 初始容量 * 加载因子")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1248]||(s[1248]=[n("一开始，HashMap 的容量是 16：")])),_:1}),s[3123]||(s[3123]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1249]||(s[1249]=[n("加载因子是 0.75：")])),_:1}),s[3124]||(s[3124]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">static final float DEFAULT_LOAD_FACTOR = 0.75f;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1250]||(s[1250]=[n("也就是说，当 16*0.75=12 时，会触发扩容机制。")])),_:1}),a("p",null,[a("strong",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1251]||(s[1251]=[n("为什么加载因子会选择 0.75 呢？为什么不是 0.8、0.6 呢")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1252]||(s[1252]=[n("？")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1253]||(s[1253]=[n("这跟统计学里的一个很重要的原理——泊松分布有关。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1254]||(s[1254]=[n("是时候上维基百科了：")])),_:1}),l(e,{style:{color:"rgb(102, 102, 102)"}},{default:i(()=>s[1255]||(s[1255]=[n("泊松分布，是一种统计与概率学里常见到的离散概率分布，由法国数学家西莫恩·德尼·泊松在 1838 年时提出。它会对随机事件的发生次数进行建模，适用于涉及计算在给定的时间段、距离、面积等范围内发生随机事件的次数的应用情形。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1256]||(s[1256]=[n("阮一峰老师曾在一篇博文中详细的介绍了泊松分布和指数分布，大家可以去看一下。")])),_:1}),l(e,{style:{color:"rgb(102, 102, 102)"}},{default:i(()=>s[1257]||(s[1257]=[n("链接：")])),_:1}),s[3125]||(s[3125]=n("[")),l(e,{style:{color:"rgb(102, 102, 102)"}},{default:i(()=>s[1258]||(s[1258]=[n("https://www.ruanyifeng.com/blog/2015/06/poisson-distribution.html")])),_:1}),s[3126]||(s[3126]=n("](https://www.ruanyifeng.com/blog/2015/06/poisson-distribution.html)")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1259]||(s[1259]=[n("具体是用这么一个公式来表示的。")])),_:1}),s[3127]||(s[3127]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726668350984-686eaaca-54f5-441b-9c05-42157d04ed3f.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1260]||(s[1260]=[n("等号的左边，P 表示概率，N 表示某种函数关系，t 表示时间，n 表示数量。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1261]||(s[1261]=[n("在 HashMap 的 doc 文档里，曾有这么一段描述：")])),_:1}),s[3128]||(s[3128]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">Because TreeNodes are about twice the size of regular nodes, we</span>
<span class="line">use them only when bins contain enough nodes to warrant use</span>
<span class="line">(see TREEIFY_THRESHOLD). And when they become too small (due to</span>
<span class="line">removal or resizing) they are converted back to plain bins.  In</span>
<span class="line">usages with well-distributed user hashCodes, tree bins are</span>
<span class="line">rarely used.  Ideally, under random hashCodes, the frequency of</span>
<span class="line">nodes in bins follows a Poisson distribution</span>
<span class="line">(http://en.wikipedia.org/wiki/Poisson_distribution) with a</span>
<span class="line">parameter of about 0.5 on average for the default resizing</span>
<span class="line">threshold of 0.75, although with a large variance because of</span>
<span class="line">resizing granularity. Ignoring variance, the expected</span>
<span class="line">occurrences of list size k are (exp(-0.5) * pow(0.5, k) /</span>
<span class="line">factorial(k)). The first values are:</span>
<span class="line">0:    0.60653066</span>
<span class="line">1:    0.30326533</span>
<span class="line">2:    0.07581633</span>
<span class="line">3:    0.01263606</span>
<span class="line">4:    0.00157952</span>
<span class="line">5:    0.00015795</span>
<span class="line">6:    0.00001316</span>
<span class="line">7:    0.00000094</span>
<span class="line">8:    0.00000006</span>
<span class="line">more: less than 1 in ten million</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1262]||(s[1262]=[n("为了便于大家的理解，这里来重温一下 HashMap 的拉链法和红黑树结构。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1263]||(s[1263]=[n("Java 8 之前，HashMap 使用链表来解决冲突，即当两个或者多个键映射到同一个桶时，它们被放在同一个桶的链表上。当链表上的节点（Node）过多时，链表会变得很长，查找的效率（")])),_:1}),s[3129]||(s[3129]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1264]||(s[1264]=[n("LinkedList")])),_:1}),s[3130]||(s[3130]=n("](https://javabebetter.cn/collection/linkedlist.html)")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1265]||(s[1265]=[n("的查找效率为 O（n））就会受到影响。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1266]||(s[1266]=[n("Java 8 中，当链表的节点数超过一个阈值（8）时，链表将转为红黑树（节点为 TreeNode），红黑树（在讲")])),_:1}),s[3131]||(s[3131]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1267]||(s[1267]=[n("TreeMap")])),_:1}),s[3132]||(s[3132]=n("](https://javabebetter.cn/collection/treemap.html)")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1268]||(s[1268]=[n("时会细说）是一种高效的平衡树结构，能够在 O(log n) 的时间内完成插入、删除和查找等操作。这种结构在节点数很多时，可以提高 HashMap 的性能和可伸缩性。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1269]||(s[1269]=[n("好，有了这个背景，我们来把上面的 doc 文档翻译为中文：")])),_:1}),s[3133]||(s[3133]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">因为TreeNode（红黑树的节点）的大小大约是常规节点（链表的节点 Node）的两倍，所以只有当桶内包含足够多的节点时才使用红黑树（参见TREEIFY_THRESHOLD「阈值，值为8」，节点数量较多时，红黑树可以提高查询效率）。</span>
<span class="line"></span>
<span class="line">由于删除元素或者调整数组大小（扩容）时（再次散列），红黑树可能会被转换为链表（节点数量小于 8 时），节点数量较少时，链表的效率比红黑树更高，因为红黑树需要更多的内存空间来存储节点。</span>
<span class="line"></span>
<span class="line">在具有良好分布的hashCode使用中，很少使用红黑树。</span>
<span class="line"></span>
<span class="line">理想情况下，在随机hashCode下，节点在桶中的频率遵循泊松分布（https://zh.wikipedia.org/wiki/卜瓦松分布），平均缩放阈值为0.75，忽略方差，列表大小k的预期出现次数为（exp（-0.5）* pow（0.5，k）/ factorial（k））。</span>
<span class="line"></span>
<span class="line">前几个值是：</span>
<span class="line">0: 0.60653066</span>
<span class="line">1: 0.30326533</span>
<span class="line">2: 0.07581633</span>
<span class="line">3: 0.01263606</span>
<span class="line">4: 0.00157952</span>
<span class="line">5: 0.00015795</span>
<span class="line">6: 0.00001316</span>
<span class="line">7: 0.00000094</span>
<span class="line">8: 0.00000006</span>
<span class="line"></span>
<span class="line">更多：小于一千万分之一</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1270]||(s[1270]=[n("虽然这段话的本意更多的是表示 jdk 8 中为什么拉链长度超过 8 的时候进行了红黑树转换，但提到了 0.75 这个加载因子，但没提到底为什么。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1271]||(s[1271]=[n("为了搞清楚到底为什么，我看到了这篇文章：")])),_:1}),l(e,{style:{color:"rgb(102, 102, 102)"}},{default:i(()=>s[1272]||(s[1272]=[n("参考链接：")])),_:1}),s[3134]||(s[3134]=n("[")),l(e,{style:{color:"rgb(102, 102, 102)"}},{default:i(()=>s[1273]||(s[1273]=[n("https://segmentfault.com/a/1190000023308658")])),_:1}),s[3135]||(s[3135]=n("](https://segmentfault.com/a/1190000023308658)")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1274]||(s[1274]=[n("里面提到了一个概念：")])),_:1}),s[3136]||(s[3136]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1275]||(s[1275]=[n("二项分布（Binomial Distribution）")])),_:1}),s[3137]||(s[3137]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1276]||(s[1276]=[n("。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1277]||(s[1277]=[n("在做一件事情的时候，其结果的概率只有 2 种情况，和抛硬币一样，不是正面就是反面。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1278]||(s[1278]=[n("假如，我们做了 N 次实验，那么在每次试验中只有两种可能的结果，并且每次实验是独立的，不同实验之间互不影响，每次实验成功的概率都是一样的。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1279]||(s[1279]=[n("以此理论为基础：我们往哈希表中扔数据，如果发生哈希冲突就为失败，否则为成功。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1280]||(s[1280]=[n("我们可以设想，实验的 hash 值是随机的，并且经过 hash 运算的键都会映射到 hash 表的地址空间上，那么这个结果也是随机的。所以，每次 put 的时候就相当于我们在扔一个 16 面（HashMap 第一次扩容后的数组默认长度为 16）的骰子，扔骰子实验那肯定是相互独立的。碰撞发生即扔了 n 次有出现重复数字。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1281]||(s[1281]=[n("然后，我们的目的是啥呢？")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1282]||(s[1282]=[n("就是掷了 k 次骰子，没有一次是相同的概率，需要尽可能的大些，一般意义上我们肯定要大于 0.5（这个数是个理想数）。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1283]||(s[1283]=[n("于是，n 次事件里面，碰撞为 0 的概率，由上面公式得：")])),_:1}),s[3138]||(s[3138]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726668350737-c1a96ffe-d119-4626-b732-d8707fae93ec.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1284]||(s[1284]=[n("这个概率值需要大于 0.5，我们认为这样的 hashmap 可以提供很低的碰撞率。所以：")])),_:1}),s[3139]||(s[3139]=a("img",{referrerpolicy:"no-referrer",src:""},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1285]||(s[1285]=[n("这时候，我们对于该公式其实最想求的时候长度 s 的时候，n 为多少次就应该进行扩容了？而负载因子则是$n/s$的值。所以推导如下：")])),_:1}),s[3140]||(s[3140]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726668349151-e0063cca-3b2d-4152-81d2-7d86416d1895.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1286]||(s[1286]=[n("所以可以得到")])),_:1}),s[3141]||(s[3141]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726668350765-6d844351-468c-4081-965c-43fc05f30686.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1287]||(s[1287]=[n("其中")])),_:1}),s[3142]||(s[3142]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726668350735-2244d036-7a45-4b1d-8edd-95617248bab9.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1288]||(s[1288]=[n("这就是一个求")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3143]||(s[3143]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1289]||(s[1289]=[n("∞⋅0")])),_:1}),s[3144]||(s[3144]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1290]||(s[1290]=[n("函数极限问题，这里我们先令$s = m+1（m \\to \\infty）$则转化为")])),_:1}),s[3145]||(s[3145]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726668351015-e91c42f7-b499-46e8-970e-a76ae872ee15.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1291]||(s[1291]=[n("我们再令 $x = \\frac{1}{m} （x \\to 0）$ 则有，")])),_:1}),s[3146]||(s[3146]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726668351224-a3d5f152-b32d-4d1a-88e9-79f5bda9f0ef.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1292]||(s[1292]=[n("所以")])),_:1}),s[3147]||(s[3147]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726668351278-e6e8b168-f7c0-4828-8176-73ed5ac69e0d.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1293]||(s[1293]=[n("考虑到 HashMap 的容量有一个要求：它必须是 2 的 n 次幂。当加载因子选择了 0.75 就可以保证它与容量的乘积为整数。")])),_:1}),s[3148]||(s[3148]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">16*0.75=12</span>
<span class="line">32*0.75=24</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1294]||(s[1294]=[n("除了 0.75，0.5~1 之间还有 0.625（5/8）、0.875（7/8）可选，从中位数的角度，挑 0.75 比较完美。另外，维基百科上说，拉链法（解决哈希冲突的一种）的加载因子最好限制在 0.7-0.8 以下，超过 0.8，查表时的 CPU 缓存不命中（cache missing）会按照指数曲线上升。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1295]||(s[1295]=[n("综上，0.75 是个比较完美的选择。")])),_:1}),a("h4",xn,[a("a",Ln,[a("span",null,[a("a",Mn,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1296]||(s[1296]=[n("小结")])),_:1}),l(r)])])])]),a("p",null,[a("strong",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1297]||(s[1297]=[n("HashMap 的加载因子（load factor，直译为加载因子，意译为负载因子）是指哈希表中填充元素的个数与桶的数量的比值，当元素个数达到负载因子与桶的数量的乘积时，就需要进行扩容。这个值一般选择 0.75，是因为这个值可以在时间和空间成本之间做到一个折中，使得哈希表的性能达到较好的表现")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1298]||(s[1298]=[n("。")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1299]||(s[1299]=[n("如果负载因子过大，填充因子较多，那么哈希表中的元素就会越来越多地聚集在少数的桶中，这就导致了冲突的增加，这些冲突会导致查找、插入和删除操作的效率下降。同时，这也会导致需要更频繁地进行扩容，进一步降低了性能。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1300]||(s[1300]=[n("如果负载因子过小，那么桶的数量会很多，虽然可以减少冲突，但是在空间利用上面也会有浪费，因此选择 0.75 是为了取得一个平衡点，即在时间和空间成本之间取得一个比较好的平衡点。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1301]||(s[1301]=[n("总之，选择 0.75 这个值是为了在时间和空间成本之间达到一个较好的平衡点，既可以保证哈希表的性能表现，又能够充分利用空间。")])),_:1}),a("h3",wn,[a("a",Cn,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1302]||(s[1302]=[n("线程不安全")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1303]||(s[1303]=[n("其实这个问题也不用说太多，但考虑到面试的时候有些面试官会问，那就简单说一下。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1304]||(s[1304]=[n("三方面原因：")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1305]||(s[1305]=[n("多线程下扩容会死循环")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1306]||(s[1306]=[n("多线程下 put 会导致元素丢失")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1307]||(s[1307]=[n("put 和 get 并发时会导致 get 到 null")])),_:1})])]),a("h4",Sn,[a("a",An,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1308]||(s[1308]=[n("多线程下扩容会死循环")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1309]||(s[1309]=[n("众所周知，HashMap 是通过拉链法来解决哈希冲突的，也就是当哈希冲突时，会将相同哈希值的键值对通过链表的形式存放起来。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1310]||(s[1310]=[n("JDK 7 时，采用的是头部插入的方式来存放链表的，也就是下一个冲突的键值对会放在上一个键值对的前面（讲扩容的时候讲过了）。扩容的时候就有可能导致出现环形链表，造成死循环。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1311]||(s[1311]=[n("resize 方法的源码：")])),_:1}),s[3149]||(s[3149]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">// newCapacity为新的容量</span>
<span class="line">void resize(int newCapacity) {</span>
<span class="line">    // 小数组，临时过度下</span>
<span class="line">    Entry[] oldTable = table;</span>
<span class="line">    // 扩容前的容量</span>
<span class="line">    int oldCapacity = oldTable.length;</span>
<span class="line">    // MAXIMUM_CAPACITY 为最大容量，2 的 30 次方 = 1&lt;&lt;30</span>
<span class="line">    if (oldCapacity == MAXIMUM_CAPACITY) {</span>
<span class="line">        // 容量调整为 Integer 的最大值 0x7fffffff（十六进制）=2 的 31 次方-1</span>
<span class="line">        threshold = Integer.MAX_VALUE;</span>
<span class="line">        return;</span>
<span class="line">    }</span>
<span class="line"></span>
<span class="line">    // 初始化一个新的数组（大容量）</span>
<span class="line">    Entry[] newTable = new Entry[newCapacity];</span>
<span class="line">    // 把小数组的元素转移到大数组中</span>
<span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span>
<span class="line">    // 引用新的大数组</span>
<span class="line">    table = newTable;</span>
<span class="line">    // 重新计算阈值</span>
<span class="line">    threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1312]||(s[1312]=[n("transfer 方法用来转移，将小数组的元素拷贝到新的数组中。")])),_:1}),s[3150]||(s[3150]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">void transfer(Entry[] newTable, boolean rehash) {</span>
<span class="line">    // 新的容量</span>
<span class="line">    int newCapacity = newTable.length;</span>
<span class="line">    // 遍历小数组</span>
<span class="line">    for (Entry&lt;K,V&gt; e : table) {</span>
<span class="line">        while(null != e) {</span>
<span class="line">            // 拉链法，相同 key 上的不同值</span>
<span class="line">            Entry&lt;K,V&gt; next = e.next;</span>
<span class="line">            // 是否需要重新计算 hash</span>
<span class="line">            if (rehash) {</span>
<span class="line">                e.hash = null == e.key ? 0 : hash(e.key);</span>
<span class="line">            }</span>
<span class="line">            // 根据大数组的容量，和键的 hash 计算元素在数组中的下标</span>
<span class="line">            int i = indexFor(e.hash, newCapacity);</span>
<span class="line"></span>
<span class="line">            // 同一位置上的新元素被放在链表的头部</span>
<span class="line">            e.next = newTable[i];</span>
<span class="line"></span>
<span class="line">            // 放在新的数组上</span>
<span class="line">            newTable[i] = e;</span>
<span class="line"></span>
<span class="line">            // 链表上的下一个元素</span>
<span class="line">            e = next;</span>
<span class="line">        }</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1313]||(s[1313]=[n("注意")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3151]||(s[3151]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1314]||(s[1314]=[n("e.next = newTable[i]")])),_:1}),s[3152]||(s[3152]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1315]||(s[1315]=[n("和")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3153]||(s[3153]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1316]||(s[1316]=[n("newTable[i] = e")])),_:1}),s[3154]||(s[3154]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1317]||(s[1317]=[n("这两行代码，就会将同一位置上的新元素被放在链表的头部。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1318]||(s[1318]=[n("扩容前的样子假如是下面这样子。")])),_:1}),s[3155]||(s[3155]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726668351269-ec1f9beb-ea4f-408b-a65f-64b701e1d2e5.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1319]||(s[1319]=[n("那么正常扩容后就是下面这样子。")])),_:1}),s[3156]||(s[3156]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726668352480-1da760d4-956f-47b4-918e-6be55e93e318.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1320]||(s[1320]=[n("假设现在有两个线程同时进行扩容，线程 A 在执行到")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3157]||(s[3157]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1321]||(s[1321]=[n("newTable[i] = e;")])),_:1}),s[3158]||(s[3158]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1322]||(s[1322]=[n("被挂起，此时线程 A 中：e=3、next=7、e.next=null")])),_:1}),s[3159]||(s[3159]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726668352473-19e6d34f-17ae-438e-8023-1da06599b29e.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1323]||(s[1323]=[n("线程 B 开始执行，并且完成了数据转移。")])),_:1}),s[3160]||(s[3160]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726668352414-03ada39d-d1d7-4f62-9c60-53d3a2b64138.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1324]||(s[1324]=[n("此时，7 的 next 为 3，3 的 next 为 null。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1325]||(s[1325]=[n("随后线程 A 获得 CPU 时间片继续执行")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3161]||(s[3161]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1326]||(s[1326]=[n("newTable[i] = e")])),_:1}),s[3162]||(s[3162]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1327]||(s[1327]=[n("，将 3 放入新数组对应的位置，执行完此轮循环后线程 A 的情况如下：")])),_:1}),s[3163]||(s[3163]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726668352422-7a192a16-4888-4a58-9bf6-01403aecdbd7.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1328]||(s[1328]=[n("执行下一轮循环，此时 e=7，原本线程 A 中 7 的 next 为 5，但由于 table 是线程 A 和线程 B 共享的，而线程 B 顺利执行完后，7 的 next 变成了 3，那么此时线程 A 中，7 的 next 也为 3 了。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1329]||(s[1329]=[n("采用头部插入的方式，变成了下面这样子：")])),_:1}),s[3164]||(s[3164]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726668352427-3cc4b546-4c9b-4890-9e9d-6bc7ae01a435.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1330]||(s[1330]=[n("好像也没什么问题，此时 next = 3，e = 3。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1331]||(s[1331]=[n("进行下一轮循环，但此时，由于线程 B 将 3 的 next 变为了 null，所以此轮循环应该是最后一轮了。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1332]||(s[1332]=[n("接下来当执行完")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3165]||(s[3165]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1333]||(s[1333]=[n("e.next=newTable[i]")])),_:1}),s[3166]||(s[3166]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1334]||(s[1334]=[n("即 3.next=7 后，3 和 7 之间就相互链接了，执行完")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3167]||(s[3167]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1335]||(s[1335]=[n("newTable[i]=e")])),_:1}),s[3168]||(s[3168]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1336]||(s[1336]=[n("后，3 被头插法重新插入到链表中，执行结果如下图所示：")])),_:1}),s[3169]||(s[3169]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726668353534-3109b309-dcda-4b22-b165-ca35f531f5bf.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1337]||(s[1337]=[n("套娃开始，元素 5 也就成了弃婴，惨~~~")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1338]||(s[1338]=[n("不过，JDK 8 时已经修复了这个问题，扩容时会保持链表原来的顺序（嗯，等于说了半天白说了，哈哈，这个面试题确实是这样，很水，但有些面试官又确实比较装逼）。")])),_:1}),a("h4",En,[a("a",jn,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1339]||(s[1339]=[n("多线程下 put 会导致元素丢失")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1340]||(s[1340]=[n("正常情况下，当发生哈希冲突时，HashMap 是这样的：")])),_:1}),s[3170]||(s[3170]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726668353540-e3fd38e6-e47f-4d71-b4b3-0b5b92755634.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1341]||(s[1341]=[n("但多线程同时执行 put 操作时，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1342]||(s[1342]=[n("put 的源码：")])),_:1}),s[3171]||(s[3171]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span>
<span class="line">               boolean evict) {</span>
<span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span>
<span class="line"></span>
<span class="line">    // 步骤①：tab为空则创建</span>
<span class="line">    if ((tab = table) == null || (n = tab.length) == 0)</span>
<span class="line">        n = (tab = resize()).length;</span>
<span class="line"></span>
<span class="line">    // 步骤②：计算index，并对null做处理</span>
<span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span>
<span class="line">        tab[i] = newNode(hash, key, value, null);</span>
<span class="line">    else {</span>
<span class="line">        Node&lt;K,V&gt; e; K k;</span>
<span class="line"></span>
<span class="line">        // 步骤③：节点key存在，直接覆盖value</span>
<span class="line">        if (p.hash == hash &amp;&amp;</span>
<span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span>
<span class="line">            e = p;</span>
<span class="line"></span>
<span class="line">        // 步骤④：判断该链为红黑树</span>
<span class="line">        else if (p instanceof TreeNode)</span>
<span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span>
<span class="line"></span>
<span class="line">        // 步骤⑤：该链为链表</span>
<span class="line">        else {</span>
<span class="line">            for (int binCount = 0; ; ++binCount) {</span>
<span class="line">                if ((e = p.next) == null) {</span>
<span class="line">                    p.next = newNode(hash, key, value, null);</span>
<span class="line"></span>
<span class="line">                    //链表长度大于8转换为红黑树进行处理</span>
<span class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span>
<span class="line">                        treeifyBin(tab, hash);</span>
<span class="line">                    break;</span>
<span class="line">                }</span>
<span class="line"></span>
<span class="line">                // key已经存在直接覆盖value</span>
<span class="line">                if (e.hash == hash &amp;&amp;</span>
<span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span>
<span class="line">                    break;</span>
<span class="line">                p = e;</span>
<span class="line">            }</span>
<span class="line">        }</span>
<span class="line"></span>
<span class="line">        // 步骤⑥、直接覆盖</span>
<span class="line">        if (e != null) { // existing mapping for key</span>
<span class="line">            V oldValue = e.value;</span>
<span class="line">            if (!onlyIfAbsent || oldValue == null)</span>
<span class="line">                e.value = value;</span>
<span class="line">            afterNodeAccess(e);</span>
<span class="line">            return oldValue;</span>
<span class="line">        }</span>
<span class="line">    }</span>
<span class="line">    ++modCount;</span>
<span class="line"></span>
<span class="line">    // 步骤⑦：超过最大容量 就扩容</span>
<span class="line">    if (++size &gt; threshold)</span>
<span class="line">        resize();</span>
<span class="line">    afterNodeInsertion(evict);</span>
<span class="line">    return null;</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1343]||(s[1343]=[n("问题发生在步骤 ② 这里：")])),_:1}),s[3172]||(s[3172]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">if ((p = tab[i = (n - 1) &amp; hash]) == null)</span>
<span class="line">    tab[i] = newNode(hash, key, value, null);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1344]||(s[1344]=[n("两个线程都执行了 if 语句，假设线程 A 先执行了")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3173]||(s[3173]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1345]||(s[1345]=[n("tab[i] = newNode(hash, key, value, null)")])),_:1}),s[3174]||(s[3174]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1346]||(s[1346]=[n("，那 table 是这样的：")])),_:1}),s[3175]||(s[3175]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726668353545-44ee78b3-7c0a-4353-b63f-912ab1b9eddc.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1347]||(s[1347]=[n("接着，线程 B 执行了")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3176]||(s[3176]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1348]||(s[1348]=[n("tab[i] = newNode(hash, key, value, null)")])),_:1}),s[3177]||(s[3177]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1349]||(s[1349]=[n("，那 table 是这样的：")])),_:1}),s[3178]||(s[3178]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726668353540-173fd000-14f1-402b-bf66-5771a11320c3.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1350]||(s[1350]=[n("3 被干掉了。")])),_:1}),a("h4",In,[a("a",Hn,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1351]||(s[1351]=[n("put 和 get 并发时会导致 get 到 null")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1352]||(s[1352]=[n("线程 1 执行 put 时，因为元素个数超出阈值而导致出现扩容，线程 2 此时执行 get，就有可能出现这个问题。")])),_:1}),s[3179]||(s[3179]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726668355421-ab4a229a-f89f-41e2-bb6f-c14c9a1704fd.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1353]||(s[1353]=[n("因为线程 1 执行完 table = newTab 之后，线程 2 中的 table 此时也发生了变化，此时去 get 的时候当然会 get 到 null 了，因为元素还没有转移。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1354]||(s[1354]=[n("参考链接：")])),_:1}),a("ul",null,[a("li",null,[a("a",Tn,[l(e,{style:{color:"rgb(102, 102, 102)"}},{default:i(()=>s[1355]||(s[1355]=[n("https://blog.csdn.net/lonyw/article/details/80519652")])),_:1}),l(r)])]),a("li",null,[a("a",Dn,[l(e,{style:{color:"rgb(102, 102, 102)"}},{default:i(()=>s[1356]||(s[1356]=[n("https://zhuanlan.zhihu.com/p/91636401")])),_:1}),l(r)])]),a("li",null,[a("a",Nn,[l(e,{style:{color:"rgb(102, 102, 102)"}},{default:i(()=>s[1357]||(s[1357]=[n("https://www.zhihu.com/question/20733617")])),_:1}),l(r)])]),a("li",null,[a("a",On,[l(e,{style:{color:"rgb(102, 102, 102)"}},{default:i(()=>s[1358]||(s[1358]=[n("https://zhuanlan.zhihu.com/p/21673805")])),_:1}),l(r)])])]),a("h4",zn,[a("a",Vn,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1359]||(s[1359]=[n("小结")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1360]||(s[1360]=[n("HashMap 是线程不安全的主要是因为它在进行插入、删除和扩容等操作时可能会导致链表的结构发生变化，从而破坏了 HashMap 的不变性。具体来说，如果在一个线程正在遍历 HashMap 的链表时，另外一个线程对该链表进行了修改（比如添加了一个节点），那么就会导致链表的结构发生变化，从而破坏了当前线程正在进行的遍历操作，可能导致遍历失败或者出现死循环等问题。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1361]||(s[1361]=[n("为了解决这个问题，Java 提供了线程安全的 HashMap 实现类")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3180]||(s[3180]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1362]||(s[1362]=[n("ConcurrentHashMap")])),_:1}),s[3181]||(s[3181]=n("](https://javabebetter.cn/thread/ConcurrentHashMap.html)")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1363]||(s[1363]=[n("。ConcurrentHashMap 内部采用了分段锁（Segment），将整个 Map 拆分为多个小的 HashMap，每个小的 HashMap 都有自己的锁，不同的线程可以同时访问不同的小 Map，从而实现了线程安全。在进行插入、删除和扩容等操作时，只需要锁住当前小 Map，不会对整个 Map 进行锁定，提高了并发访问的效率。")])),_:1}),a("h3",Pn,[a("a",Fn,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1364]||(s[1364]=[n("小结")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1365]||(s[1365]=[n("HashMap 是 Java 中最常用的集合之一，它是一种键值对存储的数据结构，可以根据键来快速访问对应的值。以下是对 HashMap 的总结：")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1366]||(s[1366]=[n("HashMap 采用数组+链表/红黑树的存储结构，能够在 O(1)的时间复杂度内实现元素的添加、删除、查找等操作。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1367]||(s[1367]=[n("HashMap 是线程不安全的，因此在多线程环境下需要使用")])),_:1}),s[1370]||(s[1370]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1368]||(s[1368]=[n("ConcurrentHashMap")])),_:1}),s[1371]||(s[1371]=n("](https://javabebetter.cn/thread/ConcurrentHashMap.html)")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1369]||(s[1369]=[n("来保证线程安全。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1372]||(s[1372]=[n("HashMap 的扩容机制是通过扩大数组容量和重新计算 hash 值来实现的，扩容时需要重新计算所有元素的 hash 值，因此在元素较多时扩容会影响性能。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1373]||(s[1373]=[n("在 Java 8 中，HashMap 的实现引入了拉链法、树化等机制来优化大量元素存储的情况，进一步提升了性能。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1374]||(s[1374]=[n("HashMap 中的 key 是唯一的，如果要存储重复的 key，则后面的值会覆盖前面的值。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1375]||(s[1375]=[n("HashMap 的初始容量和加载因子都可以设置，初始容量表示数组的初始大小，加载因子表示数组的填充因子。一般情况下，初始容量为 16，加载因子为 0.75。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1376]||(s[1376]=[n("HashMap 在遍历时是无序的，因此如果需要有序遍历，可以使用")])),_:1}),s[1379]||(s[1379]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1377]||(s[1377]=[n("TreeMap")])),_:1}),s[1380]||(s[1380]=n("](https://javabebetter.cn/collection/treemap.html)")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1378]||(s[1378]=[n("。")])),_:1})])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1381]||(s[1381]=[n("综上所述，HashMap 是一种高效的数据结构，具有快速查找和插入元素的能力，但需要注意线程安全和性能问题。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1382]||(s[1382]=[n("那如果大家已经掌握了 HashMap，那可以刷一下 LeetCode 的第 001 题、013 题，会用到 HashMap、数组和 for 循环，我把题解链接放在了技术派上：")])),_:1}),a("ul",null,[a("li",null,[a("a",Kn,[l(e,{style:{color:"rgb(102, 102, 102)"}},{default:i(()=>s[1383]||(s[1383]=[n("二哥的 LeetCode 刷题笔记：001.两数之和")])),_:1}),l(r)])]),a("li",null,[a("a",Rn,[l(e,{style:{color:"rgb(102, 102, 102)"}},{default:i(()=>s[1384]||(s[1384]=[n("二哥的 LeetCode 刷题笔记：013.罗马数字转整数")])),_:1}),l(r)])])]),l(e,{style:{color:"rgb(102, 102, 102)"}}),s[3182]||(s[3182]=a("h2",{id:"linkedhashmap-详解",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#linkedhashmap-详解"},[a("span",null,"LinkedHashMap 详解")])],-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1385]||(s[1385]=[n("俗话说了，“金无足赤人无完人”，HashMap 也不例外，有一种需求它就满足不了，假如我们需要一个按照插入顺序来排列的键值对集合，那 HashMap 就无能为力了。那该怎么办呢？必须得上今天这篇文章的主角：LinkedHashMap。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1386]||(s[1386]=[n("同学们好啊，还记得")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3183]||(s[3183]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1387]||(s[1387]=[n("HashMap")])),_:1}),s[3184]||(s[3184]=n("](https://javabetter.cn/collection/hashmap.html)")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1388]||(s[1388]=[n("那篇吗？我自己感觉写得非常棒啊，既通俗易懂，又深入源码，真的是分析得透透彻彻、清清楚楚、明明白白的。（一不小心又甩了三个成语，有文化吧？）HashMap 哪哪都好，真的，只要你想用键值对，第一时间就应该想到它。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1389]||(s[1389]=[n("为了提高查找效率，HashMap 在插入的时候对键做了一次哈希算法，这就导致插入的元素是无序的。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1390]||(s[1390]=[n("对这一点还不太明白的同学，可以再回到")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3185]||(s[3185]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1391]||(s[1391]=[n("HashMap")])),_:1}),s[3186]||(s[3186]=n("](https://javabetter.cn/collection/hashmap.html)")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1392]||(s[1392]=[n("那一篇，看看 hash 方法，再看看我对")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3187]||(s[3187]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1393]||(s[1393]=[n("put()")])),_:1}),s[3188]||(s[3188]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1394]||(s[1394]=[n("方法的讲解，就能明白了，我们这里再来回顾一下。")])),_:1}),s[3189]||(s[3189]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span>
<span class="line"></span>
<span class="line">               boolean evict) {</span>
<span class="line">    HashMap.Node&lt;K,V&gt;[] tab; HashMap.Node&lt;K,V&gt; p; int n, i;</span>
<span class="line">    // ①、数组 table 为 null 时，调用 resize 方法创建默认大小的数组</span>
<span class="line">    if ((tab = table) == null || (n = tab.length) == 0)</span>
<span class="line">        n = (tab = resize()).length;</span>
<span class="line">    // ②、计算下标，如果该位置上没有值，则填充</span>
<span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span>
<span class="line">        tab[i] = newNode(hash, key, value, null);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1395]||(s[1395]=[n("其中这个公式")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3190]||(s[3190]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1396]||(s[1396]=[n("i = (n - 1) & hash")])),_:1}),s[3191]||(s[3191]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1397]||(s[1397]=[n("计算后的值就是键位在数组（桶）中的索引（下标/位置），但这它并不是按照 0、1、2、3、4、5 这样有序的下标将键值对插入到数组当中的，而是有一定的随机性。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1398]||(s[1398]=[n("比如说默认大小为 16 的 HashMap，如果 put 了 4 个键值对，可能下标是 0、4、9、11，那这样的话，在遍历 HashMap 的时候，就不一定能按照插入顺序来了。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1399]||(s[1399]=[n("看下面的例子。")])),_:1}),s[3192]||(s[3192]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">// 创建 HashMap 对象，键类型为 String，值类型为 String</span>
<span class="line">Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span>
<span class="line"></span>
<span class="line">// 使用 put() 方法向 HashMap 中添加数据</span>
<span class="line">map.put(&quot;chenmo&quot;, &quot;沉默&quot;);</span>
<span class="line">map.put(&quot;wanger&quot;, &quot;王二&quot;);</span>
<span class="line">map.put(&quot;chenqingyang&quot;, &quot;陈清扬&quot;);</span>
<span class="line"></span>
<span class="line">// 遍历 HashMap，输出所有键值对</span>
<span class="line">for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) {</span>
<span class="line">    String key = entry.getKey();</span>
<span class="line">    String value = entry.getValue();</span>
<span class="line">    System.out.println(&quot;Key: &quot; + key + &quot;, Value: &quot; + value);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1400]||(s[1400]=[n("来看输出结果")])),_:1}),s[3193]||(s[3193]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">Key: chenmo, Value: 沉默</span>
<span class="line">Key: chenqingyang, Value: 陈清扬</span>
<span class="line">Key: wanger, Value: 王二</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1401]||(s[1401]=[n("对比一下输出结果就可以看得出来，put 的时候是 沉默、王二、陈清扬的顺序，但遍历的时候就没有按照这个顺序来：沉默、陈清扬、王二，因为 HashMap 是无序的。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1402]||(s[1402]=[n("那怎么保证键值对的插入顺序呢？")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1403]||(s[1403]=[n("LinkedHashMap 就是为这个需求应运而生的。LinkedHashMap 继承了 HashMap，所以 HashMap 有的关于键值对的功能，它也有了。")])),_:1}),s[3194]||(s[3194]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public class LinkedHashMap&lt;K,V&gt;</span>
<span class="line"></span>
<span class="line">    extends HashMap&lt;K,V&gt;</span>
<span class="line"></span>
<span class="line">    implements Map&lt;K,V&gt;{}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1404]||(s[1404]=[n("在此基础上，LinkedHashMap 内部追加了双向链表，来维护元素的插入顺序。注意下面代码中的 before 和 after，它俩就是用来维护当前元素的前一个元素和后一个元素的顺序的。")])),_:1}),s[3195]||(s[3195]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; {</span>
<span class="line">    Entry&lt;K,V&gt; before, after;</span>
<span class="line">    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) {</span>
<span class="line">        super(hash, key, value, next);</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1405]||(s[1405]=[n("关于双向链表，同学们可以回头看一遍我写的")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3196]||(s[3196]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1406]||(s[1406]=[n("LinkedList")])),_:1}),s[3197]||(s[3197]=n("](https://javabetter.cn/collection/linkedlist.html)")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1407]||(s[1407]=[n("那篇文章，会对理解本篇的 LinkedHashMap 有很大的帮助。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1408]||(s[1408]=[n("用 LinkedHashMap 替换 HashMap，再来对比一下输出结果。")])),_:1}),s[3198]||(s[3198]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">// 创建 LinkedHashMap 对象，键类型为 String，值类型为 String</span>
<span class="line">Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;();</span>
<span class="line"></span>
<span class="line">// 使用 put() 方法向 LinkedHashMap 中添加数据</span>
<span class="line">map.put(&quot;chenmo&quot;, &quot;沉默&quot;);</span>
<span class="line">map.put(&quot;wanger&quot;, &quot;王二&quot;);</span>
<span class="line">map.put(&quot;chenqingyang&quot;, &quot;陈清扬&quot;);</span>
<span class="line"></span>
<span class="line">// 遍历 LinkedHashMap，输出所有键值对</span>
<span class="line">for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) {</span>
<span class="line">    String key = entry.getKey();</span>
<span class="line">    String value = entry.getValue();</span>
<span class="line">    System.out.println(&quot;Key: &quot; + key + &quot;, Value: &quot; + value);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1409]||(s[1409]=[n("来看输出结果：")])),_:1}),s[3199]||(s[3199]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">Key: chenmo, Value: 沉默</span>
<span class="line">Key: wanger, Value: 王二</span>
<span class="line">Key: chenqingyang, Value: 陈清扬</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1410]||(s[1410]=[n("看，LinkedHashMap 是不是保持了插入顺序？这就对了。")])),_:1}),a("h3",Bn,[a("a",Qn,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1411]||(s[1411]=[n("插入顺序")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1412]||(s[1412]=[n("在")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3200]||(s[3200]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1413]||(s[1413]=[n("HashMap")])),_:1}),s[3201]||(s[3201]=n("](https://javabetter.cn/collection/hashmap.html)")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1414]||(s[1414]=[n("那篇文章里，我有讲解到一点，不知道同学们记不记得，就是 null 会插入到 HashMap 的第一位。")])),_:1}),s[3202]||(s[3202]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">Map&lt;String, String&gt; hashMap = new HashMap&lt;&gt;();</span>
<span class="line">hashMap.put(&quot;沉&quot;, &quot;沉默王二&quot;);</span>
<span class="line">hashMap.put(&quot;默&quot;, &quot;沉默王二&quot;);</span>
<span class="line">hashMap.put(&quot;王&quot;, &quot;沉默王二&quot;);</span>
<span class="line">hashMap.put(&quot;二&quot;, &quot;沉默王二&quot;);</span>
<span class="line">hashMap.put(null, null);</span>
<span class="line"></span>
<span class="line">for (String key : hashMap.keySet()) {</span>
<span class="line">    System.out.println(key + &quot; : &quot; + hashMap.get(key));</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1415]||(s[1415]=[n("输出的结果是：")])),_:1}),s[3203]||(s[3203]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">null : null</span>
<span class="line">默 : 沉默王二</span>
<span class="line">沉 : 沉默王二</span>
<span class="line">王 : 沉默王二</span>
<span class="line">二 : 沉默王二</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1416]||(s[1416]=[n("虽然 null 最后一位 put 进去的，但在遍历输出的时候，跑到了第一位。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1417]||(s[1417]=[n("那再来对比看一下 LinkedHashMap。")])),_:1}),s[3204]||(s[3204]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">Map&lt;String, String&gt; linkedHashMap = new LinkedHashMap&lt;&gt;();</span>
<span class="line">linkedHashMap.put(&quot;沉&quot;, &quot;沉默王二&quot;);</span>
<span class="line">linkedHashMap.put(&quot;默&quot;, &quot;沉默王二&quot;);</span>
<span class="line">linkedHashMap.put(&quot;王&quot;, &quot;沉默王二&quot;);</span>
<span class="line">linkedHashMap.put(&quot;二&quot;, &quot;沉默王二&quot;);</span>
<span class="line">linkedHashMap.put(null, null);</span>
<span class="line"></span>
<span class="line">for (String key : linkedHashMap.keySet()) {</span>
<span class="line">    System.out.println(key + &quot; : &quot; + linkedHashMap.get(key));</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1418]||(s[1418]=[n("输出结果是：")])),_:1}),s[3205]||(s[3205]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">沉 : 沉默王二</span>
<span class="line">默 : 沉默王二</span>
<span class="line">王 : 沉默王二</span>
<span class="line">二 : 沉默王二</span>
<span class="line">null : null</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1419]||(s[1419]=[n("null 在最后一位插入，在最后一位输出。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1420]||(s[1420]=[n("输出结果可以再次证明，")])),_:1}),s[3206]||(s[3206]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1421]||(s[1421]=[n("HashMap 是无序的，LinkedHashMap 是可以维持插入顺序的")])),_:1}),s[3207]||(s[3207]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1422]||(s[1422]=[n("。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1423]||(s[1423]=[n("那 LinkedHashMap 是如何做到这一点呢？我相信同学们和我一样，非常希望知道原因。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1424]||(s[1424]=[n("要想搞清楚，就需要深入研究一下 LinkedHashMap 的源码。LinkedHashMap 并未重写 HashMap 的")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3208]||(s[3208]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1425]||(s[1425]=[n("put()")])),_:1}),s[3209]||(s[3209]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1426]||(s[1426]=[n("方法，而是重写了")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3210]||(s[3210]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1427]||(s[1427]=[n("put()")])),_:1}),s[3211]||(s[3211]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1428]||(s[1428]=[n("方法需要调用的内部方法")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3212]||(s[3212]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1429]||(s[1429]=[n("newNode()")])),_:1}),s[3213]||(s[3213]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1430]||(s[1430]=[n("。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1431]||(s[1431]=[n("这是 HashMap 的。")])),_:1}),s[3214]||(s[3214]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) {</span>
<span class="line">    return new Node&lt;&gt;(hash, key, value, next);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1432]||(s[1432]=[n("这是 LinkedHashMap 的。")])),_:1}),s[3215]||(s[3215]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">HashMap.Node&lt;K,V&gt; newNode(int hash, K key, V value, HashMap.Node&lt;K,V&gt; e) {</span>
<span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span>
<span class="line">            new LinkedHashMap.Entry&lt;&gt;(hash, key, value, e);</span>
<span class="line">    linkNodeLast(p);</span>
<span class="line">    return p;</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1433]||(s[1433]=[n("前面曾提到 LinkedHashMap.Entry 继承了 HashMap.Node，并且追加了两个字段 before 和 after，用来维持键值对的关系。")])),_:1}),s[3216]||(s[3216]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; {</span>
<span class="line">    Entry&lt;K,V&gt; before, after;</span>
<span class="line">    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) {</span>
<span class="line">        super(hash, key, value, next);</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1434]||(s[1434]=[n("在 LinkedHashMap 中，链表中的节点顺序是按照插入顺序维护的。当使用 put() 方法向 LinkedHashMap 中添加键值对时，会将新节点插入到链表的尾部，并更新 before 和 after 属性，以保证链表的顺序关系——由")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3217]||(s[3217]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1435]||(s[1435]=[n("linkNodeLast()")])),_:1}),s[3218]||(s[3218]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1436]||(s[1436]=[n("方法来完成：")])),_:1}),s[3219]||(s[3219]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">/**</span>
<span class="line"> * 将指定节点插入到链表的尾部</span>
<span class="line"> *</span>
<span class="line"> * @param p 要插入的节点</span>
<span class="line"> */</span>
<span class="line">private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) {</span>
<span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail; // 获取链表的尾节点</span>
<span class="line">    tail = p; // 将 p 设为尾节点</span>
<span class="line">    if (last == null)</span>
<span class="line">        head = p; // 如果链表为空，则将 p 设为头节点</span>
<span class="line">    else {</span>
<span class="line">        p.before = last; // 将 p 的前驱节点设为链表的尾节点</span>
<span class="line">        last.after = p; // 将链表的尾节点的后继节点设为 p</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1437]||(s[1437]=[n("看到了吧，LinkedHashMap 在添加第一个元素的时候，会把 head 赋值为第一个元素，等到第二个元素添加进来的时候，会把第二个元素的 before 赋值为第一个元素，第一个元素的 afer 赋值为第二个元素。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1438]||(s[1438]=[n("这就保证了键值对是按照插入顺序排列的，明白了吧？")])),_:1}),a("h3",Un,[a("a",Jn,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1439]||(s[1439]=[n("访问顺序")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1440]||(s[1440]=[n("LinkedHashMap 不仅能够维持插入顺序，还能够维持访问顺序。访问包括调用")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3220]||(s[3220]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1441]||(s[1441]=[n("get()")])),_:1}),s[3221]||(s[3221]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1442]||(s[1442]=[n("方法、")])),_:1}),s[3222]||(s[3222]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1443]||(s[1443]=[n("remove()")])),_:1}),s[3223]||(s[3223]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1444]||(s[1444]=[n("方法和")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3224]||(s[3224]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1445]||(s[1445]=[n("put()")])),_:1}),s[3225]||(s[3225]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1446]||(s[1446]=[n("方法。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1447]||(s[1447]=[n("要维护访问顺序，需要我们在声明 LinkedHashMap 的时候指定三个参数。")])),_:1}),s[3226]||(s[3226]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">LinkedHashMap&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;(16, .75f, true);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1448]||(s[1448]=[n("第一个参数和第二个参数，看过")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3227]||(s[3227]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1449]||(s[1449]=[n("HashMap")])),_:1}),s[3228]||(s[3228]=n("](https://javabetter.cn/collection/hashmap.html)")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1450]||(s[1450]=[n("的同学们应该很熟悉了，指的是初始容量和负载因子。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1451]||(s[1451]=[n("第三个参数如果为 true 的话，就表示 LinkedHashMap 要维护访问顺序；否则，维护插入顺序。默认是 false。")])),_:1}),s[3229]||(s[3229]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">Map&lt;String, String&gt; linkedHashMap = new LinkedHashMap&lt;&gt;(16, .75f, true);</span>
<span class="line">linkedHashMap.put(&quot;沉&quot;, &quot;沉默王二&quot;);</span>
<span class="line">linkedHashMap.put(&quot;默&quot;, &quot;沉默王二&quot;);</span>
<span class="line">linkedHashMap.put(&quot;王&quot;, &quot;沉默王二&quot;);</span>
<span class="line">linkedHashMap.put(&quot;二&quot;, &quot;沉默王二&quot;);</span>
<span class="line"></span>
<span class="line">System.out.println(linkedHashMap);</span>
<span class="line"></span>
<span class="line">linkedHashMap.get(&quot;默&quot;);</span>
<span class="line">System.out.println(linkedHashMap);</span>
<span class="line"></span>
<span class="line">linkedHashMap.get(&quot;王&quot;);</span>
<span class="line">System.out.println(linkedHashMap);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1452]||(s[1452]=[n("输出的结果如下所示：")])),_:1}),s[3230]||(s[3230]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">{沉=沉默王二, 默=沉默王二, 王=沉默王二, 二=沉默王二}</span>
<span class="line">{沉=沉默王二, 王=沉默王二, 二=沉默王二, 默=沉默王二}</span>
<span class="line">{沉=沉默王二, 二=沉默王二, 默=沉默王二, 王=沉默王二}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1453]||(s[1453]=[n("当我们使用")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3231]||(s[3231]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1454]||(s[1454]=[n("get()")])),_:1}),s[3232]||(s[3232]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1455]||(s[1455]=[n("方法访问键位“默”的元素后，输出结果中，")])),_:1}),s[3233]||(s[3233]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1456]||(s[1456]=[n("默=沉默王二")])),_:1}),s[3234]||(s[3234]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1457]||(s[1457]=[n("在最后；当我们访问键位“王”的元素后，输出结果中，")])),_:1}),s[3235]||(s[3235]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1458]||(s[1458]=[n("王=沉默王二")])),_:1}),s[3236]||(s[3236]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1459]||(s[1459]=[n("在最后，")])),_:1}),s[3237]||(s[3237]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1460]||(s[1460]=[n("默=沉默王二")])),_:1}),s[3238]||(s[3238]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1461]||(s[1461]=[n("在倒数第二位。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1462]||(s[1462]=[n("也就是说，最不经常访问的放在头部，这就有意思了。有意思在哪呢？")])),_:1}),a("h3",Yn,[a("a",$n,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1463]||(s[1463]=[n("LRU 缓存")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1464]||(s[1464]=[n("我们可以使用 LinkedHashMap 来实现 LRU 缓存，LRU 是 Least Recently Used 的缩写，即最近最少使用，是一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰。")])),_:1}),s[3239]||(s[3239]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">/**</span>
<span class="line"> * 自定义的 MyLinkedHashMap 类，继承了 Java 中内置的 LinkedHashMap&lt;K, V&gt; 类。</span>
<span class="line"> * 用于实现一个具有固定大小的缓存，当缓存达到最大容量时，会自动移除最早加入的元素，以腾出空间给新的元素。</span>
<span class="line"> *</span>
<span class="line"> * @param &lt;K&gt; 键的类型</span>
<span class="line"> * @param &lt;V&gt; 值的类型</span>
<span class="line"> */</span>
<span class="line">public class MyLinkedHashMap&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; {</span>
<span class="line"></span>
<span class="line">    private static final int MAX_ENTRIES = 5; // 表示 MyLinkedHashMap 中最多存储的键值对数量</span>
<span class="line"></span>
<span class="line">    /**</span>
<span class="line">     * 构造方法，使用 super() 调用了父类的构造函数，并传递了三个参数：initialCapacity、loadFactor 和 accessOrder。</span>
<span class="line">     *</span>
<span class="line">     * @param initialCapacity 初始容量</span>
<span class="line">     * @param loadFactor      负载因子</span>
<span class="line">     * @param accessOrder     访问顺序</span>
<span class="line">     */</span>
<span class="line">    public MyLinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) {</span>
<span class="line">        super(initialCapacity, loadFactor, accessOrder);</span>
<span class="line">    }</span>
<span class="line"></span>
<span class="line">    /**</span>
<span class="line">     * 重写父类的 removeEldestEntry() 方法，用于指示是否应该移除最早加入的元素。</span>
<span class="line">     * 如果返回 true，那么将删除最早加入的元素。</span>
<span class="line">     *</span>
<span class="line">     * @param eldest 最早加入的元素</span>
<span class="line">     * @return 如果当前 MyLinkedHashMap 中元素的数量大于 MAX_ENTRIES，返回 true，否则返回 false。</span>
<span class="line">     */</span>
<span class="line">    @Override</span>
<span class="line">    protected boolean removeEldestEntry(Map.Entry eldest) {</span>
<span class="line">        return size() &gt; MAX_ENTRIES;</span>
<span class="line">    }</span>
<span class="line"></span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1465]||(s[1465]=[n("MyLinkedHashMap 是一个自定义类，它继承了 LinkedHashMap，并且重写了")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3240]||(s[3240]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1466]||(s[1466]=[n("removeEldestEntry()")])),_:1}),s[3241]||(s[3241]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1467]||(s[1467]=[n("方法——使 Map 最多可容纳 5 个元素，超出后就淘汰。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1468]||(s[1468]=[n("我们来测试一下。")])),_:1}),s[3242]||(s[3242]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">MyLinkedHashMap&lt;String,String&gt; map = new MyLinkedHashMap&lt;&gt;(16,0.75f,true);</span>
<span class="line">map.put(&quot;沉&quot;, &quot;沉默王二&quot;);</span>
<span class="line">map.put(&quot;默&quot;, &quot;沉默王二&quot;);</span>
<span class="line">map.put(&quot;王&quot;, &quot;沉默王二&quot;);</span>
<span class="line">map.put(&quot;二&quot;, &quot;沉默王二&quot;);</span>
<span class="line">map.put(&quot;一枚有趣的程序员&quot;, &quot;一枚有趣的程序员&quot;);</span>
<span class="line"></span>
<span class="line">System.out.println(map);</span>
<span class="line"></span>
<span class="line">map.put(&quot;一枚有颜值的程序员&quot;, &quot;一枚有颜值的程序员&quot;);</span>
<span class="line">System.out.println(map);</span>
<span class="line"></span>
<span class="line">map.put(&quot;一枚有才华的程序员&quot;,&quot;一枚有才华的程序员&quot;);</span>
<span class="line">System.out.println(map);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1469]||(s[1469]=[n("输出结果如下所示：")])),_:1}),s[3243]||(s[3243]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">{沉=沉默王二, 默=沉默王二, 王=沉默王二, 二=沉默王二, 一枚有趣的程序员=一枚有趣的程序员}</span>
<span class="line">{默=沉默王二, 王=沉默王二, 二=沉默王二, 一枚有趣的程序员=一枚有趣的程序员, 一枚有颜值的程序员=一枚有颜值的程序员}</span>
<span class="line">{王=沉默王二, 二=沉默王二, 一枚有趣的程序员=一枚有趣的程序员, 一枚有颜值的程序员=一枚有颜值的程序员, 一枚有才华的程序员=一枚有才华的程序员}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),a("p",null,[s[1472]||(s[1472]=a("code",null,'<font style="color:rgb(44, 62, 80);">沉=沉默王二</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1470]||(s[1470]=[n("和")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[1473]||(s[1473]=a("code",null,'<font style="color:rgb(44, 62, 80);">默=沉默王二</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1471]||(s[1471]=[n("依次被淘汰出局。")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1474]||(s[1474]=[n("假如在 put “一枚有才华的程序员”之前 get 了键位为“默”的元素：")])),_:1}),s[3244]||(s[3244]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">MyLinkedHashMap&lt;String,String&gt; map = new MyLinkedHashMap&lt;&gt;(16,0.75f,true);</span>
<span class="line">map.put(&quot;沉&quot;, &quot;沉默王二&quot;);</span>
<span class="line">map.put(&quot;默&quot;, &quot;沉默王二&quot;);</span>
<span class="line">map.put(&quot;王&quot;, &quot;沉默王二&quot;);</span>
<span class="line">map.put(&quot;二&quot;, &quot;沉默王二&quot;);</span>
<span class="line">map.put(&quot;一枚有趣的程序员&quot;, &quot;一枚有趣的程序员&quot;);</span>
<span class="line"></span>
<span class="line">System.out.println(map);</span>
<span class="line"></span>
<span class="line">map.put(&quot;一枚有颜值的程序员&quot;, &quot;一枚有颜值的程序员&quot;);</span>
<span class="line">System.out.println(map);</span>
<span class="line"></span>
<span class="line">map.get(&quot;默&quot;);</span>
<span class="line">map.put(&quot;一枚有才华的程序员&quot;,&quot;一枚有才华的程序员&quot;);</span>
<span class="line">System.out.println(map);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1475]||(s[1475]=[n("那输出结果就变了，对吧？")])),_:1}),s[3245]||(s[3245]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">{沉=沉默王二, 默=沉默王二, 王=沉默王二, 二=沉默王二, 一枚有趣的程序员=一枚有趣的程序员}</span>
<span class="line">{默=沉默王二, 王=沉默王二, 二=沉默王二, 一枚有趣的程序员=一枚有趣的程序员, 一枚有颜值的程序员=一枚有颜值的程序员}</span>
<span class="line">{二=沉默王二, 一枚有趣的程序员=一枚有趣的程序员, 一枚有颜值的程序员=一枚有颜值的程序员, 默=沉默王二, 一枚有才华的程序员=一枚有才华的程序员}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),a("p",null,[s[1478]||(s[1478]=a("code",null,'<font style="color:rgb(44, 62, 80);">沉=沉默王二</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1476]||(s[1476]=[n("和")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[1479]||(s[1479]=a("code",null,'<font style="color:rgb(44, 62, 80);">王=沉默王二</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1477]||(s[1477]=[n("被淘汰出局了。")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1480]||(s[1480]=[n("那 LinkedHashMap 是如何来维持访问顺序呢？同学们感兴趣的话，可以研究一下下面这三个方法。")])),_:1}),s[3246]||(s[3246]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">void afterNodeAccess(Node&lt;K,V&gt; p) { }</span>
<span class="line">void afterNodeInsertion(boolean evict) { }</span>
<span class="line">void afterNodeRemoval(Node&lt;K,V&gt; p) { }</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),a("p",null,[s[1487]||(s[1487]=a("code",null,'<font style="color:rgb(44, 62, 80);">afterNodeAccess()</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1481]||(s[1481]=[n("会在调用")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[1488]||(s[1488]=a("code",null,'<font style="color:rgb(44, 62, 80);">get()</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1482]||(s[1482]=[n("方法的时候被调用，")])),_:1}),s[1489]||(s[1489]=a("code",null,'<font style="color:rgb(44, 62, 80);">afterNodeInsertion()</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1483]||(s[1483]=[n("会在调用")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[1490]||(s[1490]=a("code",null,'<font style="color:rgb(44, 62, 80);">put()</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1484]||(s[1484]=[n("方法的时候被调用，")])),_:1}),s[1491]||(s[1491]=a("code",null,'<font style="color:rgb(44, 62, 80);">afterNodeRemoval()</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1485]||(s[1485]=[n("会在调用")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[1492]||(s[1492]=a("code",null,'<font style="color:rgb(44, 62, 80);">remove()</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1486]||(s[1486]=[n("方法的时候被调用。")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1493]||(s[1493]=[n("我来以")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3247]||(s[3247]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1494]||(s[1494]=[n("afterNodeAccess()")])),_:1}),s[3248]||(s[3248]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1495]||(s[1495]=[n("为例来讲解一下。")])),_:1}),s[3249]||(s[3249]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">/**</span>
<span class="line"> * 在访问节点后，将节点移动到链表的尾部</span>
<span class="line"> *</span>
<span class="line"> * @param e 要移动的节点</span>
<span class="line"> */</span>
<span class="line">void afterNodeAccess(HashMap.Node&lt;K,V&gt; e) { // move node to last</span>
<span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span>
<span class="line">    if (accessOrder &amp;&amp; (last = tail) != e) { // 如果按访问顺序排序，并且访问的节点不是尾节点</span>
<span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span>
<span class="line">        p.after = null; // 将要移动的节点的后继节点设为 null</span>
<span class="line">        if (b == null)</span>
<span class="line">            head = a; // 如果要移动的节点没有前驱节点，则将要移动的节点设为头节点</span>
<span class="line">        else</span>
<span class="line">            b.after = a; // 将要移动的节点的前驱节点的后继节点设为要移动的节点的后继节点</span>
<span class="line">        if (a != null)</span>
<span class="line">            a.before = b; // 如果要移动的节点有后继节点，则将要移动的节点的后继节点的前驱节点设为要移动的节点的前驱节点</span>
<span class="line">        else</span>
<span class="line">            last = b; // 如果要移动的节点没有后继节点，则将要移动的节点的前驱节点设为尾节点</span>
<span class="line">        if (last == null)</span>
<span class="line">            head = p; // 如果尾节点为空，则将要移动的节点设为头节点</span>
<span class="line">        else {</span>
<span class="line">            p.before = last; // 将要移动的节点的前驱节点设为尾节点</span>
<span class="line">            last.after = p; // 将尾节点的后继节点设为要移动的节点</span>
<span class="line">        }</span>
<span class="line">        tail = p; // 将要移动的节点设为尾节点</span>
<span class="line">        ++modCount; // 修改计数器</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1496]||(s[1496]=[n("哪个元素被 get 就把哪个元素放在最后。了解了吧？")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1497]||(s[1497]=[n("那同学们可能还想知道，为什么 LinkedHashMap 能实现 LRU 缓存，把最不经常访问的那个元素淘汰？")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1498]||(s[1498]=[n("在插入元素的时候，需要调用")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3250]||(s[3250]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1499]||(s[1499]=[n("put()")])),_:1}),s[3251]||(s[3251]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1500]||(s[1500]=[n("方法，该方法最后会调用")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3252]||(s[3252]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1501]||(s[1501]=[n("afterNodeInsertion()")])),_:1}),s[3253]||(s[3253]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1502]||(s[1502]=[n("方法，这个方法被 LinkedHashMap 重写了。")])),_:1}),s[3254]||(s[3254]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">/**</span>
<span class="line"> * 在插入节点后，如果需要，可能会删除最早加入的元素</span>
<span class="line"> *</span>
<span class="line"> * @param evict 是否需要删除最早加入的元素</span>
<span class="line"> */</span>
<span class="line">void afterNodeInsertion(boolean evict) { // possibly remove eldest</span>
<span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span>
<span class="line">    if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) { // 如果需要删除最早加入的元素</span>
<span class="line">        K key = first.key; // 获取要删除元素的键</span>
<span class="line">        removeNode(hash(key), key, null, false, true); // 调用 removeNode() 方法删除元素</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),a("p",null,[s[1505]||(s[1505]=a("code",null,'<font style="color:rgb(44, 62, 80);">removeEldestEntry()</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1503]||(s[1503]=[n("方法会判断第一个元素是否超出了可容纳的最大范围，如果超出，那就会调用")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[1506]||(s[1506]=a("code",null,'<font style="color:rgb(44, 62, 80);">removeNode()</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1504]||(s[1504]=[n("方法对最不经常访问的那个元素进行删除。")])),_:1})]),a("h3",Wn,[a("a",Xn,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1507]||(s[1507]=[n("小结")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1508]||(s[1508]=[n("由于 LinkedHashMap 要维护双向链表，所以 LinkedHashMap 在插入、删除操作的时候，花费的时间要比 HashMap 多一些。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1509]||(s[1509]=[n("这也是没办法的事，对吧，欲戴皇冠必承其重嘛。既然想要维护元素的顺序，总要付出点代价才行。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1510]||(s[1510]=[n("简单总结一下吧。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1511]||(s[1511]=[n("首先，我们知道 HashMap 是一种常用的哈希表数据结构，它可以快速地进行键值对的查找和插入操作。但是，HashMap 本身并不保证键值对的顺序，如果我们需要按照插入顺序或访问顺序来遍历键值对，就需要使用 LinkedHashMap 了。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1512]||(s[1512]=[n("LinkedHashMap 继承自 HashMap，它在 HashMap 的基础上，增加了一个双向链表来维护键值对的顺序。这个链表可以按照插入顺序或访问顺序排序，它的头节点表示最早插入或访问的元素，尾节点表示最晚插入或访问的元素。这个链表的作用就是让 LinkedHashMap 可以保持键值对的顺序，并且可以按照顺序遍历键值对。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1513]||(s[1513]=[n("LinkedHashMap 还提供了两个构造方法来指定排序方式，分别是按照插入顺序排序和按照访问顺序排序。在按照访问顺序排序的情况下，每次访问一个键值对，都会将该键值对移到链表的尾部，以保证最近访问的元素在最后面。如果需要删除最早加入的元素，可以通过重写 removeEldestEntry() 方法来实现。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1514]||(s[1514]=[n("总之，LinkedHashMap 通过维护一个双向链表来保持键值对的顺序，可以按照插入顺序或访问顺序来遍历键值对。如果你需要按照顺序来遍历键值对，那么 LinkedHashMap 就是你的不二选择了！")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),a("h2",Gn,[a("a",Zn,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1515]||(s[1515]=[n("TreeMap 详解")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1516]||(s[1516]=[n("之前")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3255]||(s[3255]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1517]||(s[1517]=[n("LinkedHashMap")])),_:1}),s[3256]||(s[3256]=n("](https://javabetter.cn/collection/linkedhashmap.html)")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1518]||(s[1518]=[n("那篇文章里提到过了，HashMap 是无序的，所以有了 LinkedHashMap，加上了双向链表后，就可以保持元素的插入顺序和访问顺序，那 TreeMap 呢？")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1519]||(s[1519]=[n("TreeMap 由红黑树实现，可以保持元素的自然顺序，或者实现了 Comparator 接口的自定义顺序。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1520]||(s[1520]=[n("可能有些同学不了解红黑树，我这里来普及一下：")])),_:1}),l(e,{style:{color:"rgb(102, 102, 102)"}},{default:i(()=>s[1521]||(s[1521]=[n("红黑树（英语：Red–black tree）是一种自平衡的二叉查找树（Binary Search Tree），结构复杂，但却有着良好的性能，完成查找、插入和删除的")])),_:1}),s[3257]||(s[3257]=n("[")),l(e,{style:{color:"rgb(102, 102, 102)"}},{default:i(()=>s[1522]||(s[1522]=[n("时间复杂度")])),_:1}),s[3258]||(s[3258]=n("](https://javabetter.cn/collection/time-complexity.html)")),l(e,{style:{color:"rgb(102, 102, 102)"}},{default:i(()=>s[1523]||(s[1523]=[n("均为 log(n)。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1524]||(s[1524]=[n("二叉查找树是一种常见的树形结构，它的每个节点都包含一个键值对。每个节点的左子树节点的键值小于该节点的键值，右子树节点的键值大于该节点的键值，这个特性使得二叉查找树非常适合进行数据的查找和排序操作。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1525]||(s[1525]=[n("下面是一个简单的手绘图，展示了一个二叉查找树的结构：")])),_:1}),s[3259]||(s[3259]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">        8</span>
<span class="line">      /   \\</span>
<span class="line">     3     10</span>
<span class="line">    / \\      \\</span>
<span class="line">   1   6     14</span>
<span class="line">      / \\    /</span>
<span class="line">     4   7  13</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1526]||(s[1526]=[n("在上面这个二叉查找树中，根节点是 8，左子树节点包括 3、1、6、4 和 7，右子树节点包括 10、14 和 13。")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1527]||(s[1527]=[n("3<8<10")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1528]||(s[1528]=[n("1<3<6")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1529]||(s[1529]=[n("4<6<7")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1530]||(s[1530]=[n("10<14")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1531]||(s[1531]=[n("13<14")])),_:1})])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1532]||(s[1532]=[n("这是一颗典型的二叉查找树：")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1533]||(s[1533]=[n("1）左子树上所有节点的值均小于或等于它的根结点的值。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1534]||(s[1534]=[n("2）右子树上所有节点的值均大于或等于它的根结点的值。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1535]||(s[1535]=[n("3）左、右子树也分别为二叉查找树。")])),_:1})])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1536]||(s[1536]=[n("二叉查找树用来查找非常方面，从根节点开始遍历，如果当前节点的键值等于要查找的键值，则查找成功；如果要查找的键值小于当前节点的键值，则继续遍历左子树；如果要查找的键值大于当前节点的键值，则继续遍历右子树。如果遍历到叶子节点仍然没有找到，则查找失败。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1537]||(s[1537]=[n("插入操作也非常简单，从根节点开始遍历，如果要插入的键值小于当前节点的键值，则将其插入到左子树中；如果要插入的键值大于当前节点的键值，则将其插入到右子树中。如果要插入的键值已经存在于树中，则更新该节点的值。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1538]||(s[1538]=[n("删除操作稍微复杂一些，需要考虑多种情况，包括要删除的节点是叶子节点、要删除的节点只有一个子节点、要删除的节点有两个子节点等等。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1539]||(s[1539]=[n("总之，二叉查找树是一种非常常用的数据结构，它可以帮助我们实现数据的查找、排序和删除等操作。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1540]||(s[1540]=[n("理解二叉查找树了吧？")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1541]||(s[1541]=[n("不过，二叉查找树有一个明显的不足，就是容易变成瘸子，就是一侧多，一侧少，比如说这样：")])),_:1}),s[3260]||(s[3260]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">        6</span>
<span class="line">      /   \\</span>
<span class="line">     4     8</span>
<span class="line">    /     / \\</span>
<span class="line">   3     7   9</span>
<span class="line">  /</span>
<span class="line"> 1</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1542]||(s[1542]=[n("在上面这个不平衡的二叉查找树中，左子树比右子树高。根节点是 6，左子树节点包括 4、3 和 1，右子树节点包括 8、7 和 9。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1543]||(s[1543]=[n("由于左子树比右子树高，这个不平衡的二叉查找树可能会导致查找、插入和删除操作的效率下降。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1544]||(s[1544]=[n("来一个更极端的情况。")])),_:1}),s[3261]||(s[3261]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">    1</span>
<span class="line">     \\</span>
<span class="line">      2</span>
<span class="line">       \\</span>
<span class="line">        3</span>
<span class="line">         \\</span>
<span class="line">          4</span>
<span class="line">           \\</span>
<span class="line">            5</span>
<span class="line">             \\</span>
<span class="line">              6</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1545]||(s[1545]=[n("在上面这个极度不平衡的二叉查找树中，所有节点都只有一个右子节点，根节点是 1，右子树节点包括 2、3、4、5 和 6。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1546]||(s[1546]=[n("这种极度不平衡的二叉查找树会导致查找、插入和删除操作的效率急剧下降，因为每次操作都只能在右子树中进行，而左子树几乎没有被利用到。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1547]||(s[1547]=[n("查找的效率就要从 log(n) 变成 o(n) 了（戳")])),_:1}),s[3262]||(s[3262]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1548]||(s[1548]=[n("这里")])),_:1}),s[3263]||(s[3263]=n("](https://javabetter.cn/collection/time-complexity.html)")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1549]||(s[1549]=[n("了解时间复杂度），对吧？")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1550]||(s[1550]=[n("必须要平衡一下，对吧？于是就有了平衡二叉树，左右两个子树的高度差的绝对值不超过 1，就像下图这样：")])),_:1}),s[3264]||(s[3264]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">        8</span>
<span class="line">      /   \\</span>
<span class="line">     4     12</span>
<span class="line">    / \\    / \\</span>
<span class="line">   2   6  10  14</span>
<span class="line">      / \\    / \\</span>
<span class="line">     5   7  13  15</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1551]||(s[1551]=[n("根节点是 8，左子树节点包括 4、2、6、5 和 7，右子树节点包括 12、10、14、13 和 15。左子树和右子树的高度差不超过1，因此它是一个平衡二叉查找树。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1552]||(s[1552]=[n("平衡二叉树就像是一棵树形秤，它的左右两边的重量要尽可能的平衡。当我们往平衡二叉树中插入一个节点时，平衡二叉树会自动调整节点的位置，以保证树的左右两边的高度差不超过1。类似地，当我们删除一个节点时，平衡二叉树也会自动调整节点的位置，以保证树的左右两边的高度差不超过1。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1553]||(s[1553]=[n("常见的平衡二叉树包括AVL树、红黑树等等，它们都是通过旋转操作来调整树的平衡，使得左子树和右子树的高度尽可能接近。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1554]||(s[1554]=[n("AVL树的示意图：")])),_:1}),s[3265]||(s[3265]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">8</span>
<span class="line">         /   \\</span>
<span class="line">        4     12</span>
<span class="line">       / \\   /  \\</span>
<span class="line">      2   6 10  14</span>
<span class="line">         / \\</span>
<span class="line">        5   7</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1555]||(s[1555]=[n("AVL树是一种高度平衡的二叉查找树，它要求左子树和右子树的高度差不超过1。由于AVL树的平衡度比较高，因此在进行插入和删除操作时需要进行更多的旋转操作来保持平衡，但是在查找操作时效率较高。AVL树适用于读操作比较多的场景。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1556]||(s[1556]=[n("例如，对于一个需要频繁进行查找操作的场景，如字典树、哈希表等数据结构，可以使用AVL树来进行优化。另外，AVL树也适用于需要保证数据有序性的场景，如数据库中的索引。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1557]||(s[1557]=[n("AVL树最初由两位苏联的计算机科学家，Adelson-Velskii和Landis，于1962年提出。因此，AVL树就以他们两人名字的首字母缩写命名了。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1558]||(s[1558]=[n("AVL树的发明对计算机科学的发展有着重要的影响，不仅为后来的平衡二叉树提供了基础，而且为其他领域的数据结构和算法提供了启示。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1559]||(s[1559]=[n("红黑树的示意图（R 即 Red「红」、B 即 Black「黑」）：")])),_:1}),s[3266]||(s[3266]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">8B</span>
<span class="line">         /   \\</span>
<span class="line">        4R    12R</span>
<span class="line">       / \\   /  \\</span>
<span class="line">      2B 6B 10B 14B</span>
<span class="line">         / \\</span>
<span class="line">        5R 7R</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1560]||(s[1560]=[n("红黑树，顾名思义，就是节点是红色或者黑色的平衡二叉树，它通过颜色的约束来维持二叉树的平衡，它要求任意一条路径上的黑色节点数目相同，同时还需要满足一些其他特定的条件，如红色节点的父节点必须为黑色节点等。")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1561]||(s[1561]=[n("1）每个节点都只能是红色或者黑色")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1562]||(s[1562]=[n("2）根节点是黑色")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1563]||(s[1563]=[n("3）每个叶节点（NIL 节点，空节点）是黑色的。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1564]||(s[1564]=[n("4）如果一个节点是红色的，则它两个子节点都是黑色的。也就是说在一条路径上不能出现相邻的两个红色节点。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1565]||(s[1565]=[n("5）从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。")])),_:1})])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1566]||(s[1566]=[n("由于红黑树的平衡度比AVL树稍低，因此在进行插入和删除操作时需要进行的旋转操作较少，但是在查找操作时效率仍然较高。红黑树适用于读写操作比较均衡的场景。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1567]||(s[1567]=[n("那，关于红黑树，同学们就先了解到这，脑子里有个大概的印象，知道 TreeMap 是个什么玩意。")])),_:1}),a("h3",hn,[a("a",_n,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1568]||(s[1568]=[n("自然顺序")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1569]||(s[1569]=[n("默认情况下，TreeMap 是根据 key 的自然顺序排列的。比如说整数，就是升序，1、2、3、4、5。")])),_:1}),s[3267]||(s[3267]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">TreeMap&lt;Integer,String&gt; mapInt = new TreeMap&lt;&gt;();</span>
<span class="line">mapInt.put(3, &quot;沉默王二&quot;);</span>
<span class="line">mapInt.put(2, &quot;沉默王二&quot;);</span>
<span class="line">mapInt.put(1, &quot;沉默王二&quot;);</span>
<span class="line">mapInt.put(5, &quot;沉默王二&quot;);</span>
<span class="line">mapInt.put(4, &quot;沉默王二&quot;);</span>
<span class="line"></span>
<span class="line">System.out.println(mapInt);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1570]||(s[1570]=[n("输出结果如下所示：")])),_:1}),s[3268]||(s[3268]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">{1=沉默王二, 2=沉默王二, 3=沉默王二, 4=沉默王二, 5=沉默王二}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1571]||(s[1571]=[n("TreeMap 是怎么做到的呢？想一探究竟，就得上源码了，来看 TreeMap 的")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3269]||(s[3269]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1572]||(s[1572]=[n("put()")])),_:1}),s[3270]||(s[3270]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1573]||(s[1573]=[n("方法：")])),_:1}),s[3271]||(s[3271]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public V put(K key, V value) {</span>
<span class="line">    Entry&lt;K,V&gt; t = root; // 将根节点赋值给变量t</span>
<span class="line">    if (t == null) { // 如果根节点为null，说明TreeMap为空</span>
<span class="line">        compare(key, key); // type (and possibly null) check，检查key的类型是否合法</span>
<span class="line">        root = new Entry&lt;&gt;(key, value, null); // 创建一个新节点作为根节点</span>
<span class="line">        size = 1; // size设置为1</span>
<span class="line">        return null; // 返回null，表示插入成功</span>
<span class="line">    }</span>
<span class="line">    int cmp;</span>
<span class="line">    Entry&lt;K,V&gt; parent;</span>
<span class="line">    // split comparator and comparable paths，根据使用的比较方法进行查找</span>
<span class="line">    Comparator&lt;? super K&gt; cpr = comparator; // 获取比较器</span>
<span class="line">    if (cpr != null) { // 如果使用了Comparator</span>
<span class="line">        do {</span>
<span class="line">            parent = t; // 将当前节点赋值给parent</span>
<span class="line">            cmp = cpr.compare(key, t.key); // 使用Comparator比较key和t的键的大小</span>
<span class="line">            if (cmp &lt; 0) // 如果key小于t的键</span>
<span class="line">                t = t.left; // 在t的左子树中查找</span>
<span class="line">            else if (cmp &gt; 0) // 如果key大于t的键</span>
<span class="line">                t = t.right; // 在t的右子树中查找</span>
<span class="line">            else // 如果key等于t的键</span>
<span class="line">                return t.setValue(value); // 直接更新t的值</span>
<span class="line">        } while (t != null);</span>
<span class="line">    }</span>
<span class="line">    else { // 如果没有使用Comparator</span>
<span class="line">        if (key == null) // 如果key为null</span>
<span class="line">            throw new NullPointerException(); // 抛出NullPointerException异常</span>
<span class="line">            Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; // 将key强制转换为Comparable类型</span>
<span class="line">        do {</span>
<span class="line">            parent = t; // 将当前节点赋值给parent</span>
<span class="line">            cmp = k.compareTo(t.key); // 使用Comparable比较key和t的键的大小</span>
<span class="line">            if (cmp &lt; 0) // 如果key小于t的键</span>
<span class="line">                t = t.left; // 在t的左子树中查找</span>
<span class="line">            else if (cmp &gt; 0) // 如果key大于t的键</span>
<span class="line">                t = t.right; // 在t的右子树中查找</span>
<span class="line">            else // 如果key等于t的键</span>
<span class="line">                return t.setValue(value); // 直接更新t的值</span>
<span class="line">        } while (t != null);</span>
<span class="line">    }</span>
<span class="line">    // 如果没有找到相同的键，需要创建一个新节点插入到TreeMap中</span>
<span class="line">    Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent); // 创建一个新节点</span>
<span class="line">    if (cmp &lt; 0) // 如果key小于parent的键</span>
<span class="line">        parent.left = e; // 将e作为parent的左子节点</span>
<span class="line">    else</span>
<span class="line">        parent.right = e; // 将e作为parent的右子节点</span>
<span class="line">    fixAfterInsertion(e); // 插入节点后需要进行平衡操作</span>
<span class="line">    size++; // size加1</span>
<span class="line">    return null; // 返回null，表示插入成功</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1574]||(s[1574]=[n("首先定义一个Entry类型的变量t，用于表示当前的根节点；")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1575]||(s[1575]=[n("如果t为null，说明TreeMap为空，直接创建一个新的节点作为根节点，并将size设置为1；")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1576]||(s[1576]=[n("如果t不为null，说明需要在TreeMap中查找键所对应的节点。因为TreeMap中的元素是有序的，所以可以使用二分查找的方式来查找节点；")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1577]||(s[1577]=[n("如果TreeMap中使用了Comparator来进行排序，则使用Comparator进行比较，否则使用Comparable进行比较。如果查找到了相同的键，则直接更新键所对应的值；")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1578]||(s[1578]=[n("如果没有查找到相同的键，则创建一个新的节点，并将其插入到TreeMap中。然后使用fixAfterInsertion()方法来修正插入节点后的平衡状态；")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1579]||(s[1579]=[n("最后将TreeMap的size加1，然后返回null。如果更新了键所对应的值，则返回原先的值。")])),_:1})])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1580]||(s[1580]=[n("注意")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3272]||(s[3272]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1581]||(s[1581]=[n("cmp = k.compareTo(t.key)")])),_:1}),s[3273]||(s[3273]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1582]||(s[1582]=[n("这行代码，就是用来进行 key 比较的，由于此时 key 是 String，所以就会调用 String 类的")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3274]||(s[3274]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1583]||(s[1583]=[n("compareTo()")])),_:1}),s[3275]||(s[3275]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1584]||(s[1584]=[n("方法进行比较。")])),_:1}),s[3276]||(s[3276]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public int compareTo(String anotherString) {</span>
<span class="line">    // 获取当前字符串和另一个字符串的长度</span>
<span class="line">    int len1 = value.length;</span>
<span class="line">    int len2 = anotherString.value.length;</span>
<span class="line">    // 取两个字符串长度的较短者作为比较的上限</span>
<span class="line">    int lim = Math.min(len1, len2);</span>
<span class="line">    // 获取当前字符串和另一个字符串的字符数组</span>
<span class="line">    char v1[] = value;</span>
<span class="line">    char v2[] = anotherString.value;</span>
<span class="line"></span>
<span class="line">    int k = 0;</span>
<span class="line">    // 对两个字符串的每个字符进行比较</span>
<span class="line">    while (k &lt; lim) {</span>
<span class="line">        char c1 = v1[k];</span>
<span class="line">        char c2 = v2[k];</span>
<span class="line">        // 如果两个字符不相等，返回它们的差值</span>
<span class="line">        if (c1 != c2) {</span>
<span class="line">            return c1 - c2;</span>
<span class="line">        }</span>
<span class="line">        k++;</span>
<span class="line">    }</span>
<span class="line">    // 如果两个字符串前面的字符都相等，返回它们长度的差值</span>
<span class="line">    return len1 - len2;</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1585]||(s[1585]=[n("来看下面的示例。")])),_:1}),s[3277]||(s[3277]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">TreeMap&lt;String,String&gt; mapString = new TreeMap&lt;&gt;();</span>
<span class="line">mapString.put(&quot;c&quot;, &quot;沉默王二&quot;);</span>
<span class="line">mapString.put(&quot;b&quot;, &quot;沉默王二&quot;);</span>
<span class="line">mapString.put(&quot;a&quot;, &quot;沉默王二&quot;);</span>
<span class="line">mapString.put(&quot;e&quot;, &quot;沉默王二&quot;);</span>
<span class="line">mapString.put(&quot;d&quot;, &quot;沉默王二&quot;);</span>
<span class="line"></span>
<span class="line">System.out.println(mapString);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1586]||(s[1586]=[n("输出结果如下所示：")])),_:1}),s[3278]||(s[3278]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">{a=沉默王二, b=沉默王二, c=沉默王二, d=沉默王二, e=沉默王二}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1587]||(s[1587]=[n("从结果可以看得出，是按照字母的升序进行排序的。")])),_:1}),a("h3",sl,[a("a",nl,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1588]||(s[1588]=[n("自定义排序")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1589]||(s[1589]=[n("如果自然顺序不满足，那就可以在声明 TreeMap 对象的时候指定排序规则。")])),_:1}),s[3279]||(s[3279]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">TreeMap&lt;Integer,String&gt; mapIntReverse = new TreeMap&lt;&gt;(Comparator.reverseOrder());</span>
<span class="line">mapIntReverse.put(3, &quot;沉默王二&quot;);</span>
<span class="line">mapIntReverse.put(2, &quot;沉默王二&quot;);</span>
<span class="line">mapIntReverse.put(1, &quot;沉默王二&quot;);</span>
<span class="line">mapIntReverse.put(5, &quot;沉默王二&quot;);</span>
<span class="line">mapIntReverse.put(4, &quot;沉默王二&quot;);</span>
<span class="line"></span>
<span class="line">System.out.println(mapIntReverse);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1590]||(s[1590]=[n("TreeMap 提供了可以指定排序规则的构造方法：")])),_:1}),s[3280]||(s[3280]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public TreeMap(Comparator&lt;? super K&gt; comparator) {</span>
<span class="line">    this.comparator = comparator;</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),a("p",null,[s[1592]||(s[1592]=a("code",null,'<font style="color:rgb(44, 62, 80);">Comparator.reverseOrder()</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1591]||(s[1591]=[n("返回的是 Collections.ReverseComparator 对象，就是用来反转顺序的，非常方便。")])),_:1})]),s[3281]||(s[3281]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">private static class ReverseComparator</span>
<span class="line">        implements Comparator&lt;Comparable&lt;Object&gt;&gt;, Serializable {</span>
<span class="line">    // 单例模式，用于表示逆序比较器</span>
<span class="line">    static final ReverseComparator REVERSE_ORDER</span>
<span class="line">            = new ReverseComparator();</span>
<span class="line"></span>
<span class="line">    // 实现比较方法，对两个实现了Comparable接口的对象进行逆序比较</span>
<span class="line">    public int compare(Comparable&lt;Object&gt; c1, Comparable&lt;Object&gt; c2) {</span>
<span class="line">        return c2.compareTo(c1); // 调用c2的compareTo()方法，以c1为参数，实现逆序比较</span>
<span class="line">    }</span>
<span class="line"></span>
<span class="line">    // 反序列化时，返回Collections.reverseOrder()，保证单例模式</span>
<span class="line">    private Object readResolve() {</span>
<span class="line">        return Collections.reverseOrder();</span>
<span class="line">    }</span>
<span class="line"></span>
<span class="line">    // 返回正序比较器</span>
<span class="line">    @Override</span>
<span class="line">    public Comparator&lt;Comparable&lt;Object&gt;&gt; reversed() {</span>
<span class="line">        return Comparator.naturalOrder();</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1593]||(s[1593]=[n("所以，输出结果如下所示：")])),_:1}),s[3282]||(s[3282]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">{5=沉默王二, 4=沉默王二, 3=沉默王二, 2=沉默王二, 1=沉默王二}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1594]||(s[1594]=[n("HashMap 是无序的，插入的顺序随着元素的增加会不停地变动。但 TreeMap 能够至始至终按照指定的顺序排列，这对于需要自定义排序的场景，实在是太有用了！")])),_:1}),a("h3",ll,[a("a",el,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1595]||(s[1595]=[n("排序的好处")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1596]||(s[1596]=[n("既然 TreeMap 的元素是经过排序的，那找出最大的那个，最小的那个，或者找出所有大于或者小于某个值的键来说，就方便多了。")])),_:1}),s[3283]||(s[3283]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">Integer highestKey = mapInt.lastKey();</span>
<span class="line">Integer lowestKey = mapInt.firstKey();</span>
<span class="line">Set&lt;Integer&gt; keysLessThan3 = mapInt.headMap(3).keySet();</span>
<span class="line">Set&lt;Integer&gt; keysGreaterThanEqTo3 = mapInt.tailMap(3).keySet();</span>
<span class="line"></span>
<span class="line">System.out.println(highestKey);</span>
<span class="line">System.out.println(lowestKey);</span>
<span class="line"></span>
<span class="line">System.out.println(keysLessThan3);</span>
<span class="line">System.out.println(keysGreaterThanEqTo3);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1597]||(s[1597]=[n("TreeMap 考虑得很周全，恰好就提供了")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3284]||(s[3284]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1598]||(s[1598]=[n("lastKey()")])),_:1}),s[3285]||(s[3285]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1599]||(s[1599]=[n("、")])),_:1}),s[3286]||(s[3286]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1600]||(s[1600]=[n("firstKey()")])),_:1}),s[3287]||(s[3287]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1601]||(s[1601]=[n("这样获取最后一个 key 和第一个 key 的方法。")])),_:1}),a("p",null,[s[1604]||(s[1604]=a("code",null,'<font style="color:rgb(44, 62, 80);">headMap()</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1602]||(s[1602]=[n("获取的是到指定 key 之前的 key；")])),_:1}),s[1605]||(s[1605]=a("code",null,'<font style="color:rgb(44, 62, 80);">tailMap()</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1603]||(s[1603]=[n("获取的是指定 key 之后的 key（包括指定 key）。")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1606]||(s[1606]=[n("来看一下输出结果：")])),_:1}),s[3288]||(s[3288]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">5</span>
<span class="line">1</span>
<span class="line">[1, 2]</span>
<span class="line">[3, 4, 5]</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1607]||(s[1607]=[n("再来看一下例子：")])),_:1}),s[3289]||(s[3289]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">TreeMap&lt;Integer, String&gt; treeMap = new TreeMap&lt;&gt;();</span>
<span class="line">treeMap.put(1, &quot;value1&quot;);</span>
<span class="line">treeMap.put(2, &quot;value2&quot;);</span>
<span class="line">treeMap.put(3, &quot;value3&quot;);</span>
<span class="line">treeMap.put(4, &quot;value4&quot;);</span>
<span class="line">treeMap.put(5, &quot;value5&quot;);</span>
<span class="line"></span>
<span class="line">// headMap示例，获取小于3的键值对</span>
<span class="line">Map&lt;Integer, String&gt; headMap = treeMap.headMap(3);</span>
<span class="line">System.out.println(headMap); // 输出 {1=value1, 2=value2}</span>
<span class="line"></span>
<span class="line">// tailMap示例，获取大于等于4的键值对</span>
<span class="line">Map&lt;Integer, String&gt; tailMap = treeMap.tailMap(4);</span>
<span class="line">System.out.println(tailMap); // 输出 {4=value4, 5=value5}</span>
<span class="line"></span>
<span class="line">// subMap示例，获取大于等于2且小于4的键值对</span>
<span class="line">Map&lt;Integer, String&gt; subMap = treeMap.subMap(2, 4);</span>
<span class="line">System.out.println(subMap); // 输出 {2=value2, 3=value3}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1608]||(s[1608]=[n("headMap、tailMap、subMap方法分别获取了小于3、大于等于4、大于等于2且小于4的键值对。")])),_:1}),a("h3",il,[a("a",al,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1609]||(s[1609]=[n("如何选择 Map")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1610]||(s[1610]=[n("在学习 TreeMap 之前，我们已经学习了")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3290]||(s[3290]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1611]||(s[1611]=[n("HashMap")])),_:1}),s[3291]||(s[3291]=n("](https://javabetter.cn/collection/hashmap.html)")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1612]||(s[1612]=[n("和")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3292]||(s[3292]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1613]||(s[1613]=[n("LinkedHashMap")])),_:1}),s[3293]||(s[3293]=n("](https://javabetter.cn/collection/linkedhashmap.html)")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1614]||(s[1614]=[n("，那如何从它们三个中间选择呢？")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1615]||(s[1615]=[n("需要考虑以下因素：")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1616]||(s[1616]=[n("是否需要按照键的自然顺序或者自定义顺序进行排序。如果需要按照键排序，则可以使用 TreeMap；如果不需要排序，则可以使用 HashMap 或 LinkedHashMap。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1617]||(s[1617]=[n("是否需要保持插入顺序。如果需要保持插入顺序，则可以使用 LinkedHashMap；如果不需要保持插入顺序，则可以使用 TreeMap 或 HashMap。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1618]||(s[1618]=[n("是否需要高效的查找。如果需要高效的查找，则可以使用 LinkedHashMap 或 HashMap，因为它们的查找操作的时间复杂度为 O(1)，而是 TreeMap 是 O(log n)。")])),_:1})])]),l(e,{style:{color:"rgb(102, 102, 102)"}},{default:i(()=>s[1619]||(s[1619]=[n("LinkedHashMap 内部使用哈希表来存储键值对，并使用一个双向链表来维护插入顺序，但查找操作只需要在哈希表中进行，与链表无关，所以时间复杂度为 O(1)")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1620]||(s[1620]=[n("来个表格吧，一目了然。")])),_:1}),a("table",null,[a("thead",null,[a("tr",null,[a("th",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1621]||(s[1621]=[n("特性")])),_:1})]),a("th",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1622]||(s[1622]=[n("TreeMap")])),_:1})]),a("th",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1623]||(s[1623]=[n("HashMap")])),_:1})]),a("th",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1624]||(s[1624]=[n("LinkedHashMap")])),_:1})])])]),a("tbody",null,[a("tr",null,[a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1625]||(s[1625]=[n("排序")])),_:1})]),a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1626]||(s[1626]=[n("支持")])),_:1})]),a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1627]||(s[1627]=[n("不支持")])),_:1})]),a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1628]||(s[1628]=[n("不支持")])),_:1})])]),a("tr",null,[a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1629]||(s[1629]=[n("插入顺序")])),_:1})]),a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1630]||(s[1630]=[n("不保证")])),_:1})]),a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1631]||(s[1631]=[n("不保证")])),_:1})]),a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1632]||(s[1632]=[n("保证")])),_:1})])]),a("tr",null,[a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1633]||(s[1633]=[n("查找效率")])),_:1})]),a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1634]||(s[1634]=[n("O(log n)")])),_:1})]),a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1635]||(s[1635]=[n("O(1)")])),_:1})]),a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1636]||(s[1636]=[n("O(1)")])),_:1})])]),a("tr",null,[a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1637]||(s[1637]=[n("空间占用")])),_:1})]),a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1638]||(s[1638]=[n("通常较大")])),_:1})]),a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1639]||(s[1639]=[n("通常较小")])),_:1})]),a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1640]||(s[1640]=[n("通常较大")])),_:1})])]),a("tr",null,[a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1641]||(s[1641]=[n("适用场景")])),_:1})]),a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1642]||(s[1642]=[n("需要排序的场景")])),_:1})]),a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1643]||(s[1643]=[n("无需排序的场景")])),_:1})]),a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1644]||(s[1644]=[n("需要保持插入顺序")])),_:1})])])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1645]||(s[1645]=[n("好了，下课，关于 TreeMap 我们就讲到这里吧，希望同学们都能对 TreeMap 有一个清晰的认识。我们下节课见~")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),a("h2",tl,[a("a",rl,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1646]||(s[1646]=[n("双端队列 ArrayDeque")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1647]||(s[1647]=[n("Java 里有一个叫做")])),_:1}),s[3294]||(s[3294]=n("_")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1648]||(s[1648]=[n("Stack")])),_:1}),s[3295]||(s[3295]=n("_")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1649]||(s[1649]=[n("的类，却没有叫做")])),_:1}),s[3296]||(s[3296]=n("_")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1650]||(s[1650]=[n("Queue")])),_:1}),s[3297]||(s[3297]=n("_")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1651]||(s[1651]=[n("的类（它只是个接口名字，和类还不一样）。")])),_:1}),s[3298]||(s[3298]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public interface Queue&lt;E&gt; extends Collection&lt;E&gt; {}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1652]||(s[1652]=[n("当需要使用栈时，Java 已不推荐使用")])),_:1}),s[3299]||(s[3299]=n("_")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1653]||(s[1653]=[n("Stack")])),_:1}),s[3300]||(s[3300]=n("_")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1654]||(s[1654]=[n("，而是推荐使用更高效的")])),_:1}),s[3301]||(s[3301]=n("_")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1655]||(s[1655]=[n("ArrayDeque")])),_:1}),s[3302]||(s[3302]=n("_")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1656]||(s[1656]=[n("（双端队列），原因我们第一次讲")])),_:1}),s[3303]||(s[3303]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1657]||(s[1657]=[n("集合框架")])),_:1}),s[3304]||(s[3304]=n("](https://javabetter.cn/collection/gailan.html)")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1658]||(s[1658]=[n("的时候，其实已经聊过了，Stack 是一个“原始”类，它的核心方法上都加了")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3305]||(s[3305]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1659]||(s[1659]=[n("synchronized")])),_:1}),s[3306]||(s[3306]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1660]||(s[1660]=[n("关键字以确保线程安全，当我们不需要线程安全（比如说单线程环境下）性能就会比较差。")])),_:1}),s[3307]||(s[3307]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726668480227-bac445de-bf46-46cf-85a9-ff1b7363165f.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1661]||(s[1661]=[n("也就是说，当需要使用栈时候，请首选")])),_:1}),s[3308]||(s[3308]=n("_")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1662]||(s[1662]=[n("ArrayDeque")])),_:1}),s[3309]||(s[3309]=n("_")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1663]||(s[1663]=[n("。")])),_:1}),s[3310]||(s[3310]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">// 声明一个双端队列</span>
<span class="line">ArrayDeque&lt;String&gt; stack = new ArrayDeque&lt;&gt;();</span>
<span class="line"></span>
<span class="line">// 增加元素</span>
<span class="line">stack.push(&quot;沉默&quot;);</span>
<span class="line">stack.push(&quot;王二&quot;);</span>
<span class="line">stack.push(&quot;陈清扬&quot;);</span>
<span class="line"></span>
<span class="line">// 获取栈顶元素</span>
<span class="line">String top = stack.peek();</span>
<span class="line">System.out.println(&quot;栈顶元素为：&quot; + top); // 陈清扬</span>
<span class="line"></span>
<span class="line">// 弹出栈顶元素</span>
<span class="line">String pop = stack.pop();</span>
<span class="line">System.out.println(&quot;弹出的元素为：&quot; + pop); // 陈清扬</span>
<span class="line"></span>
<span class="line">// 修改栈顶元素</span>
<span class="line">stack.pop();</span>
<span class="line">stack.push(&quot;小明&quot;);</span>
<span class="line">System.out.println(&quot;修改后的栈为：&quot; + stack); // [小明, 沉默]</span>
<span class="line"></span>
<span class="line">// 遍历队列查找元素</span>
<span class="line">Iterator&lt;String&gt; iterator = stack.iterator();</span>
<span class="line">int index = -1;</span>
<span class="line">String target = &quot;王二&quot;;</span>
<span class="line">while (iterator.hasNext()) {</span>
<span class="line">    String element = iterator.next();</span>
<span class="line">    index++;</span>
<span class="line">    if (element.equals(target)) {</span>
<span class="line">        break;</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">if (index == -1) {</span>
<span class="line">    System.out.println(&quot;元素 &quot; + target + &quot; 不存在于队列中&quot;);</span>
<span class="line">} else {</span>
<span class="line">    System.out.println(&quot;元素 &quot; + target + &quot; 在队列中的位置为：&quot; + index);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1664]||(s[1664]=[n("在上面的示例中，我们先创建了一个 ArrayDeque 对象，然后使用 push 方法向栈中添加了三个元素。接着使用 peek 方法获取栈顶元素，使用 pop 方法弹出栈顶元素，使用 pop 和 push 方法修改栈顶元素，使用迭代器查找元素在栈中的位置。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1665]||(s[1665]=[n("ArrayDeque 又实现了 Deque 接口（Deque 又实现了 Queue 接口）：")])),_:1}),s[3311]||(s[3311]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public class ArrayDeque&lt;E&gt; extends AbstractCollection&lt;E&gt;</span>
<span class="line">                           implements Deque&lt;E&gt;, Cloneable, Serializable</span>
<span class="line">{}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1666]||(s[1666]=[n("因此，当我们需要使用队列的时候，也可以选择 ArrayDeque。")])),_:1}),s[3312]||(s[3312]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">ArrayDeque&lt;String&gt; queue = new ArrayDeque&lt;&gt;();</span>
<span class="line"></span>
<span class="line">// 增加元素</span>
<span class="line">queue.offer(&quot;沉默&quot;);</span>
<span class="line">queue.offer(&quot;王二&quot;);</span>
<span class="line">queue.offer(&quot;陈清扬&quot;);</span>
<span class="line"></span>
<span class="line">// 获取队首元素</span>
<span class="line">String front = queue.peek();</span>
<span class="line">System.out.println(&quot;队首元素为：&quot; + front); // 沉默</span>
<span class="line"></span>
<span class="line">// 弹出队首元素</span>
<span class="line">String poll = queue.poll();</span>
<span class="line">System.out.println(&quot;弹出的元素为：&quot; + poll); // 沉默</span>
<span class="line"></span>
<span class="line">// 修改队列中的元素</span>
<span class="line">queue.poll();</span>
<span class="line">queue.offer(&quot;小明&quot;);</span>
<span class="line">System.out.println(&quot;修改后的队列为：&quot; + queue); // [陈清扬, 小明]</span>
<span class="line"></span>
<span class="line">// 查找元素</span>
<span class="line">Iterator&lt;String&gt; iterator = queue.iterator();</span>
<span class="line">int index = 0;</span>
<span class="line">while (iterator.hasNext()) {</span>
<span class="line">    String element = iterator.next();</span>
<span class="line">    if (element.equals(&quot;王二&quot;)) {</span>
<span class="line">        System.out.println(&quot;元素在队列中的位置为：&quot; + index); // 0</span>
<span class="line">        break;</span>
<span class="line">    }</span>
<span class="line">    index++;</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1667]||(s[1667]=[n("在上面的示例中，我们先创建了一个 ArrayDeque 对象，然后使用 offer 方法向队列中添加了三个元素。接着使用 peek 方法获取队首元素，使用 poll 方法弹出队首元素，使用 poll 和 offer 方法修改队列中的元素，使用迭代器查找元素在队列中的位置。")])),_:1}),a("p",null,[a("a",dl,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1668]||(s[1668]=[n("我们前面讲了")])),_:1}),l(r)]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1669]||(s[1669]=[n("，LinkedList不只是个 List，还是一个 Queue，它也实现了 Deque 接口。")])),_:1})]),s[3313]||(s[3313]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public class LinkedList&lt;E&gt;</span>
<span class="line">    extends AbstractSequentialList&lt;E&gt;</span>
<span class="line">    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span>
<span class="line">{}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1670]||(s[1670]=[n("所以，当我们需要使用队列时，还可以选择")])),_:1}),s[3314]||(s[3314]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1671]||(s[1671]=[n("LinkedList")])),_:1}),s[3315]||(s[3315]=n("](https://javabetter.cn/collection/linkedlist.html)")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1672]||(s[1672]=[n("。")])),_:1}),s[3316]||(s[3316]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">// 创建一个 LinkedList 对象</span>
<span class="line">LinkedList&lt;String&gt; queue = new LinkedList&lt;&gt;();</span>
<span class="line"></span>
<span class="line">// 添加元素</span>
<span class="line">queue.offer(&quot;沉默&quot;);</span>
<span class="line">queue.offer(&quot;王二&quot;);</span>
<span class="line">queue.offer(&quot;陈清扬&quot;);</span>
<span class="line">System.out.println(queue); // 输出 [沉默, 王二, 陈清扬]</span>
<span class="line"></span>
<span class="line">// 删除元素</span>
<span class="line">queue.poll();</span>
<span class="line">System.out.println(queue); // 输出 [王二, 陈清扬]</span>
<span class="line"></span>
<span class="line">// 修改元素：LinkedList 中的元素不支持直接修改，需要先删除再添加</span>
<span class="line">String first = queue.poll();</span>
<span class="line">queue.offer(&quot;王大二&quot;);</span>
<span class="line">System.out.println(queue); // 输出 [陈清扬, 王大二]</span>
<span class="line"></span>
<span class="line">// 查找元素：LinkedList 中的元素可以使用 get() 方法进行查找</span>
<span class="line">System.out.println(queue.get(0)); // 输出 陈清扬</span>
<span class="line">System.out.println(queue.contains(&quot;沉默&quot;)); // 输出 false</span>
<span class="line"></span>
<span class="line">// 查找元素：使用迭代器的方式查找陈清扬</span>
<span class="line">// 使用迭代器依次遍历元素并查找</span>
<span class="line">Iterator&lt;String&gt; iterator = queue.iterator();</span>
<span class="line">while (iterator.hasNext()) {</span>
<span class="line">    String element = iterator.next();</span>
<span class="line">    if (element.equals(&quot;陈清扬&quot;)) {</span>
<span class="line">        System.out.println(&quot;找到了：&quot; + element);</span>
<span class="line">        break;</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1673]||(s[1673]=[n("在使用 LinkedList 作为队列时，可以使用 offer() 方法将元素添加到队列的末尾，使用 poll() 方法从队列的头部删除元素，使用迭代器或者 poll() 方法依次遍历元素。")])),_:1}),a("h3",pl,[a("a",ol,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1674]||(s[1674]=[n("栈和队列")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1675]||(s[1675]=[n("要讲栈和队列，首先要讲")])),_:1}),s[3317]||(s[3317]=n("_")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1676]||(s[1676]=[n("Deque")])),_:1}),s[3318]||(s[3318]=n("_")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1677]||(s[1677]=[n("接口。")])),_:1}),s[3319]||(s[3319]=n("_")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1678]||(s[1678]=[n("Deque")])),_:1}),s[3320]||(s[3320]=n("_")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1679]||(s[1679]=[n("的含义是“double ended queue”，即双端队列，它既可以当作栈使用，也可以当作队列使用。下表列出了")])),_:1}),s[3321]||(s[3321]=n("_")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1680]||(s[1680]=[n("Deque")])),_:1}),s[3322]||(s[3322]=n("_")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1681]||(s[1681]=[n("与")])),_:1}),s[3323]||(s[3323]=n("_")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1682]||(s[1682]=[n("Queue")])),_:1}),s[3324]||(s[3324]=n("_")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1683]||(s[1683]=[n("相对应的接口：")])),_:1}),a("table",null,[a("thead",null,[a("tr",null,[a("th",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1684]||(s[1684]=[n("Queue Method")])),_:1})]),a("th",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1685]||(s[1685]=[n("Equivalent Deque Method")])),_:1})]),a("th",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1686]||(s[1686]=[n("说明")])),_:1})])])]),a("tbody",null,[a("tr",null,[a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1687]||(s[1687]=[n("add(e)")])),_:1})]),a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1688]||(s[1688]=[n("addLast(e)")])),_:1})]),a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1689]||(s[1689]=[n("向队尾插入元素，失败则抛出异常")])),_:1})])]),a("tr",null,[a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1690]||(s[1690]=[n("offer(e)")])),_:1})]),a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1691]||(s[1691]=[n("offerLast(e)")])),_:1})]),a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1692]||(s[1692]=[n("向队尾插入元素，失败则返回")])),_:1}),s[1693]||(s[1693]=a("code",null,'<font style="color:rgb(44, 62, 80);">false</font>',-1))])]),a("tr",null,[a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1694]||(s[1694]=[n("remove()")])),_:1})]),a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1695]||(s[1695]=[n("removeFirst()")])),_:1})]),a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1696]||(s[1696]=[n("获取并删除队首元素，失败则抛出异常")])),_:1})])]),a("tr",null,[a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1697]||(s[1697]=[n("poll()")])),_:1})]),a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1698]||(s[1698]=[n("pollFirst()")])),_:1})]),a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1699]||(s[1699]=[n("获取并删除队首元素，失败则返回")])),_:1}),s[1700]||(s[1700]=a("code",null,'<font style="color:rgb(44, 62, 80);">null</font>',-1))])]),a("tr",null,[a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1701]||(s[1701]=[n("element()")])),_:1})]),a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1702]||(s[1702]=[n("getFirst()")])),_:1})]),a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1703]||(s[1703]=[n("获取但不删除队首元素，失败则抛出异常")])),_:1})])]),a("tr",null,[a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1704]||(s[1704]=[n("peek()")])),_:1})]),a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1705]||(s[1705]=[n("peekFirst()")])),_:1})]),a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1706]||(s[1706]=[n("获取但不删除队首元素，失败则返回")])),_:1}),s[1707]||(s[1707]=a("code",null,'<font style="color:rgb(44, 62, 80);">null</font>',-1))])])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1708]||(s[1708]=[n("下表列出了")])),_:1}),s[3325]||(s[3325]=n("_")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1709]||(s[1709]=[n("Deque")])),_:1}),s[3326]||(s[3326]=n("_")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1710]||(s[1710]=[n("与")])),_:1}),s[3327]||(s[3327]=n("_")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1711]||(s[1711]=[n("Stack")])),_:1}),s[3328]||(s[3328]=n("_")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1712]||(s[1712]=[n("对应的接口：")])),_:1}),a("table",null,[a("thead",null,[a("tr",null,[a("th",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1713]||(s[1713]=[n("Stack Method")])),_:1})]),a("th",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1714]||(s[1714]=[n("Equivalent Deque Method")])),_:1})]),a("th",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1715]||(s[1715]=[n("说明")])),_:1})])])]),a("tbody",null,[a("tr",null,[a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1716]||(s[1716]=[n("push(e)")])),_:1})]),a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1717]||(s[1717]=[n("addFirst(e)")])),_:1})]),a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1718]||(s[1718]=[n("向栈顶插入元素，失败则抛出异常")])),_:1})])]),a("tr",null,[a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1719]||(s[1719]=[n("无")])),_:1})]),a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1720]||(s[1720]=[n("offerFirst(e)")])),_:1})]),a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1721]||(s[1721]=[n("向栈顶插入元素，失败则返回")])),_:1}),s[1722]||(s[1722]=a("code",null,'<font style="color:rgb(44, 62, 80);">false</font>',-1))])]),a("tr",null,[a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1723]||(s[1723]=[n("pop()")])),_:1})]),a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1724]||(s[1724]=[n("removeFirst()")])),_:1})]),a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1725]||(s[1725]=[n("获取并删除栈顶元素，失败则抛出异常")])),_:1})])]),a("tr",null,[a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1726]||(s[1726]=[n("无")])),_:1})]),a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1727]||(s[1727]=[n("pollFirst()")])),_:1})]),a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1728]||(s[1728]=[n("获取并删除栈顶元素，失败则返回")])),_:1}),s[1729]||(s[1729]=a("code",null,'<font style="color:rgb(44, 62, 80);">null</font>',-1))])]),a("tr",null,[a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1730]||(s[1730]=[n("peek()")])),_:1})]),a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1731]||(s[1731]=[n("getFirst()")])),_:1})]),a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1732]||(s[1732]=[n("获取但不删除栈顶元素，失败则抛出异常")])),_:1})])]),a("tr",null,[a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1733]||(s[1733]=[n("无")])),_:1})]),a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1734]||(s[1734]=[n("peekFirst()")])),_:1})]),a("td",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1735]||(s[1735]=[n("获取但不删除栈顶元素，失败则返回")])),_:1}),s[1736]||(s[1736]=a("code",null,'<font style="color:rgb(44, 62, 80);">null</font>',-1))])])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1737]||(s[1737]=[n("上面两个表共定义了")])),_:1}),s[3329]||(s[3329]=n("_")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1738]||(s[1738]=[n("Deque")])),_:1}),s[3330]||(s[3330]=n("_")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1739]||(s[1739]=[n("的 12 个接口。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1740]||(s[1740]=[n("添加，删除，取值都有两套接口，它们功能相同，区别是对失败情况的处理不同。")])),_:1}),a("p",null,[a("strong",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1741]||(s[1741]=[n("一套接口遇到失败就会抛出异常，另一套遇到失败会返回特殊值（")])),_:1})]),s[1745]||(s[1745]=a("code",null,'**<font style="color:rgb(44, 62, 80);">false</font>**',-1)),a("strong",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1742]||(s[1742]=[n("或")])),_:1})]),s[1746]||(s[1746]=a("code",null,'**<font style="color:rgb(44, 62, 80);">null</font>**',-1)),a("strong",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1743]||(s[1743]=[n("）")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1744]||(s[1744]=[n("。除非某种实现对容量有限制，大多数情况下，添加操作是不会失败的。")])),_:1})]),a("p",null,[a("strong",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1747]||(s[1747]=[n("虽然")])),_:1})]),a("em",null,[a("strong",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1748]||(s[1748]=[n("Deque")])),_:1})])]),a("strong",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1749]||(s[1749]=[n("的接口有 12 个之多，但无非就是对容器的两端进行操作，或添加，或删除，或查看")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1750]||(s[1750]=[n("。明白了这一点讲解起来就会非常简单。")])),_:1})]),a("p",null,[a("em",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1751]||(s[1751]=[n("ArrayDeque")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1752]||(s[1752]=[n("和")])),_:1}),a("em",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1753]||(s[1753]=[n("LinkedList")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1754]||(s[1754]=[n("是")])),_:1}),a("em",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1755]||(s[1755]=[n("Deque")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1756]||(s[1756]=[n("的两个通用实现，由于官方更推荐使用")])),_:1}),a("em",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1757]||(s[1757]=[n("ArrayDeque")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1758]||(s[1758]=[n("用作栈和队列，加之上一篇已经讲解过")])),_:1}),a("a",ul,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1759]||(s[1759]=[n("LinkedList")])),_:1}),l(r)]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1760]||(s[1760]=[n("，本文将着重讲解")])),_:1}),a("em",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1761]||(s[1761]=[n("ArrayDeque")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1762]||(s[1762]=[n("的具体实现。")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1763]||(s[1763]=[n("从名字可以看出")])),_:1}),s[3331]||(s[3331]=n("_")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1764]||(s[1764]=[n("ArrayDeque")])),_:1}),s[3332]||(s[3332]=n("_")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1765]||(s[1765]=[n("底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即")])),_:1}),s[3333]||(s[3333]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1766]||(s[1766]=[n("循环数组（circular array）")])),_:1}),s[3334]||(s[3334]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1767]||(s[1767]=[n("，也就是说数组的任何一点都可能被看作起点或者终点。")])),_:1}),a("p",null,[a("em",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1768]||(s[1768]=[n("ArrayDeque")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1769]||(s[1769]=[n("是非线程安全的（not thread-safe），当多个线程同时使用的时候，需要手动同步；另外，该容器不允许放入")])),_:1}),s[1771]||(s[1771]=a("code",null,'<font style="color:rgb(44, 62, 80);">null</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1770]||(s[1770]=[n("元素。")])),_:1})]),s[3335]||(s[3335]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726668480195-c11fe70f-2751-4043-88b5-d5a3714db12d.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1772]||(s[1772]=[n("上图中我们看到，")])),_:1}),s[3336]||(s[3336]=n("`**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1773]||(s[1773]=[n("head")])),_:1}),s[3337]||(s[3337]=n("**`**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1774]||(s[1774]=[n("指向首端第一个有效元素，")])),_:1}),s[3338]||(s[3338]=n("**`**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1775]||(s[1775]=[n("tail")])),_:1}),s[3339]||(s[3339]=n("**`**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1776]||(s[1776]=[n("指向尾端第一个可以插入元素的空位")])),_:1}),s[3340]||(s[3340]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1777]||(s[1777]=[n("。因为是循环数组，所以")])),_:1}),s[3341]||(s[3341]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1778]||(s[1778]=[n("head")])),_:1}),s[3342]||(s[3342]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1779]||(s[1779]=[n("不一定总等于 0，")])),_:1}),s[3343]||(s[3343]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1780]||(s[1780]=[n("tail")])),_:1}),s[3344]||(s[3344]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1781]||(s[1781]=[n("也不一定总是比")])),_:1}),s[3345]||(s[3345]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1782]||(s[1782]=[n("head")])),_:1}),s[3346]||(s[3346]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1783]||(s[1783]=[n("大。")])),_:1}),a("h3",vl,[a("a",bl,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1784]||(s[1784]=[n("方法剖析")])),_:1})])])]),a("h4",ml,[a("a",gl,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1785]||(s[1785]=[n("addFirst()")])),_:1})])])]),a("p",null,[s[1791]||(s[1791]=a("code",null,'<font style="color:rgb(44, 62, 80);">addFirst(E e)</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1786]||(s[1786]=[n("的作用是在")])),_:1}),a("em",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1787]||(s[1787]=[n("Deque")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1788]||(s[1788]=[n("的首端插入元素，也就是在")])),_:1}),s[1792]||(s[1792]=a("code",null,'<font style="color:rgb(44, 62, 80);">head</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1789]||(s[1789]=[n("的前面插入元素，在空间足够且下标没有越界的情况下，只需要将")])),_:1}),s[1793]||(s[1793]=a("code",null,'<font style="color:rgb(44, 62, 80);">elements[--head] = e</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1790]||(s[1790]=[n("即可。")])),_:1})]),s[3347]||(s[3347]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726668479766-7d580989-f25c-4d2c-a1f3-ddbee3b1059c.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1794]||(s[1794]=[n("实际需要考虑：")])),_:1}),a("ol",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1795]||(s[1795]=[n("空间是否够用，以及")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1796]||(s[1796]=[n("下标是否越界的问题。")])),_:1})])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1797]||(s[1797]=[n("上图中，如果")])),_:1}),s[3348]||(s[3348]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1798]||(s[1798]=[n("head")])),_:1}),s[3349]||(s[3349]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1799]||(s[1799]=[n("为")])),_:1}),s[3350]||(s[3350]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1800]||(s[1800]=[n("0")])),_:1}),s[3351]||(s[3351]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1801]||(s[1801]=[n("之后接着调用")])),_:1}),s[3352]||(s[3352]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1802]||(s[1802]=[n("addFirst()")])),_:1}),s[3353]||(s[3353]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1803]||(s[1803]=[n("，虽然空余空间还够用，但")])),_:1}),s[3354]||(s[3354]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1804]||(s[1804]=[n("head")])),_:1}),s[3355]||(s[3355]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1805]||(s[1805]=[n("为")])),_:1}),s[3356]||(s[3356]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1806]||(s[1806]=[n("-1")])),_:1}),s[3357]||(s[3357]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1807]||(s[1807]=[n("，下标越界了。下列代码很好的解决了这两个问题。")])),_:1}),s[3358]||(s[3358]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">//addFirst(E e)</span>
<span class="line">public void addFirst(E e) {</span>
<span class="line">    if (e == null)//不允许放入null</span>
<span class="line">        throw new NullPointerException();</span>
<span class="line">    elements[head = (head - 1) &amp; (elements.length - 1)] = e;//2.下标是否越界</span>
<span class="line">    if (head == tail)//1.空间是否够用</span>
<span class="line">        doubleCapacity();//扩容</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1808]||(s[1808]=[n("上述代码我们看到，")])),_:1}),s[3359]||(s[3359]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1809]||(s[1809]=[n("空间问题是在插入之后解决的")])),_:1}),s[3360]||(s[3360]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1810]||(s[1810]=[n("，因为")])),_:1}),s[3361]||(s[3361]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1811]||(s[1811]=[n("tail")])),_:1}),s[3362]||(s[3362]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1812]||(s[1812]=[n("总是指向下一个可插入的空位，也就意味着")])),_:1}),s[3363]||(s[3363]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1813]||(s[1813]=[n("elements")])),_:1}),s[3364]||(s[3364]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1814]||(s[1814]=[n("数组至少有一个空位，所以插入元素的时候不用考虑空间问题。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1815]||(s[1815]=[n("下标越界的处理解决起来非常简单，")])),_:1}),s[3365]||(s[3365]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1816]||(s[1816]=[n("head = (head - 1) & (elements.length - 1)")])),_:1}),s[3366]||(s[3366]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1817]||(s[1817]=[n("就可以了，")])),_:1}),s[3367]||(s[3367]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1818]||(s[1818]=[n("这段代码相当于取余，同时解决了")])),_:1}),s[3368]||(s[3368]=n("**`**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1819]||(s[1819]=[n("head")])),_:1}),s[3369]||(s[3369]=n("**`**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1820]||(s[1820]=[n("为负值的情况")])),_:1}),s[3370]||(s[3370]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1821]||(s[1821]=[n("。因为")])),_:1}),s[3371]||(s[3371]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1822]||(s[1822]=[n("elements.length")])),_:1}),s[3372]||(s[3372]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1823]||(s[1823]=[n("必需是")])),_:1}),s[3373]||(s[3373]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1824]||(s[1824]=[n("2")])),_:1}),s[3374]||(s[3374]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1825]||(s[1825]=[n("的指数倍，")])),_:1}),s[3375]||(s[3375]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1826]||(s[1826]=[n("elements - 1")])),_:1}),s[3376]||(s[3376]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1827]||(s[1827]=[n("就是二进制低位全")])),_:1}),s[3377]||(s[3377]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1828]||(s[1828]=[n("1")])),_:1}),s[3378]||(s[3378]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1829]||(s[1829]=[n("，跟")])),_:1}),s[3379]||(s[3379]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1830]||(s[1830]=[n("head - 1")])),_:1}),s[3380]||(s[3380]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1831]||(s[1831]=[n("相与之后就起到了取模的作用，如果")])),_:1}),s[3381]||(s[3381]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1832]||(s[1832]=[n("head - 1")])),_:1}),s[3382]||(s[3382]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1833]||(s[1833]=[n("为负数（其实只可能是-1），则相当于对其取相对于")])),_:1}),s[3383]||(s[3383]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1834]||(s[1834]=[n("elements.length")])),_:1}),s[3384]||(s[3384]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1835]||(s[1835]=[n("的补码。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1836]||(s[1836]=[n("下面再说说扩容函数")])),_:1}),s[3385]||(s[3385]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1837]||(s[1837]=[n("doubleCapacity()")])),_:1}),s[3386]||(s[3386]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1838]||(s[1838]=[n("，其逻辑是申请一个更大的数组（原数组的两倍），然后将原数组复制过去。过程如下图所示：")])),_:1}),s[3387]||(s[3387]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726668480134-9e5b1d69-1af2-44af-89de-159f63a59457.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1839]||(s[1839]=[n("图中我们看到，复制分两次进行，第一次复制")])),_:1}),s[3388]||(s[3388]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1840]||(s[1840]=[n("head")])),_:1}),s[3389]||(s[3389]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1841]||(s[1841]=[n("右边的元素，第二次复制")])),_:1}),s[3390]||(s[3390]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1842]||(s[1842]=[n("head")])),_:1}),s[3391]||(s[3391]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1843]||(s[1843]=[n("左边的元素。")])),_:1}),s[3392]||(s[3392]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">//doubleCapacity()</span>
<span class="line">private void doubleCapacity() {</span>
<span class="line">    assert head == tail;</span>
<span class="line">    int p = head;</span>
<span class="line">    int n = elements.length;</span>
<span class="line">    int r = n - p; // head右边元素的个数</span>
<span class="line">    int newCapacity = n &lt;&lt; 1;//原空间的2倍</span>
<span class="line">    if (newCapacity &lt; 0)</span>
<span class="line">        throw new IllegalStateException(&quot;Sorry, deque too big&quot;);</span>
<span class="line">    Object[] a = new Object[newCapacity];</span>
<span class="line">    System.arraycopy(elements, p, a, 0, r);//复制右半部分，对应上图中绿色部分</span>
<span class="line">    System.arraycopy(elements, 0, a, r, p);//复制左半部分，对应上图中灰色部分</span>
<span class="line">    elements = (E[])a;</span>
<span class="line">    head = 0;</span>
<span class="line">    tail = n;</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1844]||(s[1844]=[n("该方法的实现中，首先检查 head 和 tail 是否相等，如果不相等则抛出异常。然后计算出 head 右边的元素个数 r，以及新的容量 newCapacity，如果 newCapacity 太大则抛出异常。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1845]||(s[1845]=[n("接下来创建一个新的 Object 数组 a，将原有 ArrayDeque 中 head 右边的元素复制到 a 的前面（即图中绿色部分），将 head 左边的元素复制到 a 的后面（即图中灰色部分）。最后将 elements 数组替换为 a，head 设置为 0，tail 设置为 n（即新容量的长度）。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1846]||(s[1846]=[n("需要注意的是，由于 elements 数组被替换为 a 数组，因此在方法调用结束后，原有的 elements 数组将不再被引用，会被垃圾回收器回收。")])),_:1}),a("h4",yl,[a("a",fl,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1847]||(s[1847]=[n("addLast()")])),_:1})])])]),a("p",null,[s[1855]||(s[1855]=a("code",null,'<font style="color:rgb(44, 62, 80);">addLast(E e)</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1848]||(s[1848]=[n("的作用是在")])),_:1}),a("em",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1849]||(s[1849]=[n("Deque")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1850]||(s[1850]=[n("的尾端插入元素，也就是在")])),_:1}),s[1856]||(s[1856]=a("code",null,'<font style="color:rgb(44, 62, 80);">tail</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1851]||(s[1851]=[n("的位置插入元素，由于")])),_:1}),s[1857]||(s[1857]=a("code",null,'<font style="color:rgb(44, 62, 80);">tail</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1852]||(s[1852]=[n("总是指向下一个可以插入的空位，因此只需要")])),_:1}),s[1858]||(s[1858]=a("code",null,'<font style="color:rgb(44, 62, 80);">elements[tail] = e;</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1853]||(s[1853]=[n("即可。插入完成后再检查空间，如果空间已经用光，则调用")])),_:1}),s[1859]||(s[1859]=a("code",null,'<font style="color:rgb(44, 62, 80);">doubleCapacity()</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1854]||(s[1854]=[n("进行扩容。")])),_:1})]),s[3393]||(s[3393]=t(`<img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2024/png/35376129/1726668479754-96c7520a-17ab-430b-8a47-03d3c1adf4a7.png"><div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public void addLast(E e) {</span>
<span class="line">    if (e == null)//不允许放入null</span>
<span class="line">        throw new NullPointerException();</span>
<span class="line">    elements[tail] = e;//赋值</span>
<span class="line">    if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head)//下标越界处理</span>
<span class="line">        doubleCapacity();//扩容</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,2)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1860]||(s[1860]=[n("下标越界处理方式")])),_:1}),s[3394]||(s[3394]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1861]||(s[1861]=[n("addFirt()")])),_:1}),s[3395]||(s[3395]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1862]||(s[1862]=[n("中已经讲过，不再赘述。")])),_:1}),a("h4",kl,[a("a",cl,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1863]||(s[1863]=[n("pollFirst()")])),_:1})])])]),a("p",null,[s[1872]||(s[1872]=a("code",null,'<font style="color:rgb(44, 62, 80);">pollFirst()</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1864]||(s[1864]=[n("的作用是删除并返回")])),_:1}),a("em",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1865]||(s[1865]=[n("Deque")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1866]||(s[1866]=[n("首端元素，也即是")])),_:1}),s[1873]||(s[1873]=a("code",null,'<font style="color:rgb(44, 62, 80);">head</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1867]||(s[1867]=[n("位置处的元素。如果容器不空，只需要直接返回")])),_:1}),s[1874]||(s[1874]=a("code",null,'<font style="color:rgb(44, 62, 80);">elements[head]</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1868]||(s[1868]=[n("即可，当然还需要处理下标的问题。由于")])),_:1}),s[1875]||(s[1875]=a("code",null,'<font style="color:rgb(44, 62, 80);">ArrayDeque</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1869]||(s[1869]=[n("中不允许放入")])),_:1}),s[1876]||(s[1876]=a("code",null,'<font style="color:rgb(44, 62, 80);">null</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1870]||(s[1870]=[n("，当")])),_:1}),s[1877]||(s[1877]=a("code",null,'<font style="color:rgb(44, 62, 80);">elements[head] == null</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1871]||(s[1871]=[n("时，意味着容器为空。")])),_:1})]),s[3396]||(s[3396]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public E pollFirst() {</span>
<span class="line">    E result = elements[head];</span>
<span class="line">    if (result == null)//null值意味着deque为空</span>
<span class="line">        return null;</span>
<span class="line">    elements[h] = null;//let GC work</span>
<span class="line">    head = (head + 1) &amp; (elements.length - 1);//下标越界处理</span>
<span class="line">    return result;</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),a("h4",ql,[a("a",xl,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1878]||(s[1878]=[n("pollLast()")])),_:1})])])]),a("p",null,[s[1883]||(s[1883]=a("code",null,'<font style="color:rgb(44, 62, 80);">pollLast()</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1879]||(s[1879]=[n("的作用是删除并返回")])),_:1}),a("em",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1880]||(s[1880]=[n("Deque")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1881]||(s[1881]=[n("尾端元素，也即是")])),_:1}),s[1884]||(s[1884]=a("code",null,'<font style="color:rgb(44, 62, 80);">tail</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1882]||(s[1882]=[n("位置前面的那个元素。")])),_:1})]),s[3397]||(s[3397]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public E pollLast() {</span>
<span class="line">    int t = (tail - 1) &amp; (elements.length - 1);//tail的上一个位置是最后一个元素</span>
<span class="line">    E result = elements[t];</span>
<span class="line">    if (result == null)//null值意味着deque为空</span>
<span class="line">        return null;</span>
<span class="line">    elements[t] = null;//let GC work</span>
<span class="line">    tail = t;</span>
<span class="line">    return result;</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),a("h4",Ll,[a("a",Ml,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1885]||(s[1885]=[n("peekFirst()")])),_:1})])])]),a("p",null,[s[1891]||(s[1891]=a("code",null,'<font style="color:rgb(44, 62, 80);">peekFirst()</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1886]||(s[1886]=[n("的作用是返回但不删除")])),_:1}),a("em",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1887]||(s[1887]=[n("Deque")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1888]||(s[1888]=[n("首端元素，也即是")])),_:1}),s[1892]||(s[1892]=a("code",null,'<font style="color:rgb(44, 62, 80);">head</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1889]||(s[1889]=[n("位置处的元素，直接返回")])),_:1}),s[1893]||(s[1893]=a("code",null,'<font style="color:rgb(44, 62, 80);">elements[head]</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1890]||(s[1890]=[n("即可。")])),_:1})]),s[3398]||(s[3398]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public E peekFirst() {</span>
<span class="line">    return elements[head]; // elements[head] is null if deque empty</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),a("h4",wl,[a("a",Cl,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1894]||(s[1894]=[n("peekLast()")])),_:1})])])]),a("p",null,[s[1899]||(s[1899]=a("code",null,'<font style="color:rgb(44, 62, 80);">peekLast()</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1895]||(s[1895]=[n("的作用是返回但不删除")])),_:1}),a("em",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1896]||(s[1896]=[n("Deque")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1897]||(s[1897]=[n("尾端元素，也即是")])),_:1}),s[1900]||(s[1900]=a("code",null,'<font style="color:rgb(44, 62, 80);">tail</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1898]||(s[1898]=[n("位置前面的那个元素。")])),_:1})]),s[3399]||(s[3399]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public E peekLast() {</span>
<span class="line">    return elements[(tail - 1) &amp; (elements.length - 1)];</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),a("h3",Sl,[a("a",Al,[a("span",null,[a("a",El,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1901]||(s[1901]=[n("小结")])),_:1}),l(r)])])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1902]||(s[1902]=[n("当需要实现先进先出(FIFO)或者先进后出(LIFO)的数据结构时，可以考虑使用 ArrayDeque。以下是一些使用 ArrayDeque 的场景：")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1903]||(s[1903]=[n("管理任务队列：如果需要实现一个任务队列，可以使用 ArrayDeque 来存储任务元素。在队列头部添加新任务元素，从队列尾部取出任务进行处理，可以保证任务按照先进先出的顺序执行。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1904]||(s[1904]=[n("实现栈：ArrayDeque 可以作为栈的实现方式，支持 push、pop、peek 等操作，可以用于需要后进先出的场景。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1905]||(s[1905]=[n("实现缓存：在需要缓存一定数量的数据时，可以使用 ArrayDeque。当缓存的数据量超过容量时，可以从队列头部删除最老的数据，从队列尾部添加新的数据。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1906]||(s[1906]=[n("实现事件处理器：ArrayDeque 可以作为事件处理器的实现方式，支持从队列头部获取事件进行处理，从队列尾部添加新的事件。")])),_:1})])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1907]||(s[1907]=[n("简单总结一下吧。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1908]||(s[1908]=[n("ArrayDeque 是 Java 标准库中的一种双端队列实现，底层基于数组实现。与 LinkedList 相比，ArrayDeque 的性能更优，因为它使用连续的内存空间存储元素，可以更好地利用 CPU 缓存，在大多数情况下也更快。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1909]||(s[1909]=[n("为什么这么说呢？")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1910]||(s[1910]=[n("因为ArrayDeque 的底层实现是数组，而 LinkedList 的底层实现是链表。数组是一段连续的内存空间，而链表是由多个节点组成的，每个节点存储数据和指向下一个节点的指针。因此，在使用 LinkedList 时，需要频繁进行内存分配和释放，而 ArrayDeque 在创建时就一次性分配了连续的内存空间，不需要频繁进行内存分配和释放，这样可以更好地利用 CPU 缓存，提高访问效率。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1911]||(s[1911]=[n("现代计算机CPU对于数据的局部性有很强的依赖，如果需要访问的数据在内存中是连续存储的，那么就可以利用CPU的缓存机制，提高访问效率。而当数据存储在不同的内存块里时，每次访问都需要从内存中读取，效率会受到影响。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1912]||(s[1912]=[n("当然了，使用 ArrayDeque 时，数组复制操作也是需要考虑的性能消耗之一。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1913]||(s[1913]=[n("当 ArrayDeque 的元素数量超过了初始容量时，会触发扩容操作。扩容操作会创建一个新的数组，并将原有元素复制到新数组中。扩容操作的时间复杂度为 O(n)。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1914]||(s[1914]=[n("不过，ArrayDeque 的扩容策略（当 ArrayDeque 中的元素数量达到数组容量时，就需要进行扩容操作，扩容时会将数组容量扩大为原来的两倍）可以在一定程度上减少数组复制的次数和时间消耗，同时保证 ArrayDeque 的性能和空间利用率。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1915]||(s[1915]=[n("ArrayDeque 不仅支持常见的队列操作，如添加元素、删除元素、获取队列头部元素、获取队列尾部元素等。同时，它还支持栈操作，如 push、pop、peek 等。这使得 ArrayDeque 成为一种非常灵活的数据结构，可以用于各种场景的数据存储和处理。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}}),a("h2",jl,[a("a",Il,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1916]||(s[1916]=[n("优先队列 PriorityQueue")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1917]||(s[1917]=[n("PriorityQueue 是 Java 中的一个基于优先级堆的优先队列实现，它能够在 O(log n) 的时间复杂度内实现元素的插入和删除操作，并且能够自动维护队列中元素的优先级顺序。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1918]||(s[1918]=[n("通俗来说，PriorityQueue 就是一个队列，但是它不是先进先出的，而是按照元素优先级进行排序的。当你往 PriorityQueue 中插入一个元素时，它会自动根据元素的优先级将其插入到合适的位置。当你从 PriorityQueue 中删除一个元素时，它会自动将优先级最高的元素出队。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1919]||(s[1919]=[n("下面")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1920]||(s[1920]=[n("👇🏻")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1921]||(s[1921]=[n("是一个简单的PriorityQueue示例：")])),_:1}),s[3400]||(s[3400]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">// 创建 PriorityQueue 对象</span>
<span class="line">PriorityQueue&lt;String&gt; priorityQueue = new PriorityQueue&lt;&gt;();</span>
<span class="line"></span>
<span class="line">// 添加元素到 PriorityQueue</span>
<span class="line">priorityQueue.offer(&quot;沉默王二&quot;);</span>
<span class="line">priorityQueue.offer(&quot;陈清扬&quot;);</span>
<span class="line">priorityQueue.offer(&quot;小转铃&quot;);</span>
<span class="line"></span>
<span class="line">// 打印 PriorityQueue 中的元素</span>
<span class="line">System.out.println(&quot;PriorityQueue 中的元素：&quot;);</span>
<span class="line">while (!priorityQueue.isEmpty()) {</span>
<span class="line">    System.out.print(priorityQueue.poll() + &quot; &quot;);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1922]||(s[1922]=[n("在上述代码中，我们首先创建了一个 PriorityQueue 对象，并向其中添加了三个元素。然后，我们使用 while 循环遍历 PriorityQueue 中的元素，并打印出来。来看输出结果：")])),_:1}),s[3401]||(s[3401]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">PriorityQueue 中的元素：</span>
<span class="line">小转铃 沉默王二 陈清扬</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1923]||(s[1923]=[n("再来看一下示例。")])),_:1}),s[3402]||(s[3402]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">// 创建 PriorityQueue 对象，并指定优先级顺序</span>
<span class="line">PriorityQueue&lt;String&gt; priorityQueue = new PriorityQueue&lt;&gt;(Comparator.reverseOrder());</span>
<span class="line"></span>
<span class="line">// 添加元素到 PriorityQueue</span>
<span class="line">priorityQueue.offer(&quot;沉默王二&quot;);</span>
<span class="line">priorityQueue.offer(&quot;陈清扬&quot;);</span>
<span class="line">priorityQueue.offer(&quot;小转铃&quot;);</span>
<span class="line"></span>
<span class="line">// 打印 PriorityQueue 中的元素</span>
<span class="line">System.out.println(&quot;PriorityQueue 中的元素：&quot;);</span>
<span class="line">while (!priorityQueue.isEmpty()) {</span>
<span class="line">    System.out.print(priorityQueue.poll() + &quot; &quot;);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1924]||(s[1924]=[n("在上述代码中，我们使用了 Comparator.reverseOrder() 方法指定了 PriorityQueue 的优先级顺序为降序。也就是说，PriorityQueue 中的元素会按照从大到小的顺序排序。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1925]||(s[1925]=[n("其他部分的代码与之前的例子相同，我们再来看一下输出结果：")])),_:1}),s[3403]||(s[3403]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">PriorityQueue 中的元素：</span>
<span class="line">陈清扬 沉默王二 小转铃</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1926]||(s[1926]=[n("对比一下两个例子的输出结果，不难发现，顺序正好相反。")])),_:1}),a("h3",Hl,[a("a",Tl,[a("span",null,[a("a",Dl,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1927]||(s[1927]=[n("PriorityQueue的作用")])),_:1}),l(r)])])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1928]||(s[1928]=[n("PriorityQueue 的主要作用是维护一组数据的排序，使得取出数据时可以按照一定的优先级顺序进行，当我们调用 poll() 方法时，它会从队列的顶部弹出最高优先级的元素。它在很多场景下都有广泛的应用，例如任务调度、事件处理等场景，以及一些算法中需要对数据进行排序的场景。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1929]||(s[1929]=[n("在实际应用中，PriorityQueue 也经常用于实现 Dijkstra 算法、Prim 算法、Huffman 编码等算法。这里简单说一下这几种算法的作用，理解不了也没关系哈。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1930]||(s[1930]=[n("Dijkstra算法是一种用于计算带权图中的最短路径的算法。该算法采用贪心的策略，在遍历图的过程中，每次选取当前到源点距离最短的一个顶点，并以它为中心进行扩展，更新其他顶点的距离值。经过多次扩展，可以得到源点到其它所有顶点的最短路径。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1931]||(s[1931]=[n("Prim算法是一种用于求解最小生成树的算法，可以在加权连通图中找到一棵生成树，使得这棵生成树的所有边的权值之和最小。该算法从任意一个顶点开始，逐渐扩展生成树的规模，每次选择一个距离已生成树最近的顶点加入到生成树中。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1932]||(s[1932]=[n("Huffman编码是一种基于霍夫曼树的压缩算法，用于将一个字符串转换为二进制编码以进行压缩。该算法的主要思想是通过建立霍夫曼树，将出现频率较高的字符用较短的编码表示，而出现频率较低的字符用较长的编码表示，从而实现对字符串的压缩。在解压缩时，根据编码逐步解析出原字符串。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1933]||(s[1933]=[n("由于 PriorityQueue 的底层是基于堆实现的，因此在数据量比较大时，使用 PriorityQueue 可以获得较好的时间复杂度。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1934]||(s[1934]=[n("这里牵涉到了大小关系，")])),_:1}),s[3404]||(s[3404]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1935]||(s[1935]=[n("元素大小的评判可以通过元素本身的自然顺序（")])),_:1}),s[3405]||(s[3405]=n("**_**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1936]||(s[1936]=[n("natural ordering")])),_:1}),s[3406]||(s[3406]=n("**_**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1937]||(s[1937]=[n("），也可以通过构造时传入的比较器")])),_:1}),s[3407]||(s[3407]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1938]||(s[1938]=[n("（")])),_:1}),s[3408]||(s[3408]=n("_")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1939]||(s[1939]=[n("Comparator")])),_:1}),s[3409]||(s[3409]=n("_")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1940]||(s[1940]=[n("，或者元素自身实现 Comparable 接口）来决定。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1941]||(s[1941]=[n("在 PriorityQueue 中，每个元素都有一个优先级，这个优先级决定了元素在队列中的位置。队列内部通过小顶堆（也可以是大顶堆）的方式来维护元素的优先级关系。具体来说，小顶堆是一个完全二叉树，任何一个非叶子节点的权值，都不大于其左右子节点的权值，这样保证了队列的顶部元素（堆顶）一定是优先级最高的元素。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1942]||(s[1942]=[n("完全二叉树（Complete Binary Tree）是一种二叉树，其中除了最后一层，其他层的节点数都是满的，最后一层的节点都靠左对齐。下面是一个完全二叉树的示意图：")])),_:1}),s[3410]||(s[3410]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">        1</span>
<span class="line">      /   \\</span>
<span class="line">     2     3</span>
<span class="line">    / \\   /</span>
<span class="line">   4   5 6</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1943]||(s[1943]=[n("堆是一种完全二叉树，堆的特点是根节点的值最小（小顶堆）或最大（大顶堆），并且任意非根节点i的值都不大于（或不小于）其父节点的值。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1944]||(s[1944]=[n("这是一颗包含整数 1, 2, 3, 4, 5, 6, 7 的小顶堆：")])),_:1}),s[3411]||(s[3411]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">      1</span>
<span class="line">     / \\</span>
<span class="line">    2   3</span>
<span class="line">   / \\ / \\</span>
<span class="line">  4  5 6  7</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1945]||(s[1945]=[n("这是一颗大顶堆。")])),_:1}),s[3412]||(s[3412]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">            8</span>
<span class="line">          /   \\</span>
<span class="line">         7     5</span>
<span class="line">        / \\   / \\</span>
<span class="line">       6   4 2   1</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1946]||(s[1946]=[n("因为完全二叉树的结构比较规则，所以可以使用数组来存储堆的元素，而不需要使用指针等额外的空间。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1947]||(s[1947]=[n("在堆中，每个节点的下标和其在数组中的下标是一一对应的，假设节点下标为i，则其父节点下标为i/2，其左子节点下标为2i，其右子节点下标为2i+1。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1948]||(s[1948]=[n("假设有一个数组arr=[10, 20, 15, 30, 40]，现在要将其转化为一个小顶堆。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1949]||(s[1949]=[n("首先，我们将数组按照完全二叉树的形式排列，如下图所示：")])),_:1}),s[3413]||(s[3413]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">10</span>
<span class="line">     /  \\</span>
<span class="line">   20    15</span>
<span class="line">  /  \\</span>
<span class="line">30   40</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1950]||(s[1950]=[n("从上往下、从左往右依次给每个节点编号，如下所示：")])),_:1}),s[3414]||(s[3414]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">1</span>
<span class="line">     / \\</span>
<span class="line">    2   3</span>
<span class="line">   / \\</span>
<span class="line">  4   5</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1951]||(s[1951]=[n("接下来，我们按照上述公式，依次确定每个节点在数组中的位置。例如，节点1的父节点下标为1/2=0，左子节点下标为2*1=2，右子节点下标为2*1+1=3，因此节点1在数组中的位置为0，节点2在数组中的位置为2，节点3在数组中的位置为3。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1952]||(s[1952]=[n("对应的数组为[10, 20, 15, 30, 40]，符合小顶堆的定义，即每个节点的值都小于或等于其子节点的值。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1953]||(s[1953]=[n("好，我们画幅图再来理解一下。")])),_:1}),s[3415]||(s[3415]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726668513861-e74cb5f3-8a89-4ee5-bffa-22c9b35b41f7.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1954]||(s[1954]=[n("上图中我们给每个元素按照层序遍历的方式进行了编号，如果你足够细心，会发现父节点和子节点的编号是有联系的，更确切的说父子节点的编号之间有如下关系：")])),_:1}),s[3416]||(s[3416]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">leftNo = parentNo\\*2+1</span>
<span class="line">rightNo = parentNo\\*2+2</span>
<span class="line">parentNo = (nodeNo-1)/2</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1955]||(s[1955]=[n("通过上述三个公式，可以轻易计算出某个节点的父节点以及子节点的下标。这也就是为什么可以直接用数组来存储堆的原因。")])),_:1}),a("h3",Nl,[a("a",Ol,[a("span",null,[a("a",zl,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1956]||(s[1956]=[n("方法剖析")])),_:1}),l(r)])])])]),a("h4",Vl,[a("a",Pl,[a("span",null,[a("a",Fl,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1957]||(s[1957]=[n("add()和 offer()")])),_:1}),l(r)])])])]),a("p",null,[s[1964]||(s[1964]=a("code",null,'<font style="color:rgb(44, 62, 80);">add(E e)</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1958]||(s[1958]=[n("和")])),_:1}),s[1965]||(s[1965]=a("code",null,'<font style="color:rgb(44, 62, 80);">offer(E e)</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1959]||(s[1959]=[n("的语义相同，都是向优先队列中插入元素，只是")])),_:1}),s[1966]||(s[1966]=a("code",null,'<font style="color:rgb(44, 62, 80);">Queue</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1960]||(s[1960]=[n("接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回")])),_:1}),s[1967]||(s[1967]=a("code",null,'<font style="color:rgb(44, 62, 80);">false</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1961]||(s[1961]=[n("。对于")])),_:1}),a("em",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1962]||(s[1962]=[n("PriorityQueue")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1963]||(s[1963]=[n("这两个方法其实没什么差别。")])),_:1})]),s[3417]||(s[3417]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726668512395-92a0efd2-7c1d-468e-ab99-fa93a36f5eb5.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1968]||(s[1968]=[n("新加入的元素可能会破坏小顶堆的性质，因此需要进行必要的调整。")])),_:1}),s[3418]||(s[3418]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">//offer(E e)</span>
<span class="line">public boolean offer(E e) {</span>
<span class="line">    if (e == null)//不允许放入null元素</span>
<span class="line">        throw new NullPointerException();</span>
<span class="line">    modCount++;</span>
<span class="line">    int i = size;</span>
<span class="line">    if (i &gt;= queue.length)</span>
<span class="line">        grow(i + 1);//自动扩容</span>
<span class="line">    size = i + 1;</span>
<span class="line">    if (i == 0)//队列原来为空，这是插入的第一个元素</span>
<span class="line">        queue[0] = e;</span>
<span class="line">    else</span>
<span class="line">        siftUp(i, e);//调整</span>
<span class="line">    return true;</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1969]||(s[1969]=[n("上述代码中，扩容函数")])),_:1}),s[3419]||(s[3419]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1970]||(s[1970]=[n("grow()")])),_:1}),s[3420]||(s[3420]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1971]||(s[1971]=[n("类似于")])),_:1}),s[3421]||(s[3421]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1972]||(s[1972]=[n("ArrayList")])),_:1}),s[3422]||(s[3422]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1973]||(s[1973]=[n("里的")])),_:1}),s[3423]||(s[3423]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1974]||(s[1974]=[n("grow()")])),_:1}),s[3424]||(s[3424]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1975]||(s[1975]=[n("函数，就是再申请一个更大的数组，并将原数组的元素复制过去，这里不再赘述。需要注意的是")])),_:1}),s[3425]||(s[3425]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1976]||(s[1976]=[n("siftUp(int k, E x)")])),_:1}),s[3426]||(s[3426]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1977]||(s[1977]=[n("方法，该方法用于插入元素")])),_:1}),s[3427]||(s[3427]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1978]||(s[1978]=[n("x")])),_:1}),s[3428]||(s[3428]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1979]||(s[1979]=[n("并维持堆的特性。")])),_:1}),s[3429]||(s[3429]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">//siftUp()</span>
<span class="line">private void siftUp(int k, E x) {</span>
<span class="line">    while (k &gt; 0) {</span>
<span class="line">        int parent = (k - 1) &gt;&gt;&gt; 1;//parentNo = (nodeNo-1)/2</span>
<span class="line">        Object e = queue[parent];</span>
<span class="line">        if (comparator.compare(x, (E) e) &gt;= 0)//调用比较器的比较方法</span>
<span class="line">            break;</span>
<span class="line">        queue[k] = e;</span>
<span class="line">        k = parent;</span>
<span class="line">    }</span>
<span class="line">    queue[k] = x;</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1980]||(s[1980]=[n("调整的过程为：")])),_:1}),s[3430]||(s[3430]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1981]||(s[1981]=[n("从")])),_:1}),s[3431]||(s[3431]=n("**`**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1982]||(s[1982]=[n("k")])),_:1}),s[3432]||(s[3432]=n("**`**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1983]||(s[1983]=[n("指定的位置开始，将")])),_:1}),s[3433]||(s[3433]=n("**`**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1984]||(s[1984]=[n("x")])),_:1}),s[3434]||(s[3434]=n("**`**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1985]||(s[1985]=[n("逐层与当前点的")])),_:1}),s[3435]||(s[3435]=n("**`**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1986]||(s[1986]=[n("parent")])),_:1}),s[3436]||(s[3436]=n("**`**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1987]||(s[1987]=[n("进行比较并交换，直到满足")])),_:1}),s[3437]||(s[3437]=n("**`**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1988]||(s[1988]=[n("x >= queue[parent]")])),_:1}),s[3438]||(s[3438]=n("**`**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1989]||(s[1989]=[n("为止")])),_:1}),s[3439]||(s[3439]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1990]||(s[1990]=[n("。注意这里的比较可以是元素的自然顺序，也可以是依靠比较器的顺序。")])),_:1}),a("h4",Kl,[a("a",Rl,[a("span",null,[a("a",Bl,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1991]||(s[1991]=[n("element()和 peek()")])),_:1}),l(r)])])])]),a("p",null,[s[1999]||(s[1999]=a("code",null,'<font style="color:rgb(44, 62, 80);">element()</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1992]||(s[1992]=[n("和")])),_:1}),s[2e3]||(s[2e3]=a("code",null,'<font style="color:rgb(44, 62, 80);">peek()</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1993]||(s[1993]=[n("的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回")])),_:1}),s[2001]||(s[2001]=a("code",null,'<font style="color:rgb(44, 62, 80);">null</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1994]||(s[1994]=[n("。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，")])),_:1}),s[2002]||(s[2002]=a("code",null,'<font style="color:rgb(44, 62, 80);">0</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1995]||(s[1995]=[n("下标处的那个元素既是堆顶元素。所以")])),_:1}),a("strong",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1996]||(s[1996]=[n("直接返回数组")])),_:1})]),s[2003]||(s[2003]=a("code",null,'**<font style="color:rgb(44, 62, 80);">0</font>**',-1)),a("strong",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1997]||(s[1997]=[n("下标处的那个元素即可")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[1998]||(s[1998]=[n("。")])),_:1})]),s[3440]||(s[3440]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726668512169-a2c1feb4-1012-4f54-a200-4397704ac7c0.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2004]||(s[2004]=[n("代码也就非常简洁：")])),_:1}),s[3441]||(s[3441]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">//peek()</span>
<span class="line">public E peek() {</span>
<span class="line">    if (size == 0)</span>
<span class="line">        return null;</span>
<span class="line">    return (E) queue[0];//0下标处的那个元素就是最小的那个</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),a("h4",Ql,[a("a",Ul,[a("span",null,[a("a",Jl,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2005]||(s[2005]=[n("remove()和 poll()")])),_:1}),l(r)])])])]),a("p",null,[s[2009]||(s[2009]=a("code",null,'<font style="color:rgb(44, 62, 80);">remove()</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2006]||(s[2006]=[n("和")])),_:1}),s[2010]||(s[2010]=a("code",null,'<font style="color:rgb(44, 62, 80);">poll()</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2007]||(s[2007]=[n("方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回")])),_:1}),s[2011]||(s[2011]=a("code",null,'<font style="color:rgb(44, 62, 80);">null</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2008]||(s[2008]=[n("。由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。")])),_:1})]),s[3442]||(s[3442]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726668513799-571599eb-febb-4e7a-adee-8de7704a7c76.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2012]||(s[2012]=[n("PriorityQueue_poll.png")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2013]||(s[2013]=[n("代码如下：")])),_:1}),s[3443]||(s[3443]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public E poll() {</span>
<span class="line">    if (size == 0)</span>
<span class="line">        return null;</span>
<span class="line">    int s = --size;</span>
<span class="line">    modCount++;</span>
<span class="line">    E result = (E) queue[0];//0下标处的那个元素就是最小的那个</span>
<span class="line">    E x = (E) queue[s];</span>
<span class="line">    queue[s] = null;</span>
<span class="line">    if (s != 0)</span>
<span class="line">        siftDown(0, x);//调整</span>
<span class="line">    return result;</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2014]||(s[2014]=[n("上述代码首先记录")])),_:1}),s[3444]||(s[3444]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2015]||(s[2015]=[n("0")])),_:1}),s[3445]||(s[3445]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2016]||(s[2016]=[n("下标处的元素，并用最后一个元素替换")])),_:1}),s[3446]||(s[3446]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2017]||(s[2017]=[n("0")])),_:1}),s[3447]||(s[3447]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2018]||(s[2018]=[n("下标位置的元素，之后调用")])),_:1}),s[3448]||(s[3448]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2019]||(s[2019]=[n("siftDown()")])),_:1}),s[3449]||(s[3449]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2020]||(s[2020]=[n("方法对堆进行调整，最后返回原来")])),_:1}),s[3450]||(s[3450]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2021]||(s[2021]=[n("0")])),_:1}),s[3451]||(s[3451]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2022]||(s[2022]=[n("下标处的那个元素（也就是最小的那个元素）。重点是")])),_:1}),s[3452]||(s[3452]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2023]||(s[2023]=[n("siftDown(int k, E x)")])),_:1}),s[3453]||(s[3453]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2024]||(s[2024]=[n("方法，该方法的作用是")])),_:1}),s[3454]||(s[3454]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2025]||(s[2025]=[n("从")])),_:1}),s[3455]||(s[3455]=n("**`**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2026]||(s[2026]=[n("k")])),_:1}),s[3456]||(s[3456]=n("**`**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2027]||(s[2027]=[n("指定的位置开始，将")])),_:1}),s[3457]||(s[3457]=n("**`**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2028]||(s[2028]=[n("x")])),_:1}),s[3458]||(s[3458]=n("**`**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2029]||(s[2029]=[n("逐层向下与当前点的左右孩子中较小的那个交换，直到")])),_:1}),s[3459]||(s[3459]=n("**`**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2030]||(s[2030]=[n("x")])),_:1}),s[3460]||(s[3460]=n("**`**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2031]||(s[2031]=[n("小于或等于左右孩子中的任何一个为止")])),_:1}),s[3461]||(s[3461]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2032]||(s[2032]=[n("。")])),_:1}),s[3462]||(s[3462]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">//siftDown()</span>
<span class="line">private void siftDown(int k, E x) {</span>
<span class="line">    int half = size &gt;&gt;&gt; 1;</span>
<span class="line">    while (k &lt; half) {</span>
<span class="line">      //首先找到左右孩子中较小的那个，记录到c里，并用child记录其下标</span>
<span class="line">        int child = (k &lt;&lt; 1) + 1;//leftNo = parentNo*2+1</span>
<span class="line">        Object c = queue[child];</span>
<span class="line">        int right = child + 1;</span>
<span class="line">        if (right &lt; size &amp;&amp;</span>
<span class="line">            comparator.compare((E) c, (E) queue[right]) &gt; 0)</span>
<span class="line">            c = queue[child = right];</span>
<span class="line">        if (comparator.compare(x, (E) c) &lt;= 0)</span>
<span class="line">            break;</span>
<span class="line">        queue[k] = c;//然后用c取代原来的值</span>
<span class="line">        k = child;</span>
<span class="line">    }</span>
<span class="line">    queue[k] = x;</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),a("h4",Yl,[a("a",$l,[a("span",null,[a("a",Wl,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2033]||(s[2033]=[n("remove(Object o)")])),_:1}),l(r)])])])]),a("p",null,[s[2040]||(s[2040]=a("code",null,'<font style="color:rgb(44, 62, 80);">remove(Object o)</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2034]||(s[2034]=[n("方法用于删除队列中跟")])),_:1}),s[2041]||(s[2041]=a("code",null,'<font style="color:rgb(44, 62, 80);">o</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2035]||(s[2035]=[n("相等的某一个元素（如果有多个相等，只删除一个），该方法不是")])),_:1}),a("em",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2036]||(s[2036]=[n("Queue")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2037]||(s[2037]=[n("接口内的方法，而是")])),_:1}),a("em",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2038]||(s[2038]=[n("Collection")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2039]||(s[2039]=[n("接口的方法。由于删除操作会改变队列结构，所以要进行调整；又由于删除元素的位置可能是任意的，所以调整过程比其它方法稍加繁琐。")])),_:1})]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2042]||(s[2042]=[n("具体来说，")])),_:1}),s[3463]||(s[3463]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2043]||(s[2043]=[n("remove(Object o)")])),_:1}),s[3464]||(s[3464]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2044]||(s[2044]=[n("可以分为 2 种情况：")])),_:1}),a("ol",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2045]||(s[2045]=[n("删除的是最后一个元素。直接删除即可，不需要调整。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2046]||(s[2046]=[n("删除的不是最后一个元素，从删除点开始以最后一个元素为参照调用一次")])),_:1}),s[2049]||(s[2049]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2047]||(s[2047]=[n("siftDown()")])),_:1}),s[2050]||(s[2050]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2048]||(s[2048]=[n("即可。此处不再赘述。")])),_:1})])]),s[3465]||(s[3465]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726668513553-7343d786-ac22-4d73-b30b-5832abd279d8.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2051]||(s[2051]=[n("具体代码如下：")])),_:1}),s[3466]||(s[3466]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">//remove(Object o)</span>
<span class="line">public boolean remove(Object o) {</span>
<span class="line">  //通过遍历数组的方式找到第一个满足o.equals(queue[i])元素的下标</span>
<span class="line">    int i = indexOf(o);</span>
<span class="line">    if (i == -1)</span>
<span class="line">        return false;</span>
<span class="line">    int s = --size;</span>
<span class="line">    if (s == i) //情况1</span>
<span class="line">        queue[i] = null;</span>
<span class="line">    else {</span>
<span class="line">        E moved = (E) queue[s];</span>
<span class="line">        queue[s] = null;</span>
<span class="line">        siftDown(i, moved);//情况2</span>
<span class="line">        ......</span>
<span class="line">    }</span>
<span class="line">    return true;</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),a("h3",Xl,[a("a",Gl,[a("span",null,[a("a",Zl,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2052]||(s[2052]=[n("小结")])),_:1}),l(r)])])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2053]||(s[2053]=[n("PriorityQueue 是一个非常常用的数据结构，它是一种特殊的堆（Heap）实现，可以用来高效地维护一个有序的集合。")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2054]||(s[2054]=[n("它的底层实现是一个数组，通过堆的性质来维护元素的顺序。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2055]||(s[2055]=[n("取出元素时按照优先级顺序（从小到大或者从大到小）进行取出。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2056]||(s[2056]=[n("如果需要指定排序，元素必须实现 Comparable 接口或者传入一个 Comparator 来进行比较。")])),_:1})])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2057]||(s[2057]=[n("可以通过 LeetCode 的第 23 题：")])),_:1}),s[3467]||(s[3467]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2058]||(s[2058]=[n("合并K个升序链表")])),_:1}),s[3468]||(s[3468]=n("](https://leetcode-cn.com/problems/merge-k-sorted-lists/)")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2059]||(s[2059]=[n("来练习 PriorityQueue 的使用。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2060]||(s[2060]=[n("我把题解已经放到了技术派中，大家可以去作为参考。")])),_:1}),a("p",null,[a("a",hl,[s[2061]||(s[2061]=n("023.合并 K 个升序链表，通过优先级队列和最小堆优雅解决")),l(r)])]),l(e,{style:{color:"rgb(44, 62, 80)"}}),a("h2",_l,[a("a",se,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2062]||(s[2062]=[n("ArrayList 和 LinkedList 区别")])),_:1})])])]),a("h3",ne,[a("a",le,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2063]||(s[2063]=[n("ArrayList 是如何实现的？")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2064]||(s[2064]=[n("ArrayList 实现了 List 接口，继承了 AbstractList 抽象类。")])),_:1}),s[3469]||(s[3469]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726671668219-03ce28e6-a654-4358-b371-714c2b3cc1e2.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2065]||(s[2065]=[n("底层是基于数组实现的，并且实现了动态扩容（当需要添加新元素时，如果 elementData 数组已满，则会自动扩容，新的容量将是原来的 1.5 倍），来看一下 ArrayList 的部分源码。")])),_:1}),s[3470]||(s[3470]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span>
<span class="line">        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span>
<span class="line">{</span>
<span class="line">    private static final int DEFAULT_CAPACITY = 10; // 默认容量为 10</span>
<span class="line">    transient Object[] elementData; // 存储元素的数组，数组类型为 Object</span>
<span class="line">    private int size; // 列表的大小，即列表中元素的个数</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2066]||(s[2066]=[n("ArrayList 还实现了 RandomAccess 接口，这是一个标记接口：")])),_:1}),s[3471]||(s[3471]=t(`<div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token comment">// RandomAccess是一个标记接口，官方解释是只要List实现这个接口，就能支持快速随机访问。</span></span>
<span class="line"><span class="token comment">// 而什么是随机访问呢？接下来我们来举例说明</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">RandomAccess</span> <span class="token punctuation">{</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2067]||(s[2067]=[n("内部是空的，标记“实现了这个接口的类支持快速（通常是固定时间）随机访问”。快速随机访问是什么意思呢？就是说不需要遍历，就可以通过下标（索引）直接访问到内存地址。而 LinkedList 没有实现该接口，表示它不支持高效的随机访问，需要通过遍历来访问元素。")])),_:1}),s[3472]||(s[3472]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">/**</span>
<span class="line"> * 返回列表中指定位置的元素。</span>
<span class="line"> *</span>
<span class="line"> * @param index 要返回的元素的索引</span>
<span class="line"> * @return 列表中指定位置的元素</span>
<span class="line"> * @throws IndexOutOfBoundsException 如果索引越界（index &lt; 0 || index &gt;= size()）</span>
<span class="line"> */</span>
<span class="line">public E get(int index) {</span>
<span class="line">    Objects.checkIndex(index, size); // 检查索引是否越界</span>
<span class="line">    return elementData(index); // 调用 elementData 方法获取元素</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">/**</span>
<span class="line"> * 返回列表中指定位置的元素。</span>
<span class="line"> * 注意：该方法并没有检查索引是否越界，调用该方法前需要先检查索引是否越界。</span>
<span class="line"> *</span>
<span class="line"> * @param index 要返回的元素的索引</span>
<span class="line"> * @return 列表中指定位置的元素</span>
<span class="line"> */</span>
<span class="line">E elementData(int index) {</span>
<span class="line">    return (E) elementData[index]; // 强制类型转换，将 Object 类型转换为 E 类型</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2068]||(s[2068]=[n("ArrayList 还实现了 Cloneable 接口，这表明 ArrayList 是支持")])),_:1}),s[3473]||(s[3473]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2069]||(s[2069]=[n("拷贝")])),_:1}),s[3474]||(s[3474]=n("](https://javabetter.cn/basic-extra-meal/deep-copy.html)")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2070]||(s[2070]=[n("的。ArrayList 内部的确也重写了 Object 类的")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3475]||(s[3475]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2071]||(s[2071]=[n("clone()")])),_:1}),s[3476]||(s[3476]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2072]||(s[2072]=[n("方法。")])),_:1}),s[3477]||(s[3477]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">/**</span>
<span class="line"> * 返回该列表的浅表副本。</span>
<span class="line"> * （元素本身不会被复制。）</span>
<span class="line"> *</span>
<span class="line"> * @return 该列表的副本</span>
<span class="line"> */</span>
<span class="line">public Object clone() {</span>
<span class="line">    try {</span>
<span class="line">        ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone(); // 调用 Object 类的 clone 方法，得到一个浅表副本</span>
<span class="line">        v.elementData = Arrays.copyOf(elementData, size); // 复制 elementData 数组，创建一个新数组作为副本</span>
<span class="line">        v.modCount = 0; // 将 modCount 置为 0</span>
<span class="line">        return v; // 返回副本</span>
<span class="line">    } catch (CloneNotSupportedException e) {</span>
<span class="line">        // this shouldn&#39;t happen, since we are Cloneable</span>
<span class="line">        throw new InternalError(e);</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2073]||(s[2073]=[n("ArrayList 还实现了")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3478]||(s[3478]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2074]||(s[2074]=[n("Serializable")])),_:1}),s[3479]||(s[3479]=n("](https://javabetter.cn/io/Serializbale.html)")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2075]||(s[2075]=[n("接口，同样是一个标记接口：")])),_:1}),s[3480]||(s[3480]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public interface Serializable {</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2076]||(s[2076]=[n("内部也是空的，标记“实现了这个接口的类支持序列化”。序列化是什么意思呢？Java 的序列化是指，将对象转换成以字节序列的形式来表示，这些字节序中包含了对象的字段和方法。序列化后的对象可以被写到数据库、写到文件，也可用于网络传输。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2077]||(s[2077]=[n("眼睛雪亮的小伙伴可能会注意到，ArrayList 中的关键字段 elementData 使用了")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3481]||(s[3481]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2078]||(s[2078]=[n("transient 关键字")])),_:1}),s[3482]||(s[3482]=n("](https://javabetter.cn/io/transient.html)")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2079]||(s[2079]=[n("修饰，这个关键字的作用是，让它修饰的字段不被序列化。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2080]||(s[2080]=[n("这不前后矛盾吗？一个类既然实现了 Serilizable 接口，肯定是想要被序列化的，对吧？那为什么保存关键数据的 elementData 又不想被序列化呢?")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2081]||(s[2081]=[n("这还得从 “ArrayList 是基于数组实现的”开始说起。大家都知道，数组是定长的，就是说，数组一旦声明了，长度（容量）就是固定的，不能像某些东西一样伸缩自如。这就很麻烦，数组一旦装满了，就不能添加新的元素进来了。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2082]||(s[2082]=[n("ArrayList 不想像数组这样活着，它想能屈能伸，所以它实现了动态扩容。一旦在添加元素的时候，发现容量用满了")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3483]||(s[3483]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2083]||(s[2083]=[n("s == elementData.length")])),_:1}),s[3484]||(s[3484]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2084]||(s[2084]=[n("，就按照原来数组的 1.5 倍（")])),_:1}),s[3485]||(s[3485]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2085]||(s[2085]=[n("oldCapacity >> 1")])),_:1}),s[3486]||(s[3486]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2086]||(s[2086]=[n("）进行扩容。扩容之后，再将原有的数组复制到新分配的内存地址上")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3487]||(s[3487]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2087]||(s[2087]=[n("Arrays.copyOf(elementData, newCapacity)")])),_:1}),s[3488]||(s[3488]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2088]||(s[2088]=[n("。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2089]||(s[2089]=[n("这部分源码我们在之前讲")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3489]||(s[3489]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2090]||(s[2090]=[n("ArrayList")])),_:1}),s[3490]||(s[3490]=n("](https://javabetter.cn/collection/arraylist.html)")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2091]||(s[2091]=[n("的时候就已经讲的很清楚了，这里就一笔带过。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2092]||(s[2092]=[n("动态扩容意味着什么？")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2093]||(s[2093]=[n("意味着数组的实际大小可能永远无法被填满的，总有多余出来空置的内存空间。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2094]||(s[2094]=[n("比如说，默认的数组大小是 10，当添加第 11 个元素的时候，数组的长度扩容了 1.5 倍，也就是 15，意味着还有 4 个内存空间是闲置的，对吧？")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2095]||(s[2095]=[n("序列化的时候，如果把整个数组都序列化的话，是不是就多序列化了 4 个内存空间。当存储的元素数量非常非常多的时候，闲置的空间就非常非常大，序列化耗费的时间就会非常非常多。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2096]||(s[2096]=[n("于是，ArrayList 做了一个愉快而又聪明的决定，内部提供了两个私有方法 writeObject 和 readObject 来完成序列化和反序列化。")])),_:1}),s[3491]||(s[3491]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">/**</span>
<span class="line"> * 将此列表实例的状态序列写入指定的 ObjectOutputStream。</span>
<span class="line"> * （即，保存这个列表实例到一个流中。）</span>
<span class="line"> *</span>
<span class="line"> * @param s 要写入的流</span>
<span class="line"> * @throws java.io.IOException 如果写入流时发生异常</span>
<span class="line"> */</span>
<span class="line">private void writeObject(java.io.ObjectOutputStream s)</span>
<span class="line">        throws java.io.IOException {</span>
<span class="line">    s.defaultWriteObject(); // 写出对象的默认字段</span>
<span class="line">    // Write out size as capacity for behavioral compatibility with clone()</span>
<span class="line">    s.writeInt(size); // 写出 size</span>
<span class="line">    // Write out all elements in the proper order.</span>
<span class="line">    for (int i=0; i&lt;size; i++) {</span>
<span class="line">        s.writeObject(elementData[i]); // 依次写出 elementData 数组中的元素</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2097]||(s[2097]=[n("从 writeObject 方法的源码中可以看得出，它使用了 ArrayList 的实际大小 size 而不是数组的长度（")])),_:1}),s[3492]||(s[3492]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2098]||(s[2098]=[n("elementData.length")])),_:1}),s[3493]||(s[3493]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2099]||(s[2099]=[n("）来作为元素的上限进行序列化。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2100]||(s[2100]=[n("此处应该有掌声啊！不是为我，为 Java 源码的作者们，他们真的是太厉害了，可以用两个词来形容他们——殚精竭虑、精益求精。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2101]||(s[2101]=[n("这是readObject方法的源码：")])),_:1}),s[3494]||(s[3494]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">/**</span>
<span class="line"> * 从指定的 ObjectInputStream 中读取此列表实例的状态序列。</span>
<span class="line"> * （即，从流中恢复这个列表实例。）</span>
<span class="line"> *</span>
<span class="line"> * @param s 从中读取此列表实例的状态序列的流</span>
<span class="line"> * @throws java.io.IOException 如果读取流时发生异常</span>
<span class="line"> * @throws ClassNotFoundException 如果在读取流时找不到类</span>
<span class="line"> */</span>
<span class="line">private void readObject(java.io.ObjectInputStream s)</span>
<span class="line">        throws java.io.IOException, ClassNotFoundException {</span>
<span class="line">    elementData = EMPTY_ELEMENTDATA; // 初始化 elementData 数组为空数组</span>
<span class="line"></span>
<span class="line">    // 读取默认字段</span>
<span class="line">    s.defaultReadObject();</span>
<span class="line"></span>
<span class="line">    // 读取容量，这个值被忽略，因为在 ArrayList 中，容量和长度是两个不同的概念</span>
<span class="line">    s.readInt();</span>
<span class="line"></span>
<span class="line">    if (size &gt; 0) {</span>
<span class="line">        // 分配一个新的 elementData 数组，大小为 size</span>
<span class="line">        ensureCapacityInternal(size);</span>
<span class="line"></span>
<span class="line">        Object[] a = elementData;</span>
<span class="line">        // 依次从输入流中读取元素，并将其存储在数组中</span>
<span class="line">        for (int i=0; i&lt;size; i++) {</span>
<span class="line">            a[i] = s.readObject(); // 读取对象并存储在 elementData 数组中</span>
<span class="line">        }</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),a("h3",ee,[a("a",ie,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2102]||(s[2102]=[n("LinkedList 是如何实现的？")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2103]||(s[2103]=[n("LinkedList 是一个继承自 AbstractSequentialList 的双向链表，因此它也可以被当作堆栈、队列或双端队列进行操作。")])),_:1}),s[3495]||(s[3495]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726671667982-09221819-3aae-47d7-b98b-5d79c12f7394.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2104]||(s[2104]=[n("来看一下部分源码：")])),_:1}),s[3496]||(s[3496]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public class LinkedList&lt;E&gt;</span>
<span class="line">    extends AbstractSequentialList&lt;E&gt;</span>
<span class="line">    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span>
<span class="line">{</span>
<span class="line">    transient int size = 0; // 非序列化字段，表示链表中的节点个数</span>
<span class="line">    transient Node&lt;E&gt; first; // 非序列化字段，指向链表中的第一个节点</span>
<span class="line">    transient Node&lt;E&gt; last; // 非序列化字段，指向链表中的最后一个节点</span>
<span class="line"></span>
<span class="line">    // ...</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2105]||(s[2105]=[n("LinkedList 内部定义了一个 Node 节点，它包含 3 个部分：元素内容 item，前引用 prev 和后引用 next。这个在讲")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3497]||(s[3497]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2106]||(s[2106]=[n("LinkedList")])),_:1}),s[3498]||(s[3498]=n("](https://javabetter.cn/collection/linkedlist.html)")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2107]||(s[2107]=[n("的时候也讲过了，这里略过。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2108]||(s[2108]=[n("LinkedList 还实现了 Cloneable 接口，这表明 LinkedList 是支持拷贝的。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2109]||(s[2109]=[n("LinkedList 还实现了 Serializable 接口，这表明 LinkedList 是支持序列化的。眼睛雪亮的小伙伴可能又注意到了，LinkedList 中的关键字段 size、first、last 都使用了 transient 关键字修饰，这不又矛盾了吗？到底是想序列化还是不想序列化？")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2110]||(s[2110]=[n("答案是 LinkedList 想按照自己的方式序列化，来看它自己实现的")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3499]||(s[3499]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2111]||(s[2111]=[n("writeObject()")])),_:1}),s[3500]||(s[3500]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2112]||(s[2112]=[n("方法：")])),_:1}),s[3501]||(s[3501]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">private void writeObject(java.io.ObjectOutputStream s)</span>
<span class="line">        throws java.io.IOException {</span>
<span class="line">    // 写入默认的序列化标记</span>
<span class="line">    s.defaultWriteObject();</span>
<span class="line"></span>
<span class="line">    // 写入链表的节点个数</span>
<span class="line">    s.writeInt(size);</span>
<span class="line"></span>
<span class="line">    // 按正确的顺序写入所有元素</span>
<span class="line">    for (LinkedList.Node&lt;E&gt; x = first; x != null; x = x.next)</span>
<span class="line">        s.writeObject(x.item);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2113]||(s[2113]=[n("发现没？LinkedList 在序列化的时候只保留了元素的内容 item，并没有保留元素的前后引用。这样就节省了不少内存空间，对吧？")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2114]||(s[2114]=[n("那有些小伙伴可能就疑惑了，只保留元素内容，不保留前后引用，那反序列化的时候怎么办？")])),_:1}),s[3502]||(s[3502]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">private void readObject(java.io.ObjectInputStream s)</span>
<span class="line">        throws java.io.IOException, ClassNotFoundException {</span>
<span class="line">    // 读取默认的序列化标记</span>
<span class="line">    s.defaultReadObject();</span>
<span class="line"></span>
<span class="line">    // 读取链表的节点个数</span>
<span class="line">    int size = s.readInt();</span>
<span class="line"></span>
<span class="line">    // 按正确的顺序读取所有元素</span>
<span class="line">    for (int i = 0; i &lt; size; i++)</span>
<span class="line">        linkLast((E)s.readObject()); // 读取元素并将其添加到链表末尾</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">void linkLast(E e) {</span>
<span class="line">    final LinkedList.Node&lt;E&gt; l = last;</span>
<span class="line">    final LinkedList.Node&lt;E&gt; newNode = new LinkedList.Node&lt;&gt;(l, e, null);</span>
<span class="line">    last = newNode; // 将新节点作为链表尾节点</span>
<span class="line">    if (l == null)</span>
<span class="line">        first = newNode; // 如果链表为空，将新节点作为链表头节点</span>
<span class="line">    else</span>
<span class="line">        l.next = newNode; // 否则将新节点链接到链表尾部</span>
<span class="line">    size++; // 增加节点个数</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2115]||(s[2115]=[n("注意 for 循环中的")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3503]||(s[3503]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2116]||(s[2116]=[n("linkLast()")])),_:1}),s[3504]||(s[3504]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2117]||(s[2117]=[n("方法，它可以把链表重新链接起来，这样就恢复了链表序列化之前的顺序。很妙，对吧？")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2118]||(s[2118]=[n("和 ArrayList 相比，LinkedList 没有实现 RandomAccess 接口，这是因为 LinkedList 存储数据的内存地址是不连续的，所以不支持随机访问。")])),_:1}),a("h3",ae,[a("a",te,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2119]||(s[2119]=[n("新增元素时究竟谁快？")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2120]||(s[2120]=[n("前面我们已经从多个维度了解了 ArrayList 和 LinkedList 的实现原理和各自的特点。那接下来，我们就来聊聊 ArrayList 和 LinkedList 在新增元素时究竟谁快？")])),_:1}),a("h4",re,[a("a",de,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2121]||(s[2121]=[n("ArrayList")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2122]||(s[2122]=[n("ArrayList 新增元素有两种情况，一种是直接将元素添加到数组末尾，一种是将元素插入到指定位置。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2123]||(s[2123]=[n("添加到数组末尾的源码（这部分前面讲")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3505]||(s[3505]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2124]||(s[2124]=[n("ArrayList")])),_:1}),s[3506]||(s[3506]=n("](https://javabetter.cn/collection/arraylist.html)")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2125]||(s[2125]=[n("的时候讲过了，这里再温故一下）：")])),_:1}),s[3507]||(s[3507]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public boolean add(E e) {</span>
<span class="line">    add(e, elementData, size);</span>
<span class="line">    return true;</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">private void add(E e, Object[] elementData, int s) {</span>
<span class="line">    if (s == elementData.length)</span>
<span class="line">        elementData = grow(); // 扩容数组</span>
<span class="line">    elementData[s] = e; // 将元素添加到数组末尾</span>
<span class="line">    size = s + 1; // 增加元素个数</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2126]||(s[2126]=[n("很简单，先判断是否需要扩容，然后直接通过索引将元素添加到末尾。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2127]||(s[2127]=[n("插入到指定位置的源码：")])),_:1}),s[3508]||(s[3508]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public void add(int index, E element) {</span>
<span class="line">    rangeCheckForAdd(index); // 检查插入位置是否越界</span>
<span class="line">    final int s; // 当前元素个数</span>
<span class="line">    Object[] elementData; // 元素数组</span>
<span class="line">    if ((s = size) == (elementData = this.elementData).length) // 如果数组已满，则扩容</span>
<span class="line">        elementData = grow();</span>
<span class="line">    System.arraycopy(elementData, index,</span>
<span class="line">            elementData, index + 1,</span>
<span class="line">            s - index); // 将插入位置后的元素向右移动一位</span>
<span class="line">    elementData[index] = element; // 将新元素插入到指定位置</span>
<span class="line">    size = s + 1; // 增加元素个数</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2128]||(s[2128]=[n("先检查插入的位置是否在合理的范围之内，然后判断是否需要扩容，再把该位置以后的元素复制到新添加元素的位置之后，最后通过索引将元素添加到指定的位置。")])),_:1}),a("h4",pe,[a("a",oe,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2129]||(s[2129]=[n("LinkedList")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2130]||(s[2130]=[n("LinkedList 新增元素也有两种情况，一种是直接将元素添加到队尾，一种是将元素插入到指定位置。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2131]||(s[2131]=[n("添加到队尾的源码：")])),_:1}),s[3509]||(s[3509]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public boolean add(E e) {</span>
<span class="line">    linkLast(e); // 将元素添加到链表末尾</span>
<span class="line">    return true;</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">void linkLast(E e) {</span>
<span class="line">    final LinkedList.Node&lt;E&gt; l = last; // 获取链表的尾节点</span>
<span class="line">    final LinkedList.Node&lt;E&gt; newNode = new LinkedList.Node&lt;&gt;(l, e, null); // 创建新节点</span>
<span class="line">    last = newNode; // 将新节点作为链表的尾节点</span>
<span class="line">    if (l == null)</span>
<span class="line">        first = newNode; // 如果链表为空，则将新节点作为链表的头节点</span>
<span class="line">    else</span>
<span class="line">        l.next = newNode; // 否则将新节点链接到链表的尾部</span>
<span class="line">    size++; // 增加节点个数</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2132]||(s[2132]=[n("先将队尾的节点 last 存放到临时变量 l 中，然后生成新的 Node 节点，并赋给 last，如果 l 为 null，说明是第一次添加，所以 first 为新的节点；否则将新的节点赋给之前 last 的 next。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2133]||(s[2133]=[n("插入到指定位置的源码：")])),_:1}),s[3510]||(s[3510]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public void add(int index, E element) {</span>
<span class="line">    checkPositionIndex(index); // 检查插入位置是否越界</span>
<span class="line"></span>
<span class="line">    if (index == size)</span>
<span class="line">        linkLast(element); // 如果插入位置为链表末尾，则将元素添加到链表末尾</span>
<span class="line">    else</span>
<span class="line">        linkBefore(element, node(index)); // 否则将元素插入到指定位置的前面的节点后面</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">LinkedList.Node&lt;E&gt; node(int index) {</span>
<span class="line">    if (index &lt; (size &gt;&gt; 1)) { // 如果插入位置在链表前半部分，则从头节点开始查找</span>
<span class="line">        LinkedList.Node&lt;E&gt; x = first;</span>
<span class="line">        for (int i = 0; i &lt; index; i++)</span>
<span class="line">            x = x.next;</span>
<span class="line">        return x;</span>
<span class="line">    } else { // 否则从尾节点开始查找</span>
<span class="line">        LinkedList.Node&lt;E&gt; x = last;</span>
<span class="line">        for (int i = size - 1; i &gt; index; i--)</span>
<span class="line">            x = x.prev;</span>
<span class="line">        return x;</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">void linkBefore(E e, LinkedList.Node&lt;E&gt; succ) {</span>
<span class="line">    final LinkedList.Node&lt;E&gt; pred = succ.prev; // 获取插入位置的前驱节点</span>
<span class="line">    final LinkedList.Node&lt;E&gt; newNode = new LinkedList.Node&lt;&gt;(pred, e, succ); // 创建新节点</span>
<span class="line">    succ.prev = newNode; // 将新节点链接到后继节点</span>
<span class="line">    if (pred == null)</span>
<span class="line">        first = newNode; // 如果前驱节点为空，则将新节点作为头节点</span>
<span class="line">    else</span>
<span class="line">        pred.next = newNode; // 否则将新节点链接到前驱节点</span>
<span class="line">    size++; // 增加节点个数</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2134]||(s[2134]=[n("先检查插入的位置是否在合理的范围之内，然后判断插入的位置是否是队尾，如果是，添加到队尾；否则执行")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3511]||(s[3511]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2135]||(s[2135]=[n("linkBefore()")])),_:1}),s[3512]||(s[3512]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2136]||(s[2136]=[n("方法。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2137]||(s[2137]=[n("在执行")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3513]||(s[3513]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2138]||(s[2138]=[n("linkBefore()")])),_:1}),s[3514]||(s[3514]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2139]||(s[2139]=[n("方法之前，会调用")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3515]||(s[3515]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2140]||(s[2140]=[n("node()")])),_:1}),s[3516]||(s[3516]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2141]||(s[2141]=[n("方法查找指定位置上的元素，这一步是需要遍历 LinkedList 的。如果插入的位置靠前前半段，就从队头开始往后找；否则从队尾往前找。也就是说，如果插入的位置越靠近 LinkedList 的中间位置，遍历所花费的时间就越多。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2142]||(s[2142]=[n("找到指定位置上的元素（参数succ）之后，就开始执行")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3517]||(s[3517]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2143]||(s[2143]=[n("linkBefore()")])),_:1}),s[3518]||(s[3518]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2144]||(s[2144]=[n("方法，先将 succ 的前一个节点（prev）存放到临时变量 pred 中，然后生成新的 Node 节点（newNode），并将 succ 的前一个节点变更为 newNode，如果 pred 为 null，说明插入的是队头，所以 first 为新节点；否则将 pred 的后一个节点变更为 newNode。")])),_:1}),s[3519]||(s[3519]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726671668657-31e33f21-e180-4d97-8347-a75cf82727ee.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2145]||(s[2145]=[n("经过源码分析以后，你是不是在想：“好像 ArrayList 在新增元素的时候效率并不一定比 LinkedList 低啊！”")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2146]||(s[2146]=[n("当两者的起始长度是一样的情况下：")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2147]||(s[2147]=[n("如果是从集合的头部新增元素，ArrayList 花费的时间应该比 LinkedList 多，因为需要对头部以后的元素进行复制。")])),_:1})])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2148]||(s[2148]=[n("我们来测试一下：")])),_:1}),s[3520]||(s[3520]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public class ArrayListTest {</span>
<span class="line">    public static void addFromHeaderTest(int num) {</span>
<span class="line">        ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(num);</span>
<span class="line">        int i = 0;</span>
<span class="line"></span>
<span class="line">        long timeStart = System.currentTimeMillis();</span>
<span class="line"></span>
<span class="line">        while (i &lt; num) {</span>
<span class="line">            list.add(0, i + &quot;沉默王二&quot;);</span>
<span class="line">            i++;</span>
<span class="line">        }</span>
<span class="line">        long timeEnd = System.currentTimeMillis();</span>
<span class="line"></span>
<span class="line">        System.out.println(&quot;ArrayList从集合头部位置新增元素花费的时间&quot; + (timeEnd - timeStart));</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">/**</span>
<span class="line"> * @author 微信搜「沉默王二」，回复关键字 PDF</span>
<span class="line"> */</span>
<span class="line">public class LinkedListTest {</span>
<span class="line">    public static void addFromHeaderTest(int num) {</span>
<span class="line">        LinkedList&lt;String&gt; list = new LinkedList&lt;String&gt;();</span>
<span class="line">        int i = 0;</span>
<span class="line">        long timeStart = System.currentTimeMillis();</span>
<span class="line">        while (i &lt; num) {</span>
<span class="line">            list.addFirst(i + &quot;沉默王二&quot;);</span>
<span class="line">            i++;</span>
<span class="line">        }</span>
<span class="line">        long timeEnd = System.currentTimeMillis();</span>
<span class="line"></span>
<span class="line">        System.out.println(&quot;LinkedList从集合头部位置新增元素花费的时间&quot; + (timeEnd - timeStart));</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2149]||(s[2149]=[n("num 为 10000，代码实测后的时间如下所示：")])),_:1}),s[3521]||(s[3521]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">ArrayList从集合头部位置新增元素花费的时间595</span>
<span class="line">LinkedList从集合头部位置新增元素花费的时间15</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2150]||(s[2150]=[n("此时，ArrayList 花费的时间比 LinkedList 要多很多。")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2151]||(s[2151]=[n("如果是从集合的中间位置新增元素，ArrayList 花费的时间搞不好要比 LinkedList 少，因为 LinkedList 需要遍历。")])),_:1})])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2152]||(s[2152]=[n("来看测试代码。")])),_:1}),s[3522]||(s[3522]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public class ArrayListTest {</span>
<span class="line">    public static void addFromMidTest(int num) {</span>
<span class="line">        ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(num);</span>
<span class="line">        int i = 0;</span>
<span class="line"></span>
<span class="line">        long timeStart = System.currentTimeMillis();</span>
<span class="line">        while (i &lt; num) {</span>
<span class="line">            int temp = list.size();</span>
<span class="line">            list.add(temp / 2, i + &quot;沉默王二&quot;);</span>
<span class="line">            i++;</span>
<span class="line">        }</span>
<span class="line">        long timeEnd = System.currentTimeMillis();</span>
<span class="line"></span>
<span class="line">        System.out.println(&quot;ArrayList从集合中间位置新增元素花费的时间&quot; + (timeEnd - timeStart));</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">public class LinkedListTest {</span>
<span class="line">    public static void addFromMidTest(int num) {</span>
<span class="line">        LinkedList&lt;String&gt; list = new LinkedList&lt;String&gt;();</span>
<span class="line">        int i = 0;</span>
<span class="line">        long timeStart = System.currentTimeMillis();</span>
<span class="line">        while (i &lt; num) {</span>
<span class="line">            int temp = list.size();</span>
<span class="line">            list.add(temp / 2, i + &quot;沉默王二&quot;);</span>
<span class="line">            i++;</span>
<span class="line">        }</span>
<span class="line">        long timeEnd = System.currentTimeMillis();</span>
<span class="line"></span>
<span class="line">        System.out.println(&quot;LinkedList从集合中间位置新增元素花费的时间&quot; + (timeEnd - timeStart));</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2153]||(s[2153]=[n("num 为 10000，代码实测后的时间如下所示：")])),_:1}),s[3523]||(s[3523]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">ArrayList从集合中间位置新增元素花费的时间16</span>
<span class="line">LinkedList从集合中间位置新增元素花费的时间114</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2154]||(s[2154]=[n("ArrayList 花费的时间比 LinkedList 要少很多很多。")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2155]||(s[2155]=[n("如果是从集合的尾部新增元素，ArrayList 花费的时间应该比 LinkedList 少，因为数组是一段连续的内存空间，也不需要复制数组；而链表需要创建新的对象，前后引用也要重新排列。")])),_:1})])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2156]||(s[2156]=[n("来看测试代码：")])),_:1}),s[3524]||(s[3524]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public class ArrayListTest {</span>
<span class="line">    public static void addFromTailTest(int num) {</span>
<span class="line">        ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(num);</span>
<span class="line">        int i = 0;</span>
<span class="line"></span>
<span class="line">        long timeStart = System.currentTimeMillis();</span>
<span class="line"></span>
<span class="line">        while (i &lt; num) {</span>
<span class="line">            list.add(i + &quot;沉默王二&quot;);</span>
<span class="line">            i++;</span>
<span class="line">        }</span>
<span class="line"></span>
<span class="line">        long timeEnd = System.currentTimeMillis();</span>
<span class="line"></span>
<span class="line">        System.out.println(&quot;ArrayList从集合尾部位置新增元素花费的时间&quot; + (timeEnd - timeStart));</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">public class LinkedListTest {</span>
<span class="line">    public static void addFromTailTest(int num) {</span>
<span class="line">        LinkedList&lt;String&gt; list = new LinkedList&lt;String&gt;();</span>
<span class="line">        int i = 0;</span>
<span class="line">        long timeStart = System.currentTimeMillis();</span>
<span class="line">        while (i &lt; num) {</span>
<span class="line">            list.add(i + &quot;沉默王二&quot;);</span>
<span class="line">            i++;</span>
<span class="line">        }</span>
<span class="line">        long timeEnd = System.currentTimeMillis();</span>
<span class="line"></span>
<span class="line">        System.out.println(&quot;LinkedList从集合尾部位置新增元素花费的时间&quot; + (timeEnd - timeStart));</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2157]||(s[2157]=[n("num 为 10000，代码实测后的时间如下所示：")])),_:1}),s[3525]||(s[3525]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">ArrayList从集合尾部位置新增元素花费的时间69</span>
<span class="line">LinkedList从集合尾部位置新增元素花费的时间193</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2158]||(s[2158]=[n("ArrayList 花费的时间比 LinkedList 要少一些。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2159]||(s[2159]=[n("这样的结论和预期的是不是不太相符？ArrayList 在添加元素的时候如果不涉及到扩容，性能在两种情况下（中间位置新增元素、尾部新增元素）比 LinkedList 好很多，只有头部新增元素的时候比 LinkedList 差，因为数组复制的原因。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2160]||(s[2160]=[n("当然了，如果涉及到数组扩容的话，ArrayList 的性能就没那么可观了，因为扩容的时候也要复制数组。")])),_:1}),a("h3",ue,[a("a",ve,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2161]||(s[2161]=[n("删除元素时究竟谁快？")])),_:1})])])]),a("h4",be,[a("a",me,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2162]||(s[2162]=[n("ArrayList")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2163]||(s[2163]=[n("ArrayList 删除元素的时候，有两种方式，一种是直接删除元素（")])),_:1}),s[3526]||(s[3526]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2164]||(s[2164]=[n("remove(Object)")])),_:1}),s[3527]||(s[3527]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2165]||(s[2165]=[n("），需要直先遍历数组，找到元素对应的索引；一种是按照索引删除元素（")])),_:1}),s[3528]||(s[3528]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2166]||(s[2166]=[n("remove(int)")])),_:1}),s[3529]||(s[3529]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2167]||(s[2167]=[n("）。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2168]||(s[2168]=[n("来看一下源码（其实前面也讲过了，这里温习一下）：")])),_:1}),s[3530]||(s[3530]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public boolean remove(Object o) {</span>
<span class="line">    final Object[] es = elementData; // 获取数组元素</span>
<span class="line">    final int size = this.size; // 获取数组大小</span>
<span class="line">    int i = 0;</span>
<span class="line">    found: {</span>
<span class="line">        if (o == null) {</span>
<span class="line">            for (; i &lt; size; i++)</span>
<span class="line">                if (es[i] == null)</span>
<span class="line">                    break found;</span>
<span class="line">        } else {</span>
<span class="line">            for (; i &lt; size; i++)</span>
<span class="line">                if (o.equals(es[i]))</span>
<span class="line">                    break found;</span>
<span class="line">        }</span>
<span class="line">        return false;</span>
<span class="line">    }</span>
<span class="line">    fastRemove(es, i); // 调用 fastRemove 方法快速移除元素</span>
<span class="line">    return true;</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">public E remove(int index) {</span>
<span class="line">    Objects.checkIndex(index, size); // 检查索引是否越界</span>
<span class="line">    final Object[] es = elementData; // 获取数组元素</span>
<span class="line"></span>
<span class="line">    oldValue = (E) es[index]; // 获取要删除的元素</span>
<span class="line">    fastRemove(es, index); // 调用 fastRemove 方法快速移除元素</span>
<span class="line"></span>
<span class="line">    return oldValue; // 返回被删除的元素</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2169]||(s[2169]=[n("本质上讲，两个方法是一样的，它们最后调用的都是")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3531]||(s[3531]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2170]||(s[2170]=[n("fastRemove(Object, int)")])),_:1}),s[3532]||(s[3532]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2171]||(s[2171]=[n("方法。")])),_:1}),s[3533]||(s[3533]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">private void fastRemove(Object[] es, int i) {</span>
<span class="line">    final int newSize;</span>
<span class="line">    if ((newSize = size - 1) &gt; i) // 如果要删除的不是最后一个元素</span>
<span class="line">        System.arraycopy(es, i + 1, es, i, newSize - i); // 将要删除元素后面的元素向前移动一位</span>
<span class="line">    es[size = newSize] = null; // 将最后一个元素置为 null，帮助垃圾回收</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2172]||(s[2172]=[n("从源码可以看得出，只要删除的不是最后一个元素，都需要重新移动数组。删除的元素位置越靠前，代价就越大。")])),_:1}),a("h4",ge,[a("a",ye,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2173]||(s[2173]=[n("LinkedList")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2174]||(s[2174]=[n("LinkedList 删除元素的时候，有四种常用的方式：")])),_:1}),a("ul",null,[a("li",null,[s[2176]||(s[2176]=a("code",null,'<font style="color:rgb(44, 62, 80);">remove(int)</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2175]||(s[2175]=[n("，删除指定位置上的元素")])),_:1})])]),s[3534]||(s[3534]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public E remove(int index) {</span>
<span class="line">    checkElementIndex(index);</span>
<span class="line">    return unlink(node(index));</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2177]||(s[2177]=[n("先检查索引，再调用")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3535]||(s[3535]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2178]||(s[2178]=[n("node(int)")])),_:1}),s[3536]||(s[3536]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2179]||(s[2179]=[n("方法（ 前后半段遍历，和新增元素操作一样）找到节点 Node，然后调用")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3537]||(s[3537]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2180]||(s[2180]=[n("unlink(Node)")])),_:1}),s[3538]||(s[3538]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2181]||(s[2181]=[n("解除节点的前后引用，同时更新前节点的后引用和后节点的前引用：")])),_:1}),s[3539]||(s[3539]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">E unlink(Node&lt;E&gt; x) {</span>
<span class="line">    final E element = x.item; // 获取要删除的节点的元素</span>
<span class="line">    final Node&lt;E&gt; next = x.next; // 获取要删除的节点的后继节点</span>
<span class="line">    final Node&lt;E&gt; prev = x.prev; // 获取要删除的节点的前驱节点</span>
<span class="line"></span>
<span class="line">    if (prev == null) { // 如果要删除的节点是第一个节点</span>
<span class="line">        first = next; // 将头节点更新为要删除的节点的后继节点</span>
<span class="line">    } else {</span>
<span class="line">        prev.next = next; // 将要删除的节点的前驱节点的后继节点指向要删除的节点的后继节点</span>
<span class="line">        x.prev = null; // 将要删除的节点的前驱节点置为 null，帮助垃圾回收</span>
<span class="line">    }</span>
<span class="line"></span>
<span class="line">    if (next == null) { // 如果要删除的节点是最后一个节点</span>
<span class="line">        last = prev; // 将尾节点更新为要删除的节点的前驱节点</span>
<span class="line">    } else {</span>
<span class="line">        next.prev = prev; // 将要删除的节点的后继节点的前驱节点指向要删除的节点的前驱节点</span>
<span class="line">        x.next = null; // 将要删除的节点的后继节点置为 null，帮助垃圾回收</span>
<span class="line">    }</span>
<span class="line"></span>
<span class="line">    x.item = null; // 将要删除的节点的元素置为 null，帮助垃圾回收</span>
<span class="line">    size--; // 将链表的长度减一</span>
<span class="line">    return element; // 返回被删除的元素</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),a("ul",null,[a("li",null,[s[2183]||(s[2183]=a("code",null,'<font style="color:rgb(44, 62, 80);">remove(Object)</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2182]||(s[2182]=[n("，直接删除元素")])),_:1})])]),s[3540]||(s[3540]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public boolean remove(Object o) {</span>
<span class="line">    if (o == null) { // 如果要删除的元素为 null</span>
<span class="line">        for (LinkedList.Node&lt;E&gt; x = first; x != null; x = x.next) {</span>
<span class="line">            if (x.item == null) { // 如果找到了要删除的节点</span>
<span class="line">                unlink(x); // 调用 unlink 方法删除指定节点</span>
<span class="line">                return true; // 返回删除成功</span>
<span class="line">            }</span>
<span class="line">        }</span>
<span class="line">    } else {</span>
<span class="line">        for (LinkedList.Node&lt;E&gt; x = first; x != null; x = x.next) {</span>
<span class="line">            if (o.equals(x.item)) { // 如果找到了要删除的节点</span>
<span class="line">                unlink(x); // 调用 unlink 方法删除指定节点</span>
<span class="line">                return true; // 返回删除成功</span>
<span class="line">            }</span>
<span class="line">        }</span>
<span class="line">    }</span>
<span class="line">    return false; // 没有找到要删除的节点，返回删除失败</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2184]||(s[2184]=[n("也是先前后半段遍历，找到要删除的元素后调用")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3541]||(s[3541]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2185]||(s[2185]=[n("unlink(Node)")])),_:1}),s[3542]||(s[3542]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2186]||(s[2186]=[n("。")])),_:1}),a("ul",null,[a("li",null,[s[2188]||(s[2188]=a("code",null,'<font style="color:rgb(44, 62, 80);">removeFirst()</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2187]||(s[2187]=[n("，删除第一个节点")])),_:1})])]),s[3543]||(s[3543]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public E removeFirst() {</span>
<span class="line">    final LinkedList.Node&lt;E&gt; f = first;</span>
<span class="line">    if (f == null)</span>
<span class="line">        throw new NoSuchElementException();</span>
<span class="line">    return unlinkFirst(f);</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">private E unlinkFirst(LinkedList.Node&lt;E&gt; f) {</span>
<span class="line">    final E element = f.item; // 获取要删除的节点的元素</span>
<span class="line">    final LinkedList.Node&lt;E&gt; next = f.next; // 获取要删除的节点的后继节点</span>
<span class="line">    f.item = null; // 将要删除的节点的元素置为 null，帮助垃圾回收</span>
<span class="line">    f.next = null; // 将要删除的节点的后继节点置为 null，帮助垃圾回收</span>
<span class="line">    first = next; // 将头节点更新为要删除的节点的后继节点</span>
<span class="line">    if (next == null) // 如果链表已经为空</span>
<span class="line">        last = null; // 将尾节点置为 null</span>
<span class="line">    else</span>
<span class="line">        next.prev = null; // 将要删除的节点的后继节点的前驱节点置为 null，帮助垃圾回收</span>
<span class="line">    size--; // 将链表的长度减一</span>
<span class="line">    return element; // 返回被删除的元素</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2189]||(s[2189]=[n("删除第一个节点就不需要遍历了，只需要把第二个节点更新为第一个节点即可。")])),_:1}),a("ul",null,[a("li",null,[s[2191]||(s[2191]=a("code",null,'<font style="color:rgb(44, 62, 80);">removeLast()</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2190]||(s[2190]=[n("，删除最后一个节点")])),_:1})])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2192]||(s[2192]=[n("删除最后一个节点和删除第一个节点类似，只需要把倒数第二个节点更新为最后一个节点即可。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2193]||(s[2193]=[n("可以看得出，LinkedList 在删除比较靠前和比较靠后的元素时，非常高效，但如果删除的是中间位置的元素，效率就比较低了。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2194]||(s[2194]=[n("这里就不再做代码测试了，感兴趣的话可以自己试试，结果和新增元素保持一致：")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2195]||(s[2195]=[n("从集合头部删除元素时，ArrayList 花费的时间比 LinkedList 多很多；")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2196]||(s[2196]=[n("从集合中间位置删除元素时，ArrayList 花费的时间比 LinkedList 少很多；")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2197]||(s[2197]=[n("从集合尾部删除元素时，ArrayList 花费的时间比 LinkedList 少一点。")])),_:1})])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2198]||(s[2198]=[n("我本地的统计结果如下所示，可以作为参考：")])),_:1}),s[3544]||(s[3544]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">ArrayList从集合头部位置删除元素花费的时间380</span>
<span class="line">LinkedList从集合头部位置删除元素花费的时间4</span>
<span class="line">ArrayList从集合中间位置删除元素花费的时间381</span>
<span class="line">LinkedList从集合中间位置删除元素花费的时间5922</span>
<span class="line">ArrayList从集合尾部位置删除元素花费的时间8</span>
<span class="line">LinkedList从集合尾部位置删除元素花费的时间12</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),a("h3",fe,[a("a",ke,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2199]||(s[2199]=[n("遍历元素时究竟谁快？")])),_:1})])])]),a("h4",ce,[a("a",qe,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2200]||(s[2200]=[n("ArrayList")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2201]||(s[2201]=[n("遍历 ArrayList 找到某个元素的话，通常有两种形式：")])),_:1}),a("ul",null,[a("li",null,[s[2203]||(s[2203]=a("code",null,'<font style="color:rgb(44, 62, 80);">get(int)</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2202]||(s[2202]=[n("，根据索引找元素")])),_:1})])]),s[3545]||(s[3545]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public E get(int index) {</span>
<span class="line">    Objects.checkIndex(index, size);</span>
<span class="line">    return elementData(index);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2204]||(s[2204]=[n("由于 ArrayList 是由数组实现的，所以根据索引找元素非常的快，一步到位。")])),_:1}),a("ul",null,[a("li",null,[s[2206]||(s[2206]=a("code",null,'<font style="color:rgb(44, 62, 80);">indexOf(Object)</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2205]||(s[2205]=[n("，根据元素找索引")])),_:1})])]),s[3546]||(s[3546]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public int indexOf(Object o) {</span>
<span class="line">    return indexOfRange(o, 0, size);</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">int indexOfRange(Object o, int start, int end) {</span>
<span class="line">    Object[] es = elementData; // 获取 ArrayList 中的元素数组</span>
<span class="line">    if (o == null) { // 如果要查找的元素为 null</span>
<span class="line">        for (int i = start; i &lt; end; i++) {</span>
<span class="line">            if (es[i] == null) { // 如果找到了要查找的元素</span>
<span class="line">                return i; // 返回元素在 ArrayList 中的索引</span>
<span class="line">            }</span>
<span class="line">        }</span>
<span class="line">    } else {</span>
<span class="line">        for (int i = start; i &lt; end; i++) {</span>
<span class="line">            if (o.equals(es[i])) { // 如果找到了要查找的元素</span>
<span class="line">                return i; // 返回元素在 ArrayList 中的索引</span>
<span class="line">            }</span>
<span class="line">        }</span>
<span class="line">    }</span>
<span class="line">    return -1; // 没有找到要查找的元素，返回 -1</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2207]||(s[2207]=[n("根据元素找索引的话，就需要遍历整个数组了，从头到尾依次找。")])),_:1}),a("h4",xe,[a("a",Le,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2208]||(s[2208]=[n("LinkedList")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2209]||(s[2209]=[n("遍历 LinkedList 找到某个元素的话，通常也有两种形式：")])),_:1}),a("ul",null,[a("li",null,[s[2211]||(s[2211]=a("code",null,'<font style="color:rgb(44, 62, 80);">get(int)</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2210]||(s[2210]=[n("，找指定位置上的元素")])),_:1})])]),s[3547]||(s[3547]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public E get(int index) {</span>
<span class="line">    checkElementIndex(index);</span>
<span class="line">    return node(index).item;</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2212]||(s[2212]=[n("既然需要调用")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3548]||(s[3548]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2213]||(s[2213]=[n("node(int)")])),_:1}),s[3549]||(s[3549]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2214]||(s[2214]=[n("方法，就意味着需要前后半段遍历了。")])),_:1}),a("ul",null,[a("li",null,[s[2216]||(s[2216]=a("code",null,'<font style="color:rgb(44, 62, 80);">indexOf(Object)</font>',-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2215]||(s[2215]=[n("，找元素所在的位置")])),_:1})])]),s[3550]||(s[3550]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public int indexOf(Object o) {</span>
<span class="line">    int index = 0; // 初始化索引为 0</span>
<span class="line">    if (o == null) { // 如果要查找的元素为 null</span>
<span class="line">        for (LinkedList.Node&lt;E&gt; x = first; x != null; x = x.next) { // 从头节点开始遍历链表</span>
<span class="line">            if (x.item == null) // 如果找到了要查找的元素</span>
<span class="line">                return index; // 返回元素在 LinkedList 中的索引</span>
<span class="line">            index++; // 索引加一</span>
<span class="line">        }</span>
<span class="line">    } else {</span>
<span class="line">        for (LinkedList.Node&lt;E&gt; x = first; x != null; x = x.next) { // 从头节点开始遍历链表</span>
<span class="line">            if (o.equals(x.item)) // 如果找到了要查找的元素</span>
<span class="line">                return index; // 返回元素在 LinkedList 中的索引</span>
<span class="line">            index++; // 索引加一</span>
<span class="line">        }</span>
<span class="line">    }</span>
<span class="line">    return -1; // 没有找到要查找的元素，返回 -1</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2217]||(s[2217]=[n("需要遍历整个链表，和 ArrayList 的")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3551]||(s[3551]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2218]||(s[2218]=[n("indexOf()")])),_:1}),s[3552]||(s[3552]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2219]||(s[2219]=[n("类似。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2220]||(s[2220]=[n("那在我们对集合遍历的时候，通常有两种做法，一种是使用 for 循环，一种是使用")])),_:1}),s[3553]||(s[3553]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2221]||(s[2221]=[n("迭代器（Iterator）")])),_:1}),s[3554]||(s[3554]=n("](https://javabetter.cn/collection/iterator-iterable.html)")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2222]||(s[2222]=[n("。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2223]||(s[2223]=[n("如果使用的是 for 循环，可想而知 LinkedList 在 get 的时候性能会非常差，因为每一次外层的 for 循环，都要执行一次")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3555]||(s[3555]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2224]||(s[2224]=[n("node(int)")])),_:1}),s[3556]||(s[3556]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2225]||(s[2225]=[n("方法进行前后半段的遍历。")])),_:1}),s[3557]||(s[3557]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">LinkedList.Node&lt;E&gt; node(int index) {</span>
<span class="line">    // assert isElementIndex(index);</span>
<span class="line"></span>
<span class="line">    if (index &lt; (size &gt;&gt; 1)) { // 如果要查找的元素在链表的前半部分</span>
<span class="line">        LinkedList.Node&lt;E&gt; x = first; // 从头节点开始遍历链表</span>
<span class="line">        for (int i = 0; i &lt; index; i++) // 循环查找元素</span>
<span class="line">            x = x.next;</span>
<span class="line">        return x; // 返回要查找的元素节点</span>
<span class="line">    } else { // 如果要查找的元素在链表的后半部分</span>
<span class="line">        LinkedList.Node&lt;E&gt; x = last; // 从尾节点开始遍历链表</span>
<span class="line">        for (int i = size - 1; i &gt; index; i--) // 循环查找元素</span>
<span class="line">            x = x.prev;</span>
<span class="line">        return x; // 返回要查找的元素节点</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2226]||(s[2226]=[n("那如果使用的是迭代器呢？")])),_:1}),s[3558]||(s[3558]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">LinkedList&lt;String&gt; list = new LinkedList&lt;String&gt;();</span>
<span class="line">for (Iterator&lt;String&gt; it = list.iterator(); it.hasNext();) {</span>
<span class="line">    it.next();</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2227]||(s[2227]=[n("迭代器只会调用一次")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3559]||(s[3559]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2228]||(s[2228]=[n("node(int)")])),_:1}),s[3560]||(s[3560]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2229]||(s[2229]=[n("方法，在执行")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3561]||(s[3561]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2230]||(s[2230]=[n("list.iterator()")])),_:1}),s[3562]||(s[3562]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2231]||(s[2231]=[n("的时候：先调用 AbstractSequentialList 类的")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3563]||(s[3563]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2232]||(s[2232]=[n("iterator()")])),_:1}),s[3564]||(s[3564]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2233]||(s[2233]=[n("方法，再调用 AbstractList 类的")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3565]||(s[3565]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2234]||(s[2234]=[n("listIterator()")])),_:1}),s[3566]||(s[3566]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2235]||(s[2235]=[n("方法，再调用 LinkedList 类的")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3567]||(s[3567]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2236]||(s[2236]=[n("listIterator(int)")])),_:1}),s[3568]||(s[3568]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2237]||(s[2237]=[n("方法，如下图所示。")])),_:1}),s[3569]||(s[3569]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726671668215-9777399f-05a6-445c-9498-2d57279e5373.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2238]||(s[2238]=[n("最后返回的是 LinkedList 类的内部私有类 ListItr 对象：")])),_:1}),s[3570]||(s[3570]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public ListIterator&lt;E&gt; listIterator(int index) {</span>
<span class="line">    checkPositionIndex(index); // 检查索引是否在有效范围内</span>
<span class="line">    return new LinkedList.ListItr(index); // 创建一个新的 ListItr 对象并返回</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">private class ListItr implements ListIterator&lt;E&gt; {</span>
<span class="line">    private LinkedList.Node&lt;E&gt; lastReturned; // 上一个已返回的节点</span>
<span class="line">    private LinkedList.Node&lt;E&gt; next; // 下一个节点</span>
<span class="line">    private int nextIndex; // 下一个节点的索引</span>
<span class="line">    private int expectedModCount = modCount; // 链表被修改的次数</span>
<span class="line"></span>
<span class="line">    ListItr(int index) {</span>
<span class="line">        // assert isPositionIndex(index);</span>
<span class="line">        next = (index == size) ? null : node(index); // 如果 index 等于 size，next 为 null，否则返回 node(index)</span>
<span class="line">        nextIndex = index; // 设置 nextIndex 为 index</span>
<span class="line">    }</span>
<span class="line"></span>
<span class="line">    public boolean hasNext() {</span>
<span class="line">        return nextIndex &lt; size; // 如果下一个节点的索引小于链表的长度，返回 true，否则返回 false</span>
<span class="line">    }</span>
<span class="line"></span>
<span class="line">    public E next() {</span>
<span class="line">        checkForComodification(); // 检查链表是否已经被修改</span>
<span class="line">        if (!hasNext()) // 如果没有下一个节点，抛出 NoSuchElementException 异常</span>
<span class="line">            throw new NoSuchElementException();</span>
<span class="line"></span>
<span class="line">        lastReturned = next; // 将下一个节点设置为上一个已返回节点</span>
<span class="line">        next = next.next; // 将下一个节点设置为当前节点的下一个节点</span>
<span class="line">        nextIndex++; // 将下一个节点的索引增加 1</span>
<span class="line">        return lastReturned.item; // 返回上一个已返回节点的元素</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2239]||(s[2239]=[n("执行 ListItr 的构造方法时调用了一次")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3571]||(s[3571]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2240]||(s[2240]=[n("node(int)")])),_:1}),s[3572]||(s[3572]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2241]||(s[2241]=[n("方法，返回第一个节点。在此之后，迭代器就执行")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3573]||(s[3573]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2242]||(s[2242]=[n("hasNext()")])),_:1}),s[3574]||(s[3574]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2243]||(s[2243]=[n("判断有没有下一个，执行")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3575]||(s[3575]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2244]||(s[2244]=[n("next()")])),_:1}),s[3576]||(s[3576]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2245]||(s[2245]=[n("方法下一个节点。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2246]||(s[2246]=[n("由此，可以得出这样的结论：")])),_:1}),s[3577]||(s[3577]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2247]||(s[2247]=[n("遍历 LinkedList 的时候，千万不要使用 for 循环，要使用迭代器。")])),_:1}),s[3578]||(s[3578]=n("**")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2248]||(s[2248]=[n("也就是说，for 循环遍历的时候，ArrayList 花费的时间远小于 LinkedList；迭代器遍历的时候，两者性能差不多。")])),_:1}),a("h3",Me,[a("a",we,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2249]||(s[2249]=[n("两者的使用场景")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2250]||(s[2250]=[n("当需要频繁随机访问元素的时候，例如读取大量数据并进行处理或者需要对数据进行排序或查找的场景，可以使用 ArrayList。例如一个学生管理系统，需要对学生列表进行排序或查找操作，可以使用 ArrayList 存储学生信息，以便快速访问和处理。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2251]||(s[2251]=[n("当需要频繁插入和删除元素的时候，例如实现队列或栈，或者需要在中间插入或删除元素的场景，可以使用 LinkedList。例如一个实时聊天系统，需要实现一个消息队列，可以使用 LinkedList 存储消息，以便快速插入和删除消息。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2252]||(s[2252]=[n("在一些特殊场景下，可能需要同时支持随机访问和插入/删除操作。例如一个在线游戏系统，需要实现一个玩家列表，需要支持快速查找和遍历玩家，同时也需要支持玩家的加入和离开。在这种情况下，可以使用 LinkedList 和 ArrayList 的组合，例如使用 LinkedList 存储玩家，以便快速插入和删除玩家，同时使用 ArrayList 存储玩家列表，以便快速查找和遍历玩家。")])),_:1}),s[3579]||(s[3579]=a("h2",{id:"iterator-和-iterable-区别",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#iterator-和-iterable-区别"},[a("span",null,"Iterator 和 Iterable 区别")])],-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2253]||(s[2253]=[n("在 Java 中，我们对 List 进行遍历的时候，主要有这么三种方式。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2254]||(s[2254]=[n("第一种：for 循环。")])),_:1}),s[3580]||(s[3580]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">for (int i = 0; i &lt; list.size(); i++) {</span>
<span class="line">    System.out.print(list.get(i) + &quot;，&quot;);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2255]||(s[2255]=[n("第二种：迭代器。")])),_:1}),s[3581]||(s[3581]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">Iterator it = list.iterator();</span>
<span class="line">while (it.hasNext()) {</span>
<span class="line">    System.out.print(it.next() + &quot;，&quot;);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2256]||(s[2256]=[n("第三种：for-each。")])),_:1}),s[3582]||(s[3582]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">for (String str : list) {</span>
<span class="line">    System.out.print(str + &quot;，&quot;);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2257]||(s[2257]=[n("第一种我们略过，第二种用的是 Iterator，第三种看起来是 for-each，其实背后也是 Iterator，看一下反编译后的代码（如下所示）就明白了。")])),_:1}),s[3583]||(s[3583]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">Iterator var3 = list.iterator();</span>
<span class="line"></span>
<span class="line">while(var3.hasNext()) {</span>
<span class="line">    String str = (String)var3.next();</span>
<span class="line">    System.out.print(str + &quot;，&quot;);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2258]||(s[2258]=[n("for-each 只不过是个语法糖，让我们开发者在遍历 List 的时候可以写更少的代码，更简洁明了。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2259]||(s[2259]=[n("Iterator 是个接口，JDK 1.2 的时候就有了，用来改进 Enumeration 接口：")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2260]||(s[2260]=[n("允许删除元素（增加了 remove 方法）")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2261]||(s[2261]=[n("优化了方法名（Enumeration 中是 hasMoreElements 和 nextElement，不简洁）")])),_:1})])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2262]||(s[2262]=[n("来看一下 Iterator 的源码：")])),_:1}),s[3584]||(s[3584]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public interface Iterator&lt;E&gt; {</span>
<span class="line">    // 判断集合中是否存在下一个对象</span>
<span class="line">    boolean hasNext();</span>
<span class="line">    // 返回集合中的下一个对象，并将访问指针移动一位</span>
<span class="line">    E next();</span>
<span class="line">    // 删除集合中调用next()方法返回的对象</span>
<span class="line">    default void remove() {</span>
<span class="line">        throw new UnsupportedOperationException(&quot;remove&quot;);</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2263]||(s[2263]=[n("JDK 1.8 时，Iterable 接口中新增了 forEach 方法。该方法接受一个 Consumer 对象作为参数，用于对集合中的每个元素执行指定的操作。该方法的实现方式是使用 for-each 循环遍历集合中的元素，对于每个元素，调用 Consumer 对象的 accept 方法执行指定的操作。")])),_:1}),s[3585]||(s[3585]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">default void forEach(Consumer&lt;? super T&gt; action) {</span>
<span class="line">    Objects.requireNonNull(action);</span>
<span class="line">    for (T t : this) {</span>
<span class="line">        action.accept(t);</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2264]||(s[2264]=[n("该方法实现时首先会对 action 参数进行非空检查，如果为 null 则抛出 NullPointerException 异常。然后使用 for-each 循环遍历集合中的元素，并对每个元素调用 action.accept(t) 方法执行指定的操作。由于 Iterable 接口是 Java 集合框架中所有集合类型的基本接口，因此该方法可以被所有实现了 Iterable 接口的集合类型使用。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2265]||(s[2265]=[n("它对 Iterable 的每个元素执行给定操作，具体指定的操作需要自己写Consumer接口通过accept方法回调出来。")])),_:1}),s[3586]||(s[3586]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(1, 2, 3));</span>
<span class="line">list.forEach(integer -&gt; System.out.println(integer));</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2266]||(s[2266]=[n("写得更浅显易懂点，就是：")])),_:1}),s[3587]||(s[3587]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(1, 2, 3));</span>
<span class="line">list.forEach(new Consumer&lt;Integer&gt;() {</span>
<span class="line">    @Override</span>
<span class="line">    public void accept(Integer integer) {</span>
<span class="line">        System.out.println(integer);</span>
<span class="line">    }</span>
<span class="line">});</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2267]||(s[2267]=[n("如果我们仔细观察ArrayList 或者 LinkedList 的“户口本”就会发现，并没有直接找到 Iterator 的影子。")])),_:1}),s[3588]||(s[3588]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726671705549-01c1cf64-0a34-4149-8408-e25d70421481.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2268]||(s[2268]=[n("反而找到了 Iterable！")])),_:1}),s[3589]||(s[3589]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public interface Iterable&lt;T&gt; {</span>
<span class="line">    Iterator&lt;T&gt; iterator();</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2269]||(s[2269]=[n("也就是说，List 的关系图谱中并没有直接使用 Iterator，而是使用 Iterable 做了过渡。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2270]||(s[2270]=[n("回头再来看一下第二种遍历 List 的方式。")])),_:1}),s[3590]||(s[3590]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">Iterator it = list.iterator();</span>
<span class="line">while (it.hasNext()) {</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2271]||(s[2271]=[n("发现刚好呼应上了。拿 ArrayList 来说吧，它重写了 Iterable 接口的 iterator 方法：")])),_:1}),s[3591]||(s[3591]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public Iterator&lt;E&gt; iterator() {</span>
<span class="line">    return new Itr();</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2272]||(s[2272]=[n("返回的对象 Itr 是个内部类，实现了 Iterator 接口，并且按照自己的方式重写了 hasNext、next、remove 等方法。")])),_:1}),s[3592]||(s[3592]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">/**</span>
<span class="line"> * ArrayList 迭代器的实现，内部类。</span>
<span class="line"> */</span>
<span class="line">private class Itr implements Iterator&lt;E&gt; {</span>
<span class="line"></span>
<span class="line">    /**</span>
<span class="line">     * 游标位置，即下一个元素的索引。</span>
<span class="line">     */</span>
<span class="line">    int cursor;</span>
<span class="line"></span>
<span class="line">    /**</span>
<span class="line">     * 上一个元素的索引。</span>
<span class="line">     */</span>
<span class="line">    int lastRet = -1;</span>
<span class="line"></span>
<span class="line">    /**</span>
<span class="line">     * 预期的结构性修改次数。</span>
<span class="line">     */</span>
<span class="line">    int expectedModCount = modCount;</span>
<span class="line"></span>
<span class="line">    /**</span>
<span class="line">     * 判断是否还有下一个元素。</span>
<span class="line">     *</span>
<span class="line">     * @return 如果还有下一个元素，则返回 true，否则返回 false。</span>
<span class="line">     */</span>
<span class="line">    public boolean hasNext() {</span>
<span class="line">        return cursor != size;</span>
<span class="line">    }</span>
<span class="line"></span>
<span class="line">    /**</span>
<span class="line">     * 获取下一个元素。</span>
<span class="line">     *</span>
<span class="line">     * @return 列表中的下一个元素。</span>
<span class="line">     * @throws NoSuchElementException 如果没有下一个元素，则抛出 NoSuchElementException 异常。</span>
<span class="line">     */</span>
<span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line">    public E next() {</span>
<span class="line">        // 获取 ArrayList 对象的内部数组</span>
<span class="line">        Object[] elementData = ArrayList.this.elementData;</span>
<span class="line">        // 记录当前迭代器的位置</span>
<span class="line">        int i = cursor;</span>
<span class="line">        if (i &gt;= size) {</span>
<span class="line">            throw new NoSuchElementException();</span>
<span class="line">        }</span>
<span class="line">        // 将游标位置加 1，为下一次迭代做准备</span>
<span class="line">        cursor = i + 1;</span>
<span class="line">        // 记录上一个元素的索引</span>
<span class="line">        return (E) elementData[lastRet = i];</span>
<span class="line">    }</span>
<span class="line"></span>
<span class="line">    /**</span>
<span class="line">     * 删除最后一个返回的元素。</span>
<span class="line">     * 迭代器只能删除最后一次调用 next 方法返回的元素。</span>
<span class="line">     *</span>
<span class="line">     * @throws ConcurrentModificationException 如果在最后一次调用 next 方法之后列表结构被修改，则抛出 ConcurrentModificationException 异常。</span>
<span class="line">     * @throws IllegalStateException         如果在调用 next 方法之前没有调用 remove 方法，或者在同一次迭代中多次调用 remove 方法，则抛出 IllegalStateException 异常。</span>
<span class="line">     */</span>
<span class="line">    public void remove() {</span>
<span class="line">        // 检查在最后一次调用 next 方法之后是否进行了结构性修改</span>
<span class="line">        if (expectedModCount != modCount) {</span>
<span class="line">            throw new ConcurrentModificationException();</span>
<span class="line">        }</span>
<span class="line">        // 如果上一次调用 next 方法之前没有调用 remove 方法，则抛出 IllegalStateException 异常</span>
<span class="line">        if (lastRet &lt; 0) {</span>
<span class="line">            throw new IllegalStateException();</span>
<span class="line">        }</span>
<span class="line">        try {</span>
<span class="line">            // 调用 ArrayList 对象的 remove(int index) 方法删除上一个元素</span>
<span class="line">            ArrayList.this.remove(lastRet);</span>
<span class="line">            // 将游标位置设置为上一个元素的位置</span>
<span class="line">            cursor = lastRet;</span>
<span class="line">            // 将上一个元素的索引设置为 -1，表示没有上一个元素</span>
<span class="line">            lastRet = -1;</span>
<span class="line">            // 更新预期的结构性修改次数</span>
<span class="line">            expectedModCount = modCount;</span>
<span class="line">        } catch (IndexOutOfBoundsException ex) {</span>
<span class="line">            throw new ConcurrentModificationException();</span>
<span class="line">        }</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2273]||(s[2273]=[n("那可能有些小伙伴会问：为什么不直接将 Iterator 中的核心方法 hasNext、next 放到 Iterable 接口中呢？直接像下面这样使用不是更方便？")])),_:1}),s[3593]||(s[3593]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">Iterable it = list.iterator();</span>
<span class="line">while (it.hasNext()) {</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2274]||(s[2274]=[n("从英文单词的后缀语法上来看，（Iterable）able 表示这个 List 是支持迭代的，而 （Iterator）tor 表示这个 List 是如何迭代的。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2275]||(s[2275]=[n("支持迭代与具体怎么迭代显然不能混在一起，否则就乱的一笔。还是各司其职的好。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2276]||(s[2276]=[n("想一下，如果把 Iterator 和 Iterable 合并，for-each 这种遍历 List 的方式是不是就不好办了？")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2277]||(s[2277]=[n("原则上，只要一个 List 实现了 Iterable 接口，那么它就可以使用 for-each 这种方式来遍历，那具体该怎么遍历，还是要看它自己是怎么实现 Iterator 接口的。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2278]||(s[2278]=[n("Map 就没办法直接使用 for-each，因为 Map 没有实现 Iterable 接口，只有通过")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3594]||(s[3594]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2279]||(s[2279]=[n("map.entrySet()")])),_:1}),s[3595]||(s[3595]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2280]||(s[2280]=[n("、")])),_:1}),s[3596]||(s[3596]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2281]||(s[2281]=[n("map.keySet()")])),_:1}),s[3597]||(s[3597]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2282]||(s[2282]=[n("、")])),_:1}),s[3598]||(s[3598]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2283]||(s[2283]=[n("map.values()")])),_:1}),s[3599]||(s[3599]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2284]||(s[2284]=[n("这种返回一个 Collection 的方式才能 使用 for-each。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2285]||(s[2285]=[n("如果我们仔细研究 LinkedList 的源码就会发现，LinkedList 并没有直接重写 Iterable 接口的 iterator 方法，而是由它的父类 AbstractSequentialList 来完成。")])),_:1}),s[3600]||(s[3600]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public Iterator&lt;E&gt; iterator() {</span>
<span class="line">    return listIterator();</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2286]||(s[2286]=[n("LinkedList 重写了 listIterator 方法：")])),_:1}),s[3601]||(s[3601]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public ListIterator&lt;E&gt; listIterator(int index) {</span>
<span class="line">    checkPositionIndex(index);</span>
<span class="line">    return new ListItr(index);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2287]||(s[2287]=[n("这里我们发现了一个新的迭代器 ListIterator，它继承了 Iterator 接口，在遍历List 时可以从任意下标开始遍历，而且支持双向遍历。")])),_:1}),s[3602]||(s[3602]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; {</span>
<span class="line">    boolean hasNext();</span>
<span class="line">    E next();</span>
<span class="line">    boolean hasPrevious();</span>
<span class="line">    E previous();</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2288]||(s[2288]=[n("我们知道，集合（Collection）不仅有 List，还有 Set，那 Iterator 不仅支持 List，还支持 Set，但 ListIterator 就只支持 List。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2289]||(s[2289]=[n("那可能有些小伙伴会问：为什么不直接让 List 实现 Iterator 接口，而是要用内部类来实现呢？")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2290]||(s[2290]=[n("这是因为有些 List 可能会有多种遍历方式，比如说 LinkedList，除了支持正序的遍历方式，还支持逆序的遍历方式——DescendingIterator：")])),_:1}),s[3603]||(s[3603]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">/**</span>
<span class="line"> * ArrayList 逆向迭代器的实现，内部类。</span>
<span class="line"> */</span>
<span class="line">private class DescendingIterator implements Iterator&lt;E&gt; {</span>
<span class="line"></span>
<span class="line">    /**</span>
<span class="line">     * 使用 ListItr 对象进行逆向遍历。</span>
<span class="line">     */</span>
<span class="line">    private final ListItr itr = new ListItr(size());</span>
<span class="line"></span>
<span class="line">    /**</span>
<span class="line">     * 判断是否还有下一个元素。</span>
<span class="line">     *</span>
<span class="line">     * @return 如果还有下一个元素，则返回 true，否则返回 false。</span>
<span class="line">     */</span>
<span class="line">    public boolean hasNext() {</span>
<span class="line">        return itr.hasPrevious();</span>
<span class="line">    }</span>
<span class="line"></span>
<span class="line">    /**</span>
<span class="line">     * 获取下一个元素。</span>
<span class="line">     *</span>
<span class="line">     * @return 列表中的下一个元素。</span>
<span class="line">     * @throws NoSuchElementException 如果没有下一个元素，则抛出 NoSuchElementException 异常。</span>
<span class="line">     */</span>
<span class="line">    public E next() {</span>
<span class="line">        return itr.previous();</span>
<span class="line">    }</span>
<span class="line"></span>
<span class="line">    /**</span>
<span class="line">     * 删除最后一个返回的元素。</span>
<span class="line">     * 迭代器只能删除最后一次调用 next 方法返回的元素。</span>
<span class="line">     *</span>
<span class="line">     * @throws UnsupportedOperationException 如果列表不支持删除操作，则抛出 UnsupportedOperationException 异常。</span>
<span class="line">     * @throws IllegalStateException         如果在调用 next 方法之前没有调用 remove 方法，或者在同一次迭代中多次调用 remove 方法，则抛出 IllegalStateException 异常。</span>
<span class="line">     */</span>
<span class="line">    public void remove() {</span>
<span class="line">        itr.remove();</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2291]||(s[2291]=[n("可以看得到，DescendingIterator 刚好利用了 ListIterator 向前遍历的方式。可以通过以下的方式来使用：")])),_:1}),s[3604]||(s[3604]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">Iterator it = list.descendingIterator();</span>
<span class="line">while (it.hasNext()) {</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2292]||(s[2292]=[n("好了，关于Iterator与Iterable我们就先聊这么多，总结两点：")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2293]||(s[2293]=[n("学会深入思考，一点点抽丝剥茧，多想想为什么这样实现，很多问题没有自己想象中的那么复杂。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2294]||(s[2294]=[n("遇到疑惑不放弃，这是提升自己最好的机会，遇到某个疑难的点，解决的过程中会挖掘出很多相关的东西。")])),_:1})])]),s[3605]||(s[3605]=a("h2",{id:"foreach-循环陷阱",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#foreach-循环陷阱"},[a("span",null,"foreach 循环陷阱")])],-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2295]||(s[2295]=[n("那天，小二去阿里面试，面试官老王一上来就甩给了他一道面试题：为什么阿里的 Java 开发手册里会强制不要在 foreach 里进行元素的删除操作？")])),_:1}),s[3606]||(s[3606]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726671720267-e0403a0f-5e13-448b-ad54-76d8c736016e.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2296]||(s[2296]=[n("小二听完这句话就乐了。为什么呢？因为一天前他刚在《")])),_:1}),s[3607]||(s[3607]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2297]||(s[2297]=[n("二哥的Java进阶之路")])),_:1}),s[3608]||(s[3608]=n("](https://github.com/itwanger/toBeBetterJavaer)")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2298]||(s[2298]=[n("》上看到过这道题的答案。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2299]||(s[2299]=[n("以下是整篇文章的内容。")])),_:1}),a("h4",Ce,[a("a",Se,[a("span",null,[a("a",Ae,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2300]||(s[2300]=[n("关于fail-fast")])),_:1}),l(r)])])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2301]||(s[2301]=[n("为了镇楼，先搬一段英文来解释一下 fail-fast。")])),_:1}),l(e,{style:{color:"rgb(102, 102, 102)"}},{default:i(()=>s[2302]||(s[2302]=[n("In systems design, a fail-fast system is one which immediately reports at its interface any condition that is likely to indicate a failure. Fail-fast systems are usually designed to stop normal operation rather than attempt to continue a possibly flawed process. Such designs often check the system's state at several points in an operation, so any failures can be detected early. The responsibility of a fail-fast module is detecting errors, then letting the next-highest level of the system handle them.")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2303]||(s[2303]=[n("这段话的大致意思就是，fail-fast 是一种通用的系统设计思想，一旦检测到可能会发生错误，就立马抛出异常，程序将不再往下执行。")])),_:1}),s[3609]||(s[3609]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public void test(Wanger wanger) {   </span>
<span class="line">    if (wanger == null) {</span>
<span class="line">        throw new RuntimeException(&quot;wanger 不能为空&quot;);</span>
<span class="line">    }</span>
<span class="line">    </span>
<span class="line">    System.out.println(wanger.toString());</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2304]||(s[2304]=[n("一旦检测到 wanger 为 null，就立马抛出异常，让调用者来决定这种情况下该怎么处理，下一步")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3610]||(s[3610]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2305]||(s[2305]=[n("wanger.toString()")])),_:1}),s[3611]||(s[3611]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2306]||(s[2306]=[n("就不会执行了——避免更严重的错误出现。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2307]||(s[2307]=[n("很多时候，我们会把 fail-fast 归类为 Java 集合框架的一种错误检测机制，但其实 fail-fast 并不是 Java 集合框架特有的机制。")])),_:1}),a("h4",Ee,[a("a",je,[a("span",null,[a("a",Ie,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2308]||(s[2308]=[n("for-each 删除元素报错")])),_:1}),l(r)])])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2309]||(s[2309]=[n("之所以我们把 fail-fast 放在集合框架篇里介绍，是因为问题比较容易再现。")])),_:1}),s[3612]||(s[3612]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span>
<span class="line">list.add(&quot;沉默王二&quot;);</span>
<span class="line">list.add(&quot;沉默王三&quot;);</span>
<span class="line">list.add(&quot;一个文章真特么有趣的程序员&quot;);</span>
<span class="line"></span>
<span class="line">for (String str : list) {</span>
<span class="line">	if (&quot;沉默王二&quot;.equals(str)) {</span>
<span class="line">		list.remove(str);</span>
<span class="line">	}</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">System.out.println(list);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2310]||(s[2310]=[n("这段代码看起来没有任何问题，但运行起来就报错了。")])),_:1}),s[3613]||(s[3613]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726671720852-27f4738a-a6da-4cf9-8b49-a3fbe5dcdd27.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2311]||(s[2311]=[n("根据错误的堆栈信息，我们可以定位到 ArrayList 的第 901 行代码。")])),_:1}),s[3614]||(s[3614]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">final void checkForComodification() {</span>
<span class="line">    if (modCount != expectedModCount)</span>
<span class="line">        throw new ConcurrentModificationException();</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2312]||(s[2312]=[n("也就是说，remove 的时候触发执行了")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3615]||(s[3615]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2313]||(s[2313]=[n("checkForComodification")])),_:1}),s[3616]||(s[3616]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2314]||(s[2314]=[n("方法，该方法对 modCount 和 expectedModCount 进行了比较，发现两者不等，就抛出了")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3617]||(s[3617]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2315]||(s[2315]=[n("ConcurrentModificationException")])),_:1}),s[3618]||(s[3618]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2316]||(s[2316]=[n("异常。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2317]||(s[2317]=[n("为什么会执行")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3619]||(s[3619]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2318]||(s[2318]=[n("checkForComodification")])),_:1}),s[3620]||(s[3620]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2319]||(s[2319]=[n("方法呢？")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2320]||(s[2320]=[n("是因为 for-each 本质上是个语法糖，底层是通过")])),_:1}),s[3621]||(s[3621]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2321]||(s[2321]=[n("迭代器 Iterator")])),_:1}),s[3622]||(s[3622]=n("](https://javabetter.cn/collection/iterator-iterable.html)")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2322]||(s[2322]=[n("配合 while 循环实现的，来看一下反编译后的字节码。")])),_:1}),s[3623]||(s[3623]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">List&lt;String&gt; list = new ArrayList();</span>
<span class="line">list.add(&quot;沉默王二&quot;);</span>
<span class="line">list.add(&quot;沉默王三&quot;);</span>
<span class="line">list.add(&quot;一个文章真特么有趣的程序员&quot;);</span>
<span class="line">Iterator var2 = list.iterator();</span>
<span class="line"></span>
<span class="line">while(var2.hasNext()) {</span>
<span class="line">    String str = (String)var2.next();</span>
<span class="line">    if (&quot;沉默王二&quot;.equals(str)) {</span>
<span class="line">        list.remove(str);</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">System.out.println(list);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2323]||(s[2323]=[n("来看一下 ArrayList 的 iterator 方法吧：")])),_:1}),s[3624]||(s[3624]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public Iterator&lt;E&gt; iterator() {</span>
<span class="line">    return new Itr();</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2324]||(s[2324]=[n("内部类 Itr 实现了 Iterator 接口，这是 Itr 的源码。")])),_:1}),s[3625]||(s[3625]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">private class Itr implements Iterator&lt;E&gt; {</span>
<span class="line">    int cursor;             // 下一个元素的索引</span>
<span class="line">    int lastRet = -1;       // 上一个返回元素的索引；如果没有则为 -1</span>
<span class="line">    int expectedModCount = modCount; // ArrayList 的修改次数</span>
<span class="line"></span>
<span class="line">    Itr() { }  // 构造函数</span>
<span class="line"></span>
<span class="line">    public boolean hasNext() { // 判断是否还有下一个元素</span>
<span class="line">        return cursor != size;</span>
<span class="line">    }</span>
<span class="line"></span>
<span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line">    public E next() { // 返回下一个元素</span>
<span class="line">        checkForComodification(); // 检查 ArrayList 是否被修改过</span>
<span class="line">        int i = cursor; // 当前索引</span>
<span class="line">        Object[] elementData = ArrayList.this.elementData; // ArrayList 中的元素数组</span>
<span class="line">        if (i &gt;= elementData.length) // 超出数组范围</span>
<span class="line">            throw new ConcurrentModificationException(); // 抛出异常</span>
<span class="line">        cursor = i + 1; // 更新下一个元素的索引</span>
<span class="line">        return (E) elementData[lastRet = i]; // 返回下一个元素</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2325]||(s[2325]=[n("也就是说")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3626]||(s[3626]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2326]||(s[2326]=[n("new Itr()")])),_:1}),s[3627]||(s[3627]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2327]||(s[2327]=[n("的时候 expectedModCount 被赋值为 modCount，而 modCount 是 ArrayList 中的一个计数器，用于记录 ArrayList 对象被修改的次数。ArrayList 的修改操作包括添加、删除、设置元素值等。每次对 ArrayList 进行修改操作时，modCount 的值会自增 1。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2328]||(s[2328]=[n("在迭代 ArrayList 时，如果迭代过程中发现 modCount 的值与迭代器的 expectedModCount 不一致，则说明 ArrayList 已被修改过，此时会抛出 ConcurrentModificationException 异常。这种机制可以保证迭代器在遍历 ArrayList 时，不会遗漏或重复元素，同时也可以在多线程环境下检测到并发修改问题。")])),_:1}),s[3628]||(s[3628]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">protected transient int modCount = 0;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,1)),a("h4",He,[a("a",Te,[a("span",null,[a("a",De,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2329]||(s[2329]=[n("分析代码执行的逻辑")])),_:1}),l(r)])])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2330]||(s[2330]=[n("我们来继续定位之前报错的错误堆栈。这是之前的代码。")])),_:1}),s[3629]||(s[3629]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span>
<span class="line">list.add(&quot;沉默王二&quot;);</span>
<span class="line">list.add(&quot;沉默王三&quot;);</span>
<span class="line">list.add(&quot;一个文章真特么有趣的程序员&quot;);</span>
<span class="line"></span>
<span class="line">for (String str : list) {</span>
<span class="line">	if (&quot;沉默王二&quot;.equals(str)) {</span>
<span class="line">		list.remove(str);</span>
<span class="line">	}</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">System.out.println(list);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2331]||(s[2331]=[n("由于 list 此前执行了 3 次 add 方法。")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2332]||(s[2332]=[n("add 方法调用 ensureCapacityInternal 方法")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2333]||(s[2333]=[n("ensureCapacityInternal 方法调用 ensureExplicitCapacity 方法")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2334]||(s[2334]=[n("ensureExplicitCapacity 方法中会执行")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2336]||(s[2336]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2335]||(s[2335]=[n("modCount++")])),_:1}),s[2337]||(s[2337]=n("`"))])]),s[3630]||(s[3630]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">private void ensureExplicitCapacity(int minCapacity) {</span>
<span class="line">    modCount++;</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2338]||(s[2338]=[n("所以 modCount 的值在经过三次 add 后为 3，于是")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3631]||(s[3631]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2339]||(s[2339]=[n("new Itr()")])),_:1}),s[3632]||(s[3632]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2340]||(s[2340]=[n("后 expectedModCount 的值也为 3（回到前面去看一下 Itr 的源码）。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2341]||(s[2341]=[n("接着来执行 for-each 的循环遍历。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2342]||(s[2342]=[n("执行第一次循环时，发现“沉默王二”等于 str，于是执行")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3633]||(s[3633]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2343]||(s[2343]=[n("list.remove(str)")])),_:1}),s[3634]||(s[3634]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2344]||(s[2344]=[n("。")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2345]||(s[2345]=[n("remove 方法调用 fastRemove 方法")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2346]||(s[2346]=[n("fastRemove 方法中会执行")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2348]||(s[2348]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2347]||(s[2347]=[n("modCount++")])),_:1}),s[2349]||(s[2349]=n("`"))])]),s[3635]||(s[3635]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">private void fastRemove(int index) {</span>
<span class="line">    modCount++;</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2350]||(s[2350]=[n("modCount 的值变成了 4。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2351]||(s[2351]=[n("第二次遍历时，会执行 Itr 的 next 方法（")])),_:1}),s[3636]||(s[3636]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2352]||(s[2352]=[n("String str = (String) var3.next();")])),_:1}),s[3637]||(s[3637]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2353]||(s[2353]=[n("），next 方法就会调用")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3638]||(s[3638]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2354]||(s[2354]=[n("checkForComodification")])),_:1}),s[3639]||(s[3639]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2355]||(s[2355]=[n("方法。")])),_:1}),s[3640]||(s[3640]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">final void checkForComodification() {</span>
<span class="line">    if (modCount != expectedModCount)</span>
<span class="line">        throw new ConcurrentModificationException();</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2356]||(s[2356]=[n("此时 expectedModCount 为 3，modCount 为 4，就只好抛出 ConcurrentModificationException 异常了。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2357]||(s[2357]=[n("那其实在阿里巴巴的 Java 开发手册里也提到了，不要在 for-each 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator 方式。")])),_:1}),s[3641]||(s[3641]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1726671722206-16c4a913-7c33-415a-aa4b-24da5750bcdc.png"},null,-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2358]||(s[2358]=[n("那原因其实就是我们上面分析的这些，出于 fail-fast 保护机制。")])),_:1}),a("h4",Ne,[a("a",Oe,[a("span",null,[a("a",ze,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2359]||(s[2359]=[n("那该如何正确地删除元素呢？")])),_:1}),l(r)])])])]),a("h5",Ve,[a("a",Pe,[a("span",null,[a("a",Fe,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2360]||(s[2360]=[n("1）remove 后 break")])),_:1}),l(r)])])])]),s[3642]||(s[3642]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span>
<span class="line">list.add(&quot;沉默王二&quot;);</span>
<span class="line">list.add(&quot;沉默王三&quot;);</span>
<span class="line">list.add(&quot;一个文章真特么有趣的程序员&quot;);</span>
<span class="line"></span>
<span class="line">for (String str : list) {</span>
<span class="line">	if (&quot;沉默王二&quot;.equals(str)) {</span>
<span class="line">		list.remove(str);</span>
<span class="line">		break;</span>
<span class="line">	}</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2361]||(s[2361]=[n("break 后循环就不再遍历了，意味着 Iterator 的 next 方法不再执行了，也就意味着")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3643]||(s[3643]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2362]||(s[2362]=[n("checkForComodification")])),_:1}),s[3644]||(s[3644]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2363]||(s[2363]=[n("方法不再执行了，所以异常也就不会抛出了。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2364]||(s[2364]=[n("但是呢，当 List 中有重复元素要删除的时候，break 就不合适了。")])),_:1}),a("h5",Ke,[a("a",Re,[a("span",null,[a("a",Be,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2365]||(s[2365]=[n("2）for 循环")])),_:1}),l(r)])])])]),s[3645]||(s[3645]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span>
<span class="line">list.add(&quot;沉默王二&quot;);</span>
<span class="line">list.add(&quot;沉默王三&quot;);</span>
<span class="line">list.add(&quot;一个文章真特么有趣的程序员&quot;);</span>
<span class="line">for (int i = 0; i &lt; list.size(); i++) {</span>
<span class="line">	String str = list.get(i);</span>
<span class="line">	if (&quot;沉默王二&quot;.equals(str)) {</span>
<span class="line">		list.remove(str);</span>
<span class="line">	}</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2366]||(s[2366]=[n("for 循环虽然可以避开 fail-fast 保护机制，也就说 remove 元素后不再抛出异常；但是呢，这段程序在原则上是有问题的。为什么呢？")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2367]||(s[2367]=[n("第一次循环的时候，i 为 0，")])),_:1}),s[3646]||(s[3646]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2368]||(s[2368]=[n("list.size()")])),_:1}),s[3647]||(s[3647]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2369]||(s[2369]=[n("为 3，当执行完 remove 方法后，i 为 1，")])),_:1}),s[3648]||(s[3648]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2370]||(s[2370]=[n("list.size()")])),_:1}),s[3649]||(s[3649]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2371]||(s[2371]=[n("却变成了 2，因为 list 的大小在 remove 后发生了变化，也就意味着“沉默王三”这个元素被跳过了。能明白吗？")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2372]||(s[2372]=[n("remove 之前")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3650]||(s[3650]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2373]||(s[2373]=[n("list.get(1)")])),_:1}),s[3651]||(s[3651]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2374]||(s[2374]=[n("为“沉默王三”；但 remove 之后")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3652]||(s[3652]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2375]||(s[2375]=[n("list.get(1)")])),_:1}),s[3653]||(s[3653]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2376]||(s[2376]=[n("变成了“一个文章真特么有趣的程序员”，而")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3654]||(s[3654]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2377]||(s[2377]=[n("list.get(0)")])),_:1}),s[3655]||(s[3655]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2378]||(s[2378]=[n("变成了“沉默王三”。")])),_:1}),a("h5",Qe,[a("a",Ue,[a("span",null,[a("a",Je,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2379]||(s[2379]=[n("3）使用 Iterator")])),_:1}),l(r)])])])]),s[3656]||(s[3656]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span>
<span class="line">list.add(&quot;沉默王二&quot;);</span>
<span class="line">list.add(&quot;沉默王三&quot;);</span>
<span class="line">list.add(&quot;一个文章真特么有趣的程序员&quot;);</span>
<span class="line"></span>
<span class="line">Iterator&lt;String&gt; itr = list.iterator();</span>
<span class="line"></span>
<span class="line">while (itr.hasNext()) {</span>
<span class="line">	String str = itr.next();</span>
<span class="line">	if (&quot;沉默王二&quot;.equals(str)) {</span>
<span class="line">		itr.remove();</span>
<span class="line">	}</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2380]||(s[2380]=[n("为什么使用 Iterator 的 remove 方法就可以避开 fail-fast 保护机制呢？看一下 remove 的源码就明白了。")])),_:1}),s[3657]||(s[3657]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public void remove() {</span>
<span class="line">    if (lastRet &lt; 0) // 如果没有上一个返回元素的索引，则抛出异常</span>
<span class="line">        throw new IllegalStateException();</span>
<span class="line">    checkForComodification(); // 检查 ArrayList 是否被修改过</span>
<span class="line"></span>
<span class="line">    try {</span>
<span class="line">        ArrayList.this.remove(lastRet); // 删除上一个返回元素</span>
<span class="line">        cursor = lastRet; // 更新下一个元素的索引</span>
<span class="line">        lastRet = -1; // 清空上一个返回元素的索引</span>
<span class="line">        expectedModCount = modCount; // 更新 ArrayList 的修改次数</span>
<span class="line">    } catch (IndexOutOfBoundsException ex) {</span>
<span class="line">        throw new ConcurrentModificationException(); // 抛出异常</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2381]||(s[2381]=[n("删除完会执行")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3658]||(s[3658]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2382]||(s[2382]=[n("expectedModCount = modCount")])),_:1}),s[3659]||(s[3659]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2383]||(s[2383]=[n("，保证了 expectedModCount 与 modCount 的同步。")])),_:1}),a("h4",Ye,[a("a",$e,[a("span",null,[a("a",We,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2384]||(s[2384]=[n("小结")])),_:1}),l(r)])])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2385]||(s[2385]=[n("为什么不能在foreach里执行删除操作？")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2386]||(s[2386]=[n("因为 foreach 循环是基于迭代器实现的，而迭代器在遍历集合时会维护一个 expectedModCount 属性来记录集合被修改的次数。如果在 foreach 循环中执行删除操作会导致 expectedModCount 属性值与实际的 modCount 属性值不一致，从而导致迭代器的 hasNext() 和 next() 方法抛出 ConcurrentModificationException 异常。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2387]||(s[2387]=[n("为了避免这种情况，应该使用迭代器的 remove() 方法来删除元素，该方法会在删除元素后更新迭代器状态，确保循环的正确性。如果需要在循环中删除元素，应该使用迭代器的 remove() 方法，而不是集合自身的 remove() 方法。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2388]||(s[2388]=[n("就像这样。")])),_:1}),s[3660]||(s[3660]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span>
<span class="line">list.add(&quot;沉默王二&quot;);</span>
<span class="line">list.add(&quot;沉默王三&quot;);</span>
<span class="line">list.add(&quot;一个文章真特么有趣的程序员&quot;);</span>
<span class="line"></span>
<span class="line">Iterator&lt;String&gt; itr = list.iterator();</span>
<span class="line"></span>
<span class="line">while (itr.hasNext()) {</span>
<span class="line">	String str = itr.next();</span>
<span class="line">	if (&quot;沉默王二&quot;.equals(str)) {</span>
<span class="line">		itr.remove();</span>
<span class="line">	}</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2389]||(s[2389]=[n("除此之外，我们还可以采用")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3661]||(s[3661]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2390]||(s[2390]=[n("Stream 流")])),_:1}),s[3662]||(s[3662]=n("](https://javabetter.cn/java8/stream.html)")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2391]||(s[2391]=[n("的filter() 方法来过滤集合中的元素，然后再通过 collect() 方法将过滤后的元素收集到一个新的集合中。")])),_:1}),s[3663]||(s[3663]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;沉默&quot;, &quot;王二&quot;, &quot;陈清扬&quot;));</span>
<span class="line">list = list.stream().filter(s -&gt; !s.equals(&quot;陈清扬&quot;)).collect(Collectors.toList());</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2392]||(s[2392]=[n("好了，关于这个问题，就聊到这里吧，希望能帮助到你。")])),_:1}),a("h2",Xe,[a("a",Ge,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2393]||(s[2393]=[n("Comparable 和 Comparator")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2394]||(s[2394]=[n("Comparable 和 Comparator 是 Java 的两个接口，从名字上我们就能够读出来它们俩的相似性：以某种方式来比较两个对象。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2395]||(s[2395]=[n("但它们之间到底有什么区别呢？请随我来，打怪进阶喽！")])),_:1}),a("h3",Ze,[a("a",he,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2396]||(s[2396]=[n("Comparable")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2397]||(s[2397]=[n("Comparable 接口的定义非常简单，源码如下所示。")])),_:1}),s[3664]||(s[3664]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public interface Comparable&lt;T&gt; {</span>
<span class="line">    int compareTo(T t);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2398]||(s[2398]=[n("如果一个类实现了 Comparable 接口（只需要干一件事，重写")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3665]||(s[3665]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2399]||(s[2399]=[n("compareTo()")])),_:1}),s[3666]||(s[3666]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2400]||(s[2400]=[n("方法），就可以按照自己制定的规则将由它创建的对象进行比较。下面给出一个例子。")])),_:1}),s[3667]||(s[3667]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public class Cmower implements Comparable&lt;Cmower&gt; {</span>
<span class="line">    private int age;</span>
<span class="line">    private String name;</span>
<span class="line"></span>
<span class="line">    public Cmower(int age, String name) {</span>
<span class="line">        this.age = age;</span>
<span class="line">        this.name = name;</span>
<span class="line">    }</span>
<span class="line"></span>
<span class="line">    @Override</span>
<span class="line">    public int compareTo(Cmower o) {</span>
<span class="line">        return this.getAge() - o.getAge();</span>
<span class="line">    }</span>
<span class="line"></span>
<span class="line">    public static void main(String[] args) {</span>
<span class="line">        Cmower wanger = new Cmower(19,&quot;沉默王二&quot;);</span>
<span class="line">        Cmower wangsan = new Cmower(16,&quot;沉默王三&quot;);</span>
<span class="line"></span>
<span class="line">        if (wanger.compareTo(wangsan) &lt; 0) {</span>
<span class="line">            System.out.println(wanger.getName() + &quot;比较年轻有为&quot;);</span>
<span class="line">        } else {</span>
<span class="line">            System.out.println(wangsan.getName() + &quot;比较年轻有为&quot;);</span>
<span class="line">        }</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2401]||(s[2401]=[n("在上面的示例中，我创建了一个 Cmower 类，它有两个字段：age 和 name。Cmower 类实现了 Comparable 接口，并重写了")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3668]||(s[3668]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2402]||(s[2402]=[n("compareTo()")])),_:1}),s[3669]||(s[3669]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2403]||(s[2403]=[n("方法。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2404]||(s[2404]=[n("程序输出的结果是“沉默王三比较年轻有为”，因为他比沉默王二小三岁。这个结果有什么凭证吗？")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2405]||(s[2405]=[n("凭证就在于")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3670]||(s[3670]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2406]||(s[2406]=[n("compareTo()")])),_:1}),s[3671]||(s[3671]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2407]||(s[2407]=[n("方法，该方法的返回值可能为负数，零或者正数，代表的意思是该对象按照排序的规则小于、等于或者大于要比较的对象。如果指定对象的类型与此对象不能进行比较，则引发")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3672]||(s[3672]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2408]||(s[2408]=[n("ClassCastException")])),_:1}),s[3673]||(s[3673]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2409]||(s[2409]=[n("异常（自从有了")])),_:1}),s[3674]||(s[3674]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2410]||(s[2410]=[n("泛型")])),_:1}),s[3675]||(s[3675]=n("](https://javabetter.cn/basic-extra-meal/generic.html)")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2411]||(s[2411]=[n("，这种情况就少有发生了）。")])),_:1}),a("h3",_e,[a("a",si,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2412]||(s[2412]=[n("Comparator")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2413]||(s[2413]=[n("Comparator 接口的定义相比较于 Comparable 就复杂的多了，不过，核心的方法只有两个，来看一下源码。")])),_:1}),s[3676]||(s[3676]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public interface Comparator&lt;T&gt; {</span>
<span class="line">    int compare(T o1, T o2);</span>
<span class="line">    boolean equals(Object obj);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2414]||(s[2414]=[n("第一个方法")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3677]||(s[3677]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2415]||(s[2415]=[n("compare(T o1, T o2)")])),_:1}),s[3678]||(s[3678]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2416]||(s[2416]=[n("的返回值可能为负数，零或者正数，代表的意思是第一个对象小于、等于或者大于第二个对象。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2417]||(s[2417]=[n("第二个方法")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3679]||(s[3679]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2418]||(s[2418]=[n("equals(Object obj)")])),_:1}),s[3680]||(s[3680]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2419]||(s[2419]=[n("需要传入一个 Object 作为参数，并判断该 Object 是否和 Comparator 保持一致。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2420]||(s[2420]=[n("有时候，我们想让类保持它的原貌，不想主动实现 Comparable 接口，但我们又需要它们之间进行比较，该怎么办呢？")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2421]||(s[2421]=[n("Comparator 就派上用场了，来看一下示例。")])),_:1}),a("h4",ni,[a("a",li,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2422]||(s[2422]=[n("原封不动的 Cmower 类。")])),_:1})])])]),s[3681]||(s[3681]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public class Cmower  {</span>
<span class="line">    private int age;</span>
<span class="line">    private String name;</span>
<span class="line"></span>
<span class="line">    public Cmower(int age, String name) {</span>
<span class="line">        this.age = age;</span>
<span class="line">        this.name = name;</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2423]||(s[2423]=[n("Cmower 类有两个字段：age 和 name，意味着该类可以按照 age 或者 name 进行排序。")])),_:1}),a("h4",ei,[a("a",ii,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2424]||(s[2424]=[n("再来看 Comparator 接口的实现类。")])),_:1})])])]),s[3682]||(s[3682]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public class CmowerComparator implements Comparator&lt;Cmower&gt; {</span>
<span class="line">    @Override</span>
<span class="line">    public int compare(Cmower o1, Cmower o2) {</span>
<span class="line">        return o1.getAge() - o2.getAge();</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2425]||(s[2425]=[n("按照 age 进行比较。当然也可以再实现一个比较器，按照 name 进行自然排序，示例如下。")])),_:1}),s[3683]||(s[3683]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public class CmowerNameComparator implements Comparator&lt;Cmower&gt; {</span>
<span class="line">    @Override</span>
<span class="line">    public int compare(Cmower o1, Cmower o2) {</span>
<span class="line">        if (o1.getName().hashCode() &lt; o2.getName().hashCode()) {</span>
<span class="line">            return -1;</span>
<span class="line">        } else if (o1.getName().hashCode() == o2.getName().hashCode()) {</span>
<span class="line">            return 0;</span>
<span class="line">        }</span>
<span class="line">        return 1;</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),a("h4",ai,[a("a",ti,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2426]||(s[2426]=[n("再来看测试类。")])),_:1})])])]),s[3684]||(s[3684]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">Cmower wanger = new Cmower(19,&quot;沉默王二&quot;);</span>
<span class="line">Cmower wangsan = new Cmower(16,&quot;沉默王三&quot;);</span>
<span class="line">Cmower wangyi = new Cmower(28,&quot;沉默王一&quot;);</span>
<span class="line"></span>
<span class="line">List&lt;Cmower&gt; list = new ArrayList&lt;&gt;();</span>
<span class="line">list.add(wanger);</span>
<span class="line">list.add(wangsan);</span>
<span class="line">list.add(wangyi);</span>
<span class="line"></span>
<span class="line">list.sort(new CmowerComparator());</span>
<span class="line"></span>
<span class="line">for (Cmower c : list) {</span>
<span class="line">    System.out.println(c.getName());</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2427]||(s[2427]=[n("创建了三个对象，age 不同，name 不同，并把它们加入到了 List 当中。然后使用 List 的")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3685]||(s[3685]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2428]||(s[2428]=[n("sort()")])),_:1}),s[3686]||(s[3686]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2429]||(s[2429]=[n("方法进行排序，来看一下输出的结果。")])),_:1}),s[3687]||(s[3687]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">沉默王三</span>
<span class="line">沉默王二</span>
<span class="line">沉默王一</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2430]||(s[2430]=[n("这意味着沉默王三的年纪比沉默王二小，排在第一位；沉默王一的年纪比沉默王二大，排在第三位。和我们的预期完全符合。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2431]||(s[2431]=[n("借此机会，再来看一下 sort 方法的源码：")])),_:1}),s[3688]||(s[3688]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">public void sort(Comparator&lt;? super E&gt; c) {</span>
<span class="line">    // 保存当前队列的 modCount 值，用于检测 sort 操作是否非法</span>
<span class="line">    final int expectedModCount = modCount;</span>
<span class="line">    // 调用 Arrays.sort 对 elementData 数组进行排序，使用传入的比较器 c</span>
<span class="line">    Arrays.sort((E[]) elementData, 0, size, c);</span>
<span class="line">    // 检查操作期间 modCount 是否被修改，如果被修改则抛出并发修改异常</span>
<span class="line">    if (modCount != expectedModCount) {</span>
<span class="line">        throw new ConcurrentModificationException();</span>
<span class="line">    }</span>
<span class="line">    // 增加 modCount 值，表示队列已经被修改过</span>
<span class="line">    modCount++;</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2432]||(s[2432]=[n("可以看到，参数就是一个 Comparator 接口，并且使用了")])),_:1}),a("p",null,[a("a",ri,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2433]||(s[2433]=[n("泛型")])),_:1}),l(r)])]),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[3689]||(s[3689]=a("p",null,[a("code",null,"Comparator<? super E> c")],-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2434]||(s[2434]=[n("。")])),_:1}),a("h3",di,[a("a",pi,[a("span",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2435]||(s[2435]=[n("到底该用哪一个？")])),_:1})])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2436]||(s[2436]=[n("通过上面的两个例子可以比较出 Comparable 和 Comparator 两者之间的区别：")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2437]||(s[2437]=[n("一个类实现了 Comparable 接口，意味着该类的对象可以直接进行比较（排序），但比较（排序）的方式只有一种，很单一。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2438]||(s[2438]=[n("一个类如果想要保持原样，又需要进行不同方式的比较（排序），就可以定制比较器（实现 Comparator 接口）。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2439]||(s[2439]=[n("Comparable 接口在")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2446]||(s[2446]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2440]||(s[2440]=[n("java.lang")])),_:1}),s[2447]||(s[2447]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2441]||(s[2441]=[n("包下，而")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2448]||(s[2448]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2442]||(s[2442]=[n("Comparator")])),_:1}),s[2449]||(s[2449]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2443]||(s[2443]=[n("接口在")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}}),s[2450]||(s[2450]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2444]||(s[2444]=[n("java.util")])),_:1}),s[2451]||(s[2451]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2445]||(s[2445]=[n("包下，算不上是亲兄弟，但可以称得上是表（堂）兄弟。")])),_:1})])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2452]||(s[2452]=[n("举个不恰当的例子。我想从洛阳出发去北京看长城，体验一下好汉的感觉，要么坐飞机，要么坐高铁；但如果是孙悟空的话，翻个筋斗就到了。我和孙悟空之间有什么区别呢？")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2453]||(s[2453]=[n("孙悟空自己实现了 Comparable 接口（他那年代也没有飞机和高铁，没得选），而我可以借助 Comparator 接口（现代化的交通工具）。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2454]||(s[2454]=[n("好了，关于 Comparable 和 Comparator 我们就先聊这么多。总而言之，如果对象的排序需要基于自然顺序，请选择 ")])),_:1}),s[3690]||(s[3690]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2455]||(s[2455]=[n("Comparable")])),_:1}),s[3691]||(s[3691]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2456]||(s[2456]=[n("，如果需要按照对象的不同属性进行排序，请选择 ")])),_:1}),s[3692]||(s[3692]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2457]||(s[2457]=[n("Comparator")])),_:1}),s[3693]||(s[3693]=n("`")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2458]||(s[2458]=[n("。")])),_:1}),s[3694]||(s[3694]=a("h2",{id:"weakhashmap-详解",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#weakhashmap-详解"},[a("span",null,"WeakHashMap 详解")])],-1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2459]||(s[2459]=[n("在Java中，我们一般都会使用到Map，比如")])),_:1}),s[3695]||(s[3695]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2460]||(s[2460]=[n("HashMap")])),_:1}),s[3696]||(s[3696]=n("](https://javabetter.cn/collection/hashmap.html)")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2461]||(s[2461]=[n("这样的具体实现。更高级一点，我们可能会使用WeakHashMap。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2462]||(s[2462]=[n("WeakHashMap其实和HashMap大多数行为是一样的，只是WeakHashMap不会阻止GC回收key对象（不是value），那么WeakHashMap是怎么做到的呢，这就是我们研究的主要问题。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2463]||(s[2463]=[n("在开始WeakHashMap之前，我们先要对弱引用有一定的了解。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2464]||(s[2464]=[n("在Java中，有四种引用类型")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2465]||(s[2465]=[n("强引用(Strong Reference)，我们正常编码时默认的引用类型，强应用之所以为强，是因为如果一个对象到GC Roots强引用可到达，就可以阻止GC回收该对象")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2466]||(s[2466]=[n("软引用（Soft Reference）阻止GC回收的能力相对弱一些，如果是软引用可以到达，那么这个对象会停留在内存更时间上长一些。当内存不足时垃圾回收器才会回收这些软引用可到达的对象")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2467]||(s[2467]=[n("弱引用（WeakReference）无法阻止GC回收，如果一个对象时弱引用可到达，那么在下一个GC回收执行时，该对象就会被回收掉。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2468]||(s[2468]=[n("虚引用（Phantom Reference）十分脆弱，它的唯一作用就是当其指向的对象被回收之后，自己被加入到引用队列，用作记录该引用指向的对象已被销毁")])),_:1})])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2469]||(s[2469]=[n("这其中还有一个概念叫做引用队列(Reference Queue)")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2470]||(s[2470]=[n("一般情况下，一个对象标记为垃圾（并不代表回收了）后，会加入到引用队列。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2471]||(s[2471]=[n("对于虚引用来说，它指向的对象会只有被回收后才会加入引用队列，所以可以用作记录该引用指向的对象是否回收。")])),_:1})])]),a("h3",oi,[a("a",ui,[a("span",null,[a("a",vi,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2472]||(s[2472]=[n("WeakHashMap如何不阻止对象回收呢")])),_:1}),l(r)])])])]),s[3697]||(s[3697]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">private static final class Entry&lt;K, V&gt; extends WeakReference&lt;K&gt; implements</span>
<span class="line">  Map.Entry&lt;K, V&gt; {</span>
<span class="line">  int hash;</span>
<span class="line">  boolean isNull;</span>
<span class="line">  V value;</span>
<span class="line">  Entry&lt;K, V&gt; next;</span>
<span class="line">  interface Type&lt;R, K, V&gt; {</span>
<span class="line">  R get(Map.Entry&lt;K, V&gt; entry);</span>
<span class="line">  }</span>
<span class="line">  Entry(K key, V object, ReferenceQueue&lt;K&gt; queue) {</span>
<span class="line">  super(key, queue);</span>
<span class="line">  isNull = key == null;</span>
<span class="line">  hash = isNull ? 0 : key.hashCode();</span>
<span class="line">  value = object;</span>
<span class="line">  }</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2473]||(s[2473]=[n("如源码所示，")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2474]||(s[2474]=[n("WeakHashMap的Entry继承了WeakReference。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2475]||(s[2475]=[n("其中Key作为了WeakReference指向的对象")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2476]||(s[2476]=[n("因此WeakHashMap利用了WeakReference的机制来实现不阻止GC回收Key")])),_:1})])]),a("h3",bi,[a("a",mi,[a("span",null,[a("a",gi,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2477]||(s[2477]=[n("如何删除被回收的key数据呢")])),_:1}),l(r)])])])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2478]||(s[2478]=[n("在Javadoc中关于WeakHashMap有这样的描述，当key不再引用时，其对应的key/value也会被移除。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2479]||(s[2479]=[n("那么是如何移除的呢，这里我们通常有两种假设策略")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2480]||(s[2480]=[n("当对象被回收的时候，进行通知")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2481]||(s[2481]=[n("WeakHashMap轮询处理时效的Entry")])),_:1})])]),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2482]||(s[2482]=[n("而WeakHashMap采用的是轮询的形式，在其put/get/size等方法调用的时候都会预先调用一个poll的方法，来检查并删除失效的Entry")])),_:1}),s[3698]||(s[3698]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">void poll() {</span>
<span class="line">  Entry&lt;K, V&gt; toRemove;</span>
<span class="line">  while ((toRemove = (Entry&lt;K, V&gt;) referenceQueue.poll()) != null) {</span>
<span class="line">  removeEntry(toRemove);</span>
<span class="line">  Log.d(LOGTAG, &quot;removeEntry=&quot; + toRemove.value);</span>
<span class="line">  }</span>
<span class="line"> }</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2483]||(s[2483]=[n("为什么没有使用看似更好的通知呢，我想是因为在Java中没有一个可靠的通知回调，比如大家常说的finalize方法，其实也不是标准的，不同的JVM可以实现不同，甚至是不调用这个方法。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2484]||(s[2484]=[n("当然除了单纯的看源码，进行合理的验证是检验分析正确的一个重要方法。")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2485]||(s[2485]=[n("这里首先，我们定义一个MyObject类，处理一下finalize方法（在我的测试机上可以正常调用，仅仅做为辅助验证手段）")])),_:1}),s[3699]||(s[3699]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">class MyObject(val id: String) : Any() {</span>
<span class="line">  protected fun finalize() {</span>
<span class="line">  Log.i(&quot;MainActivity&quot;, &quot;Object($id) finalize method is called&quot;)</span>
<span class="line">  }</span>
<span class="line"> }</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2486]||(s[2486]=[n("然后是调用者的代码，如下")])),_:1}),s[3700]||(s[3700]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">private val weakHashMap = WeakHashMap&lt;Any, Int&gt;()</span>
<span class="line"> var count : Int = 0</span>
<span class="line"> override fun onCreate(savedInstanceState: Bundle?) {</span>
<span class="line">  super.onCreate(savedInstanceState)</span>
<span class="line">  setContentView(R.layout.activity_main)</span>
<span class="line">  setSupportActionBar(toolbar)</span>
<span class="line">  dumpWeakInfo()</span>
<span class="line">  fab.setOnClickListener { view -&gt;</span>
<span class="line">  //System.gc()// this seldom works use Android studio force gc stop</span>
<span class="line">  weakHashMap.put(MyObject(count.toString()), count)</span>
<span class="line">  count ++</span>
<span class="line">  dumpWeakInfo()</span>
<span class="line">  Snackbar.make(view, &quot;Replace with your own action&quot;, Snackbar.LENGTH_LONG)</span>
<span class="line">  .setAction(&quot;Action&quot;, null).show()</span>
<span class="line">  }</span>
<span class="line"> }</span>
<span class="line">  fun dumpWeakInfo() {</span>
<span class="line">  Log.i(&quot;MainActivity&quot;, &quot;dumpWeakInfo weakInfo.size=\${weakHashMap.size}&quot;)</span>
<span class="line"> }</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2487]||(s[2487]=[n("我们按照如下操作")])),_:1}),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2488]||(s[2488]=[n("点击fab控件，每次对WeakhashMap对象增加一个Entry，并打印WeakHashMap的size 执行3此")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2489]||(s[2489]=[n("在没有强制触发GC时，WeakHashMap对象size一直会增加")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2490]||(s[2490]=[n("手动出发Force GC，我们会看到MyObject有finalize方法被调用")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2491]||(s[2491]=[n("再次点击fab空间，然后输出的WeakHashMap size急剧减少。")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2492]||(s[2492]=[n("同样我们收到在WeakHashMap增加的日志也会输出")])),_:1})])]),s[3701]||(s[3701]=t(`<div class="language-plain line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="language-plain"><code><span class="line">I/MainActivity(10202): dumpWeakInfo weakInfo.size=1</span>
<span class="line"> I/MainActivity(10202): dumpWeakInfo weakInfo.size=2</span>
<span class="line"> I/MainActivity(10202): dumpWeakInfo weakInfo.size=3</span>
<span class="line"> I/MainActivity(10202): Object(2) finalize method is called</span>
<span class="line"> I/MainActivity(10202): Object(1) finalize method is called</span>
<span class="line"> I/MainActivity(10202): Object(0) finalize method is called</span>
<span class="line"> I/WeakHashMap(10202): removeEntry=2</span>
<span class="line"> I/WeakHashMap(10202): removeEntry=0</span>
<span class="line"> I/WeakHashMap(10202): removeEntry=1</span>
<span class="line"> I/MainActivity(10202): dumpWeakInfo weakInfo.size=1</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2493]||(s[2493]=[n("注意：System.gc()并不一定可以工作,建议使用Android Studio的Force GC")])),_:1}),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2494]||(s[2494]=[n("完整的测试代码可以访问这里 ")])),_:1}),s[3702]||(s[3702]=n("[")),l(e,{style:{color:"rgb(44, 62, 80)"}},{default:i(()=>s[2495]||(s[2495]=[n("https://github.com/androidyue/WeakHashMapSample")])),_:1}),s[3703]||(s[3703]=n("](https://github.com/androidyue/WeakHashMapSample)")),s[3704]||(s[3704]=a("h2",{id:"-1",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#-1"},[a("span")])],-1)),s[3705]||(s[3705]=a("p",null,"打开idea 按ctrl+n 输入ArrayList",-1)),s[3706]||(s[3706]=a("p",null,"点All places",-1)),s[3707]||(s[3707]=a("p",null,"代码有点多 可以把源码大纲罗列出来：",-1)),s[3708]||(s[3708]=a("p",null,"alt + 7",-1)),s[3709]||(s[3709]=a("p",null,"ctrl + F12",-1)),a("h2",yi,[a("a",fi,[a("span",null,[l(e,{style:{color:"rgb(0, 0, 0)"}},{default:i(()=>s[2496]||(s[2496]=[n("compute 简介(")])),_:1}),l(e,{style:{color:"rgb(0, 0, 0)"}},{default:i(()=>s[2497]||(s[2497]=[n("Java 8 新增")])),_:1}),l(e,{style:{color:"rgb(0, 0, 0)"}},{default:i(()=>s[2498]||(s[2498]=[n(")")])),_:1})])])]),l(e,{style:{color:"rgb(0, 0, 0)"}},{default:i(()=>s[2499]||(s[2499]=[n("如下所示，Java 8 在 ")])),_:1}),s[3710]||(s[3710]=n("**")),l(e,{style:{color:"rgb(0, 0, 0)"}},{default:i(()=>s[2500]||(s[2500]=[n("Map 和 ConcurrentMap")])),_:1}),s[3711]||(s[3711]=n("**")),l(e,{style:{color:"rgb(0, 0, 0)"}},{default:i(()=>s[2501]||(s[2501]=[n(" 接口中都增加了 3 个 ")])),_:1}),l(e,{style:{color:"rgb(192, 52, 29)","background-color":"rgb(251, 229, 225)"}},{default:i(()=>s[2502]||(s[2502]=[n("compute")])),_:1}),l(e,{style:{color:"rgb(0, 0, 0)"}},{default:i(()=>s[2503]||(s[2503]=[n(" 方法，说明也是")])),_:1}),s[3712]||(s[3712]=n("**")),l(e,{style:{color:"rgb(0, 0, 0)"}},{default:i(()=>s[2504]||(s[2504]=[n("支持多线程并发安全操作")])),_:1}),s[3713]||(s[3713]=n("**")),l(e,{style:{color:"rgb(0, 0, 0)"}},{default:i(()=>s[2505]||(s[2505]=[n("的。 ")])),_:1}),s[3714]||(s[3714]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1716687683469-661c0e36-465a-475a-9e9b-fbdb5a94ce96.png"},null,-1)),s[3715]||(s[3715]=a("img",{referrerpolicy:"no-referrer",src:"https://cdn.nlark.com/yuque/0/2024/png/35376129/1716687683472-0bc80f7e-5baf-4132-b9c4-fb04bee3dc91.png"},null,-1)),a("p",null,[a("strong",null,[l(e,{style:{color:"rgb(0, 0, 0)"}},{default:i(()=>s[2506]||(s[2506]=[n("这三个方法的区别：")])),_:1})])]),a("ul",null,[a("li",null,[l(e,{style:{color:"rgb(0, 0, 0)"}},{default:i(()=>s[2507]||(s[2507]=[n("compute：计算并更新值")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(0, 0, 0)"}},{default:i(()=>s[2508]||(s[2508]=[n("computeIfAbsent：Value不存在时才计算")])),_:1})]),a("li",null,[l(e,{style:{color:"rgb(0, 0, 0)"}},{default:i(()=>s[2509]||(s[2509]=[n("computeIfPresent：Value存在时才计算")])),_:1})])]),a("h3",ki,[a("a",ci,[a("span",null,[l(e,{style:{color:"rgb(0, 0, 0)"}},{default:i(()=>s[2510]||(s[2510]=[n("compute有啥用?")])),_:1})])])]),l(e,{style:{color:"rgb(0, 0, 0)"}},{default:i(()=>s[2511]||(s[2511]=[n("先看看没用 Java 8 的一个小示例：")])),_:1}),s[3716]||(s[3716]=t(`<div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="line"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">preJava8</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    List<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span> animals <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">&quot;dog&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;cat&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;cat&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;dog&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;fish&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;dog&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">&gt;</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap<span class="token operator">&lt;</span><span class="token operator">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">for</span><span class="token punctuation">(</span>String animal <span class="token operator">:</span> animals<span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">        Integer count <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>animal<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>animal<span class="token punctuation">,</span> count <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token operator">++</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(0, 0, 0)"}},{default:i(()=>s[2512]||(s[2512]=[n("输出：")])),_:1}),l(e,{style:{color:"rgb(0, 0, 0)"}},{default:i(()=>s[2513]||(s[2513]=[n("这是一个统计一个列表中每个动物的数量，代码再怎么精简都需要一步")])),_:1}),l(e,{style:{color:"rgb(0, 0, 0)"}}),l(e,{style:{color:"rgb(192, 52, 29)","background-color":"rgb(251, 229, 225)"}},{default:i(()=>s[2514]||(s[2514]=[n("get")])),_:1}),l(e,{style:{color:"rgb(0, 0, 0)"}}),l(e,{style:{color:"rgb(0, 0, 0)"}},{default:i(()=>s[2515]||(s[2515]=[n("操作，判断集合中是否有元素再确定是初始化：1，还是需要 +1。")])),_:1}),l(e,{style:{color:"rgb(0, 0, 0)"}},{default:i(()=>s[2516]||(s[2516]=[n("很多时候，这个")])),_:1}),l(e,{style:{color:"rgb(0, 0, 0)"}}),l(e,{style:{color:"rgb(192, 52, 29)","background-color":"rgb(251, 229, 225)"}},{default:i(()=>s[2517]||(s[2517]=[n("get")])),_:1}),l(e,{style:{color:"rgb(0, 0, 0)"}}),l(e,{style:{color:"rgb(0, 0, 0)"}},{default:i(()=>s[2518]||(s[2518]=[n("操作显然是毫无必要的，所以 Java 8 提供了 3 个")])),_:1}),l(e,{style:{color:"rgb(0, 0, 0)"}}),l(e,{style:{color:"rgb(192, 52, 29)","background-color":"rgb(251, 229, 225)"}},{default:i(()=>s[2519]||(s[2519]=[n("compute")])),_:1}),l(e,{style:{color:"rgb(0, 0, 0)"}}),l(e,{style:{color:"rgb(0, 0, 0)"}},{default:i(()=>s[2520]||(s[2520]=[n("方法，来看看怎么用吧！")])),_:1}),a("p",null,[a("strong",null,[l(e,{style:{color:"rgb(0, 0, 0)"}},{default:i(()=>s[2521]||(s[2521]=[n("Java 8 compute 实现方式：")])),_:1})])]),s[3717]||(s[3717]=t(`<div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="line"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">inJava8</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    List<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span> animals <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">&quot;dog&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;cat&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;cat&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;dog&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;fish&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;dog&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">&gt;</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap<span class="token operator">&lt;</span><span class="token operator">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">for</span><span class="token punctuation">(</span>String animal <span class="token operator">:</span> animals<span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">        map<span class="token punctuation">.</span><span class="token function">compute</span><span class="token punctuation">(</span>animal<span class="token punctuation">,</span> <span class="token punctuation">(</span>k<span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> v <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token operator">++</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(0, 0, 0)"}},{default:i(()=>s[2522]||(s[2522]=[n("使用 ")])),_:1}),l(e,{style:{color:"rgb(192, 52, 29)","background-color":"rgb(251, 229, 225)"}},{default:i(()=>s[2523]||(s[2523]=[n("compute")])),_:1}),l(e,{style:{color:"rgb(0, 0, 0)"}},{default:i(()=>s[2524]||(s[2524]=[n(" 方法一行搞定，省去了需要使用 ")])),_:1}),l(e,{style:{color:"rgb(192, 52, 29)","background-color":"rgb(251, 229, 225)"}},{default:i(()=>s[2525]||(s[2525]=[n("get")])),_:1}),l(e,{style:{color:"rgb(0, 0, 0)"}},{default:i(()=>s[2526]||(s[2526]=[n(" 取值再判断的冗余操作，直接就可以获取元素值并计算更新")])),_:1}),a("h3",qi,[a("a",xi,[a("span",null,[l(e,{style:{color:"rgb(0, 0, 0)"}},{default:i(()=>s[2527]||(s[2527]=[n("compute 源码分析")])),_:1})])])]),l(e,{style:{color:"rgb(0, 0, 0)"}},{default:i(()=>s[2528]||(s[2528]=[n("这还是一个默认方法，为什么是默认方法，也是为了不改动其所有实现类")])),_:1}),s[3718]||(s[3718]=t(`<div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">default</span> <span class="token class-name">V</span> <span class="token function">compute</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span></span>
<span class="line">        <span class="token class-name">BiFunction</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">V</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> remappingFunction<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        </span>
<span class="line">    <span class="token comment">// 函数式接口不能为空    </span></span>
<span class="line">    <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>remappingFunction<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    </span>
<span class="line">    <span class="token comment">// 获取旧值</span></span>
<span class="line">    <span class="token class-name">V</span> oldValue <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// 获取计算的新值</span></span>
<span class="line">    <span class="token class-name">V</span> newValue <span class="token operator">=</span> remappingFunction<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    </span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>newValue <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 新值为空</span></span>
<span class="line">        <span class="token comment">// delete mapping</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldValue <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token function">containsKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 旧值存在时</span></span>
<span class="line">            <span class="token comment">// 移除该键值</span></span>
<span class="line">            <span class="token function">remove</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token comment">// nothing to do. Leave things as they were.</span></span>
<span class="line">            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 新值不为空</span></span>
<span class="line">        <span class="token comment">// 添加或者覆盖旧值</span></span>
<span class="line">        <span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> newValue<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">return</span> newValue<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(0, 0, 0)"}},{default:i(()=>s[2529]||(s[2529]=[n("实现逻辑其实也很简单，其实就是结合了 Java 8 的函数式编程让代码变得更简单了，Java 也越来越聪明了。")])),_:1}),l(e,{style:{color:"rgb(0, 0, 0)"}},{default:i(()=>s[2530]||(s[2530]=[n("另外两个方法我就不演示了，在特定的场合肯定也肯定特别有用，大家知道就好，需要的时候要知道拿来用。")])),_:1}),a("h5",Li,[a("a",Mi,[a("span",null,[l(e,{style:{color:"rgb(0, 0, 0)"}},{default:i(()=>s[2531]||(s[2531]=[n("方法定义")])),_:1})])])]),s[3719]||(s[3719]=t(`<div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token comment">/* </span>
<span class="line">    * @since 1.8</span>
<span class="line">     */</span></span>
<span class="line">    <span class="token keyword">default</span> <span class="token class-name">V</span> <span class="token function">computeIfAbsent</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span></span>
<span class="line">            <span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> mappingFunction<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>mappingFunction<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token class-name">V</span> v<span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>v <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token class-name">V</span> newValue<span class="token punctuation">;</span></span>
<span class="line">            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newValue <span class="token operator">=</span> mappingFunction<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                <span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> newValue<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">                <span class="token keyword">return</span> newValue<span class="token punctuation">;</span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">        <span class="token keyword">return</span> v<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(0, 0, 0)"}},{default:i(()=>s[2532]||(s[2532]=[n("可以看到，该方法为java8 新增，具体怎么使用呢？下面以几个例子来说明下：")])),_:1}),l(e,{style:{color:"rgb(0, 0, 0)"}},{default:i(()=>s[2533]||(s[2533]=[n("java8 之前 我们判断 map中一个对象是否存在，如果不存在实例化 一个新的，实现如下：")])),_:1}),s[3720]||(s[3720]=t(`<div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ComputeIfAbsentTest01</span> <span class="token punctuation">{</span></span>
<span class="line">    </span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line"></span>
<span class="line">        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token class-name">Maps</span><span class="token punctuation">.</span><span class="token function">newHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">//java8 之前操作</span></span>
<span class="line">        list <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;list&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(0, 0, 0)"}},{default:i(()=>s[2534]||(s[2534]=[n("必须首先获取然后再做一步非空判断，那么 java8之后我们该如何实现了呢？")])),_:1}),s[3721]||(s[3721]=t(`<div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ComputeIfAbsentTest02</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line"></span>
<span class="line">        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token class-name">Maps</span><span class="token punctuation">.</span><span class="token function">newHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">//java8 之后的骚操作</span></span>
<span class="line">        list <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">computeIfAbsent</span><span class="token punctuation">(</span><span class="token string">&quot;list&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;World&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(0, 0, 0)"}},{default:i(()=>s[2535]||(s[2535]=[n("一行代码搞定 哈哈哈， 怎么理解上述的执行过程呢，下面来解读一下")])),_:1}),s[3722]||(s[3722]=t(`<div class="language-Java line-numbers-mode" data-highlighter="prismjs" data-ext="Java" data-title="Java"><pre class="language-Java"><code><span class="line">If the specified key is not already associated with a value (or is mapped to null, attempts to compute its value using the given mapping function and enters it into this map unless null.</span>
<span class="line"></span>
<span class="line">如果指定的key 不存在关联的值或者返回 Null,那么就会试着去执行传入的mappingFunction。</span>
<span class="line"></span>
<span class="line">对照上面的例子就是，如果从map中获取对应键值 list ，获取不到则执行Function, Function 的结果放入map中，并将该结果返回。</span>
<span class="line"></span>
<span class="line">default V computeIfAbsent(K key,Function&lt;? super K, ? extends V&gt; mappingFunction) {</span>
<span class="line">        Objects.requireNonNull(mappingFunction);</span>
<span class="line">        V v;</span>
<span class="line">        //获取的的value不存在</span>
<span class="line">        if ((v = get(key)) == null) {</span>
<span class="line">            V newValue;</span>
<span class="line">            //对传入key 应用 Function</span>
<span class="line">            if ((newValue = mappingFunction.apply(key)) != null) {</span>
<span class="line">                //新value放入map</span>
<span class="line">                put(key, newValue);</span>
<span class="line">                //返回新的value</span>
<span class="line">                return newValue;</span>
<span class="line">            }</span>
<span class="line">        }</span>
<span class="line">        //map中存在则直接返回</span>
<span class="line">        return v;</span>
<span class="line">    }</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),l(e,{style:{color:"rgb(0, 0, 0)"}},{default:i(()=>s[2536]||(s[2536]=[n("简单的应用场景：我们经常会遇到统计的问题，加入现在有一个字符串集合，需要统计其中字符串出现的次数，该如何实现呢？参照如下代码：")])),_:1}),s[3723]||(s[3723]=t(`<div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="language-java"><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ComputeIfAbsentTest03</span> <span class="token punctuation">{</span></span>
<span class="line">    </span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">//java8 实现计算功能统计字符串出现次数</span></span>
<span class="line">        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">&gt;</span></span> countMap <span class="token operator">=</span> <span class="token class-name">Maps</span><span class="token punctuation">.</span><span class="token function">newHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> source <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;world&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;welcome&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;welcome&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;simon&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> s <span class="token operator">:</span> source<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            countMap<span class="token punctuation">.</span><span class="token function">computeIfAbsent</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> key <span class="token operator">-&gt;</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>countMap<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1))])}const Ai=p(v,[["render",wi],["__file","base08.html.vue"]]),Ei=JSON.parse('{"path":"/blogs/docs/Java/collections/base08.html","title":"集合体系结构","lang":"en-US","frontmatter":{"title":"集合体系结构","date":"2024/09/28","tags":["集合体系结构"],"categories":["Java"],"hideComments":false},"headers":[{"level":2,"title":"集合体系结构","slug":"集合体系结构","link":"#集合体系结构","children":[]},{"level":2,"title":"List","slug":"list","link":"#list","children":[{"level":3,"title":"ArrayList","slug":"arraylist","link":"#arraylist","children":[]},{"level":3,"title":"LinkedList","slug":"linkedlist","link":"#linkedlist","children":[]},{"level":3,"title":"Vector 和 Stack","slug":"vector-和-stack","link":"#vector-和-stack","children":[]}]},{"level":2,"title":"Set","slug":"set","link":"#set","children":[{"level":3,"title":"HashSet","slug":"hashset","link":"#hashset","children":[]},{"level":3,"title":"LinkedHashSet","slug":"linkedhashset","link":"#linkedhashset","children":[]},{"level":3,"title":"TreeSet","slug":"treeset","link":"#treeset","children":[]}]},{"level":2,"title":"Queue","slug":"queue","link":"#queue","children":[{"level":3,"title":"ArrayDeque","slug":"arraydeque","link":"#arraydeque","children":[]},{"level":3,"title":"LinkedList","slug":"linkedlist-1","link":"#linkedlist-1","children":[]},{"level":3,"title":"PriorityQueue","slug":"priorityqueue","link":"#priorityqueue","children":[]}]},{"level":2,"title":"Map","slug":"map","link":"#map","children":[{"level":3,"title":"HashMap","slug":"hashmap","link":"#hashmap","children":[]},{"level":3,"title":"LinkedHashMap","slug":"linkedhashmap","link":"#linkedhashmap","children":[]},{"level":3,"title":"TreeMap","slug":"treemap","link":"#treemap","children":[]}]},{"level":2,"title":"ArrayList 详解（附源码）","slug":"arraylist-详解-附源码","link":"#arraylist-详解-附源码","children":[{"level":3,"title":"创建 ArrayList","slug":"创建-arraylist","link":"#创建-arraylist","children":[]},{"level":3,"title":"向 ArrayList 中添加元素","slug":"向-arraylist-中添加元素","link":"#向-arraylist-中添加元素","children":[]},{"level":3,"title":"右移操作符","slug":"右移操作符","link":"#右移操作符","children":[]},{"level":3,"title":"向指定 ArrayList 位置添加元素","slug":"向指定-arraylist-位置添加元素","link":"#向指定-arraylist-位置添加元素","children":[]},{"level":3,"title":"更新 ArrayList 中的元素","slug":"更新-arraylist-中的元素","link":"#更新-arraylist-中的元素","children":[]},{"level":3,"title":"删除 ArrayList 中的元素","slug":"删除-arraylist-中的元素","link":"#删除-arraylist-中的元素","children":[]},{"level":3,"title":"查找 ArrayList 中的元素","slug":"查找-arraylist-中的元素","link":"#查找-arraylist-中的元素","children":[]},{"level":3,"title":"二分查找法","slug":"二分查找法","link":"#二分查找法","children":[]},{"level":3,"title":"ArrayList增删改查时的时间复杂度","slug":"arraylist增删改查时的时间复杂度","link":"#arraylist增删改查时的时间复杂度","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}]},{"level":2,"title":"LinkedList","slug":"linkedlist-2","link":"#linkedlist-2","children":[{"level":3,"title":"招式一：增","slug":"招式一-增","link":"#招式一-增","children":[]},{"level":3,"title":"招式二：删","slug":"招式二-删","link":"#招式二-删","children":[]},{"level":3,"title":"招式三：改","slug":"招式三-改","link":"#招式三-改","children":[]},{"level":3,"title":"招式四：查","slug":"招式四-查","link":"#招式四-查","children":[]},{"level":3,"title":"LinkedList 的挑战","slug":"linkedlist-的挑战","link":"#linkedlist-的挑战","children":[]},{"level":3,"title":"LinkedList 的应用","slug":"linkedlist-的应用","link":"#linkedlist-的应用","children":[]}]},{"level":2,"title":"栈 Stack 详解","slug":"栈-stack-详解","link":"#栈-stack-详解","children":[{"level":3,"title":"栈数据结构","slug":"栈数据结构","link":"#栈数据结构","children":[]},{"level":3,"title":"自定义栈","slug":"自定义栈","link":"#自定义栈","children":[]},{"level":3,"title":"Stack 类","slug":"stack-类","link":"#stack-类","children":[]},{"level":3,"title":"小结","slug":"小结","link":"#小结","children":[]}]},{"level":2,"title":"HashMap 详解（附源码）","slug":"hashmap-详解-附源码","link":"#hashmap-详解-附源码","children":[{"level":3,"title":"HashMap 增删改查的简单例子","slug":"hashmap-增删改查的简单例子","link":"#hashmap-增删改查的简单例子","children":[]},{"level":3,"title":"hash 方法的原理","slug":"hash-方法的原理","link":"#hash-方法的原理","children":[]},{"level":3,"title":"HashMap 的扩容机制","slug":"hashmap-的扩容机制","link":"#hashmap-的扩容机制","children":[]},{"level":3,"title":"加载因子为什么是 0.75","slug":"加载因子为什么是-0-75","link":"#加载因子为什么是-0-75","children":[]},{"level":3,"title":"线程不安全","slug":"线程不安全","link":"#线程不安全","children":[]},{"level":3,"title":"小结","slug":"小结-5","link":"#小结-5","children":[]}]},{"level":2,"title":"LinkedHashMap 详解","slug":"linkedhashmap-详解","link":"#linkedhashmap-详解","children":[{"level":3,"title":"插入顺序","slug":"插入顺序","link":"#插入顺序","children":[]},{"level":3,"title":"访问顺序","slug":"访问顺序","link":"#访问顺序","children":[]},{"level":3,"title":"LRU 缓存","slug":"lru-缓存","link":"#lru-缓存","children":[]},{"level":3,"title":"小结","slug":"小结-6","link":"#小结-6","children":[]}]},{"level":2,"title":"TreeMap 详解","slug":"treemap-详解","link":"#treemap-详解","children":[{"level":3,"title":"自然顺序","slug":"自然顺序","link":"#自然顺序","children":[]},{"level":3,"title":"自定义排序","slug":"自定义排序","link":"#自定义排序","children":[]},{"level":3,"title":"排序的好处","slug":"排序的好处","link":"#排序的好处","children":[]},{"level":3,"title":"如何选择 Map","slug":"如何选择-map","link":"#如何选择-map","children":[]}]},{"level":2,"title":"双端队列 ArrayDeque","slug":"双端队列-arraydeque","link":"#双端队列-arraydeque","children":[{"level":3,"title":"栈和队列","slug":"栈和队列","link":"#栈和队列","children":[]},{"level":3,"title":"方法剖析","slug":"方法剖析","link":"#方法剖析","children":[]},{"level":3,"title":"小结","slug":"小结-7","link":"#小结-7","children":[]}]},{"level":2,"title":"优先队列 PriorityQueue","slug":"优先队列-priorityqueue","link":"#优先队列-priorityqueue","children":[{"level":3,"title":"PriorityQueue的作用","slug":"priorityqueue的作用","link":"#priorityqueue的作用","children":[]},{"level":3,"title":"方法剖析","slug":"方法剖析-1","link":"#方法剖析-1","children":[]},{"level":3,"title":"小结","slug":"小结-8","link":"#小结-8","children":[]}]},{"level":2,"title":"ArrayList 和 LinkedList 区别","slug":"arraylist-和-linkedlist-区别","link":"#arraylist-和-linkedlist-区别","children":[{"level":3,"title":"ArrayList 是如何实现的？","slug":"arraylist-是如何实现的","link":"#arraylist-是如何实现的","children":[]},{"level":3,"title":"LinkedList 是如何实现的？","slug":"linkedlist-是如何实现的","link":"#linkedlist-是如何实现的","children":[]},{"level":3,"title":"新增元素时究竟谁快？","slug":"新增元素时究竟谁快","link":"#新增元素时究竟谁快","children":[]},{"level":3,"title":"删除元素时究竟谁快？","slug":"删除元素时究竟谁快","link":"#删除元素时究竟谁快","children":[]},{"level":3,"title":"遍历元素时究竟谁快？","slug":"遍历元素时究竟谁快","link":"#遍历元素时究竟谁快","children":[]},{"level":3,"title":"两者的使用场景","slug":"两者的使用场景","link":"#两者的使用场景","children":[]}]},{"level":2,"title":"Iterator 和 Iterable 区别","slug":"iterator-和-iterable-区别","link":"#iterator-和-iterable-区别","children":[]},{"level":2,"title":"foreach 循环陷阱","slug":"foreach-循环陷阱","link":"#foreach-循环陷阱","children":[]},{"level":2,"title":"Comparable 和 Comparator","slug":"comparable-和-comparator","link":"#comparable-和-comparator","children":[{"level":3,"title":"Comparable","slug":"comparable","link":"#comparable","children":[]},{"level":3,"title":"Comparator","slug":"comparator","link":"#comparator","children":[]},{"level":3,"title":"到底该用哪一个？","slug":"到底该用哪一个","link":"#到底该用哪一个","children":[]}]},{"level":2,"title":"WeakHashMap 详解","slug":"weakhashmap-详解","link":"#weakhashmap-详解","children":[{"level":3,"title":"WeakHashMap如何不阻止对象回收呢","slug":"weakhashmap如何不阻止对象回收呢","link":"#weakhashmap如何不阻止对象回收呢","children":[]},{"level":3,"title":"如何删除被回收的key数据呢","slug":"如何删除被回收的key数据呢","link":"#如何删除被回收的key数据呢","children":[]}]},{"level":2,"title":"","slug":"-1","link":"#-1","children":[]},{"level":2,"title":"compute 简介(Java 8 新增)","slug":"compute-简介-java-8-新增","link":"#compute-简介-java-8-新增","children":[{"level":3,"title":"compute有啥用?","slug":"compute有啥用","link":"#compute有啥用","children":[]},{"level":3,"title":"compute 源码分析","slug":"compute-源码分析","link":"#compute-源码分析","children":[]}]}],"git":{"createdTime":1727709468000,"updatedTime":1727709468000,"contributors":[{"name":"橘子掀开夜晚","email":"487331044@qq.com","commits":1}]},"filePathRelative":"blogs/docs/Java/collections/base08.md"}');export{Ai as comp,Ei as data};
